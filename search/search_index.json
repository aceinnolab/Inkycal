{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Inkycal Documentation","text":"<p>Welcome to the official documentation for Inkycal \u2014 a modular, customizable information dashboard for Raspberry Pi\u2013powered E-Paper displays.</p> <p>Inkycal turns your E-Paper display into a beautiful always-on dashboard capable of showing:</p> <ul> <li>Calendars &amp; schedules  </li> <li>Weather forecasts  </li> <li>Task lists  </li> <li>Photos &amp; images  </li> <li>Custom Python-based modules  </li> </ul> <p>All rendered as crisp, low-power e-paper graphics.</p>"},{"location":"#what-is-inkycal","title":"\ud83d\ude80 What is Inkycal?","text":"<p>Inkycal is a Python application designed to generate and display information dashboards on Waveshare and Papirus e-paper displays. It includes:</p> <p>\u2714 Modular architecture \u2714 Beautiful templates \u2714 Battery-friendly rendering \u2714 Support for colour e-paper (black, white, red/yellow) \u2714 Remote configuration through a web UI \u2714 Automatic boot-startup \u2714 PiSugar battery support  </p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li> <p>Modular Design   Add, remove, or reorder modules like Calendar, Weather, Images, and more.</p> </li> <li> <p>E-Paper Optimized Rendering   Includes ghosting prevention, calibration cycles, and reduced colour palettes.</p> </li> <li> <p>Web-Based Configuration UI   Create your <code>settings.json</code> directly from the cloud.</p> </li> <li> <p>Runs on Raspberry Pi Zero, Zero W, Zero 2 W, Pi 3/4/5   Optimized for low-power devices.</p> </li> <li> <p>Pre-built InkycalOS Image (optional)   A ready-to-boot SD card image that includes everything preconfigured.</p> </li> </ul>"},{"location":"#installation-options","title":"\ud83d\udce6 Installation Options","text":"<p>Choose the method that suits you best:</p>"},{"location":"#1-raspberry-pi-installation","title":"1. Raspberry Pi Installation","text":"<p>Install Inkycal manually on Raspberry Pi OS (Lite recommended). \u2192 See: Installation Guide</p>"},{"location":"#2-install-via-pip-no-e-paper-dev-mode","title":"2. Install via pip (no e-paper, dev mode)","text":"<p>Ideal for development or testing modules. \u2192 See: Installing on non-GPIO devices</p>"},{"location":"#3-inkycalos-lite-recommended","title":"3. InkycalOS Lite (Recommended)","text":"<p>Preconfigured SD card image with everything set up: Just add your <code>settings.json</code> and boot.</p>"},{"location":"#documentation-overview","title":"\ud83d\udcc1 Documentation Overview","text":"<p>This documentation is divided into the following sections:</p> Section Description Installation Set up Inkycal on Raspberry Pi or another device Quickstart Your first Inkycal run in 3 minutes Modules Full API and configuration docs for all built-in modules Developing Modules Learn how to build your own custom modules Display Drivers Supported e-paper models and driver notes Troubleshooting Common issues, calibration, ghosting, slow boot, etc."},{"location":"#supported-e-paper-displays","title":"\ud83e\udde9 Supported E-Paper Displays","text":"<p>Inkycal supports most Waveshare E-Paper displays:</p> <ul> <li>5.83\", 7.5\", 9.7\", 10.3\", 12.48\", 13.3\" displays</li> <li>Black/White and Black/White/Red or Yellow or 16 grayscale displays</li> <li>SPI interface required  </li> </ul> <p>For a full list, see: Supported Displays</p>"},{"location":"#system-requirements","title":"\ud83d\udee0 System Requirements","text":"<ul> <li>Raspberry Pi Zero / Zero W / Zero 2 W / Pi 3 / 4 / 5 </li> <li>Raspberry Pi OS Lite (Bookworm or Bullseye recommended)  </li> <li>SPI enabled  </li> <li>Python 3.11\u20133.13  </li> <li>At least a 4GB SD card  </li> </ul> <p>Optional:</p> <ul> <li>PiSugar battery module  </li> <li>WiFi connectivity for weather/calendar modules  </li> </ul>"},{"location":"#getting-started","title":"\ud83d\udcc4 Getting Started","text":"<ol> <li>Create your module layout using the Inkycal web UI </li> <li>Download your <code>settings.json</code> </li> <li>Copy it to your Pi  </li> <li>Run:</li> </ol> <pre><code>python inky_run.py\n</code></pre> <p>Or let Inkycal start automatically on boot.</p> <p>\u27a1\ufe0f Continue to the full Quickstart Guide: \ud83d\udc49 Quickstart\ufffc</p>"},{"location":"#support-the-project","title":"\u2764\ufe0f Support the Project","text":"<p>Maintaining Inkycal takes a significant amount of time and resources. If you find this project useful, please consider supporting development:</p> <p>\ud83d\udc49 https://github.com/sponsors/aceisace</p> <p>Sponsors also get access to InkycalOS Lite, the pre-built SD card image that saves hours of setup time.</p>"},{"location":"#need-help","title":"\ud83d\udcec Need Help?","text":"<p>If you run into problems:</p> <ul> <li>See the Troubleshooting section </li> <li>Open an issue on GitHub </li> <li>Or join the community discussions</li> </ul>"},{"location":"about/","title":"\ud83d\uddbc\ufe0f About Inkycal","text":"<p>Inkycal is an open-source framework designed to turn e-paper displays into elegant, low-power information dashboards. It runs on the Raspberry Pi and generates beautiful, personalized screens based on modular building blocks such as calendars, weather forecasts, news feeds, reminders, and more.</p> <p>Inkycal focuses on being:</p> <ul> <li>Minimalistic \u2014 clean layouts optimized for e-paper  </li> <li>Modular \u2014 each component is self-contained and configurable  </li> <li>Energy-efficient \u2014 ideal for Raspberry Pi Zero + e-paper  </li> <li>Hackable \u2014 every part of the pipeline is open and extendable  </li> </ul>"},{"location":"about/#what-inkycal-does","title":"\ud83c\udfaf What Inkycal Does","text":"<p>Inkycal produces an image and displays it on an e-paper device. That image can include:</p> <ul> <li>\ud83d\udcc5 Monthly calendars  </li> <li>\u2600\ufe0f Weather forecasts with professional icons  </li> <li>\ud83d\udcf0 RSS news headlines  </li> <li>\ud83d\udcc6 Upcoming events from iCalendar / Google Calendar  </li> <li>\ud83d\udcc8 Charts, reminders, custom messages  </li> <li>\ud83d\udd52 Clocks, countdowns, timers  </li> <li>\ud83d\udca4 Screensavers  </li> </ul> <p>Each module is responsible for drawing a part of the screen. You choose the modules, configure their sizes, and Inkycal renders the final image.</p>"},{"location":"about/#how-it-works","title":"\ud83e\udde9 How It Works","text":""},{"location":"about/#1-configuration-via-web-ui","title":"1. Configuration via Web UI","text":"<p>Users visit the Inkycal Web UI and generate a <code>settings.json</code> file, which defines:</p> <ul> <li>Display type  </li> <li>Registered modules  </li> <li>Ordering &amp; layout  </li> <li>Module-specific settings  </li> <li>Timezone + locale  </li> </ul>"},{"location":"about/#2-rendering-on-raspberry-pi","title":"2. Rendering on Raspberry Pi","text":"<p>Inkycal loads the configuration, creates a canvas, and asks each module to draw its content.</p>"},{"location":"about/#3-output-to-e-paper-driver","title":"3. Output to E-Paper Driver","text":"<p>The generated monochrome (and optionally colour) images are sent to:</p> <ul> <li>Waveshare displays  </li> <li>Custom drivers (via plugin system)</li> </ul>"},{"location":"about/#architecture-overview","title":"\ud83d\udce6 Architecture Overview","text":"<p>settings.json \u2192 Inkycal Core \u2192 Module Pipeline \u2192 Canvas \u2192 Display Driver \u2192 E-Paper</p>"},{"location":"about/#core-components","title":"Core components:","text":"Component Purpose <code>Inkycal</code> (main class) Loads settings, initializes modules &amp; display <code>Canvas</code> Handles text rendering, fonts, layout, drawing <code>Modules</code> Individual blocks (calendar, weather, custom text, etc.) <code>Display</code> Hardware-specific driver abstraction <code>utils</code> Fonts, timezones, wrapping, border drawing"},{"location":"about/#modules-extendable-architecture","title":"\ud83e\uddf1 Modules (Extendable Architecture)","text":"<p>Modules are small Python classes that each render a part of the final screen.</p> <p>Built-in modules include:</p> <ul> <li><code>Calendar</code></li> <li><code>WeatherForecast</code></li> <li><code>RSSReader</code></li> <li><code>ImageFrame</code></li> <li><code>Clock</code></li> <li><code>CustomText</code></li> </ul> <p>You can write your own module by subclassing:</p> <pre><code>from inkycal.modules.base import InkycalModule\n\nclass MyModule(InkycalModule):\n    def generate_image(self):\n        # Draw on canvas\n        return im_black, im_colour\n</code></pre> <p>More detailed module development docs will be added in the Developer Guide.</p>"},{"location":"about/#internationalization","title":"\ud83c\udf0d Internationalization","text":"<p>Inkycal supports: * Multiple languages * Localized month and weekday names * Custom date/time formatting (arrow tokens) * Unicode fonts including CJK (Chinese/Japanese/Korean)</p> <p>The built-in Noto font family ensures wide glyph coverage.</p>"},{"location":"about/#performance-hardware-targets","title":"\u26a1 Performance &amp; Hardware Targets","text":"<p>Inkycal is optimized for slow hardware such as:</p> <ul> <li>Raspberry Pi Zero W</li> <li>Pi Zero 2</li> <li>Raspberry Pi 3/4 (faster rendering)</li> </ul> <p>Key performance features:</p> <ul> <li>Font caching</li> <li>Minimal RAM usage</li> <li>Efficient grayscale-to-bi-level rendering</li> <li>Optional image optimization for e-paper ghosting reduction</li> </ul>"},{"location":"about/#why-inkycal-exists","title":"\u2764\ufe0f Why Inkycal Exists","text":"<p>E-paper displays are uniquely suited for: * Static, glanceable information * Environments where a full monitor is wasteful * Always-on dashboards that draw no power after an update * Low-maintenance IoT devices * Minimalist home and office setups</p> <p>Inkycal aims to bring premium-quality layouts to affordable hardware, without requiring deep programming knowledge.</p>"},{"location":"about/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Inkycal is open to contributions from developers, designers, and testers.</p> <p>Ways to help:</p> <ul> <li>Report issues and suggest features</li> <li>Contribute new modules</li> <li>Improve documentation</li> <li>Help with translations</li> <li>Sponsor ongoing development</li> </ul>"},{"location":"about/#support-community","title":"\ud83d\udcac Support &amp; Community","text":"<p>You can reach the project through:</p> <ul> <li>GitHub Issues</li> <li>Discussions (soon)</li> <li>Sponsor messages</li> <li>Documentation site</li> </ul> <p>If you rely on Inkycal for your daily routine, please consider supporting the project as it funds ongoing maintenance, display testing, and PiZero optimizations.</p>"},{"location":"about/#whats-next","title":"\ud83d\ude80 What\u2019s Next?","text":"<p>The roadmap includes:</p> <ul> <li>More built-in modules</li> <li>A plugin system for third-party modules</li> <li>Improved layout engine</li> <li>Live preview in Web UI</li> <li>Multi-display setups</li> <li>InkycalOS full desktop environment</li> </ul>"},{"location":"about/#acknowledgements","title":"\ud83d\ude4f Acknowledgements","text":"<p>Inkycal uses:</p> <ul> <li>Pillow for image rendering</li> <li>Arrow for datetime operations</li> <li>Requests for network modules</li> <li>tzlocal for system timezone detection</li> <li>Numpy for pixel-level operations</li> <li>Sphinx / MkDocs for documentation</li> <li>A modified Waveshare driver base</li> </ul> <p>Special thanks to the Inkycal community for testing and for their amazing custom module ideas.</p>"},{"location":"dev_doc/","title":"\ud83d\udee0\ufe0f Developer Guide","text":"<p>This document explains how to build custom modules for Inkycal, how modules interact with the core system, how to structure clean and reliable image generation code, and how to register your module with the Inkycal runtime.</p> <p>If you want a minimal starting point, scroll to Module Template below.</p>"},{"location":"dev_doc/#what-is-an-inkycal-module","title":"\ud83d\udce6 What Is an Inkycal Module?","text":"<p>A module in Inkycal is a self-contained unit that:</p> <ul> <li>receives configuration from the <code>settings.json</code> file,</li> <li>generates an image (black + colour layer),</li> <li>fits into a layout region managed by the Inkycal core,</li> <li>can specify required &amp; optional Web-UI configuration fields.</li> </ul> <p>Modules must subclass <code>InkycalModule</code>, which defines the interface and base behavior.</p>"},{"location":"dev_doc/#module-lifecycle","title":"\ud83e\uddec Module Lifecycle","text":"<p>Every module follows the same three steps:</p>"},{"location":"dev_doc/#1-initialization","title":"1. Initialization","text":"<p>Receives its config. Sets width, height, padding, font, fontsize.</p>"},{"location":"dev_doc/#2-optional-validation","title":"2. (Optional) Validation","text":"<p>Ensures its parameters are meaningful.</p>"},{"location":"dev_doc/#3-image-generation","title":"3. Image generation","text":"<p>Builds the actual e-paper image content via <code>generate_image()</code>. The image is finally combined with others by Inkycal and rendered on the display.</p>"},{"location":"dev_doc/#anatomy-of-a-module","title":"\ud83e\udde9 Anatomy of a Module","text":"<p>All modules inherit from:</p> <pre><code>class InkycalModule(metaclass=abc.ABCMeta):\n    ...\n</code></pre>"},{"location":"dev_doc/#key-inherited-attributes","title":"Key inherited attributes","text":"Attribute Description <code>self.width, self.height</code> Module region size in pixels <code>self.padding_left</code>, <code>self.padding_top</code> Padding around your module <code>self.fontsize</code>, <code>self.font</code> Default font settings <code>self.config</code> Dict of module config parameters"},{"location":"dev_doc/#required-method","title":"Required method","text":"<p>Each module must implement:</p> <pre><code>def generate_image(self):\n    \"\"\"Return (image_black, image_colour)\"\"\"\n</code></pre> <p>This is where all drawing happens.</p>"},{"location":"dev_doc/#defining-module-parameters-web-ui-integration","title":"\u2699\ufe0f Defining Module Parameters (Web-UI Integration)","text":"<p>Modules declare configuration fields using two dictionaries:</p>"},{"location":"dev_doc/#requires-mandatory-fields","title":"<code>requires</code> (mandatory fields)","text":"<p>These fields must be provided in the Web-UI or an error is raised.</p> <pre><code>requires = {\n    \"api_key\": {\"label\": \"Your API key\"},\n    \"username\": {\"label\": \"Enter your username\"},\n}\n</code></pre>"},{"location":"dev_doc/#optional-ui-exposed-but-not-required","title":"<code>optional</code> (UI-exposed but not required)","text":"<pre><code>optional = {\n    \"hobbies\": {\"label\": \"Hobbies (comma-separated)\"},\n    \"age\": {\"label\": \"Your age\", \"default\": 18},\n    \"likes_inkycal\": {\n        \"label\": \"Do you like Inkycal?\",\n        \"options\": [True, False],\n    },\n}\n</code></pre> <p><code>options</code> turns the field into a dropdown menu in the Web-UI.</p>"},{"location":"dev_doc/#how-web-ui-input-works","title":"\ud83e\udde0 How Web-UI Input Works","text":"<p>The browser can only send:</p> <ul> <li>strings,</li> <li>booleans,</li> <li>empty values (<code>None</code>).</li> </ul> <p>Convert types manually inside <code>__init__()</code>:</p> <pre><code>if config[\"age\"] and isinstance(config[\"age\"], str):\n    self.age = int(config[\"age\"])\nelse:\n    self.age = 18\n</code></pre> <p>List conversion:</p> <pre><code>self.hobbies = config[\"hobbies\"].split(\",\") if config[\"hobbies\"] else []\n</code></pre>"},{"location":"dev_doc/#rendering-images-with-canvas","title":"\ud83c\udfa8 Rendering Images with Canvas","text":"<p>The Canvas class is the recommended way to draw on images.</p>"},{"location":"dev_doc/#create-a-canvas","title":"Create a canvas:","text":"<pre><code>from inkycal.utils.canvas import Canvas\n\ncanvas = Canvas(im_size=(width, height), font=self.font, font_size=self.fontsize)\n</code></pre>"},{"location":"dev_doc/#write-text","title":"Write text:","text":"<pre><code>canvas.write(\n    xy=(0, 0),\n    box_size=(200, 40),\n    text=\"Hello World!\",\n    alignment=\"center\"\n)\n</code></pre>"},{"location":"dev_doc/#draw-coloured-text","title":"Draw coloured text:","text":"<pre><code>canvas.write(\n    xy=(0,0),\n    box_size=(200,40),\n    text=\"Hello!\",\n    colour=\"colour\"\n)\n</code></pre>"},{"location":"dev_doc/#return-the-final-images","title":"Return the final images:","text":"<pre><code>return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"dev_doc/#optional-validation-step","title":"\ud83e\uddea Optional Validation Step","text":"<p>Modules may implement <code>_validate()</code> to check logic:</p> <pre><code>def _validate(self):\n    if not isinstance(self.age, int):\n        raise ValueError(\"Age must be an integer\")\n</code></pre> <p>This runs automatically when calling <code>set(help=False, ...)</code> from the API.</p>"},{"location":"dev_doc/#full-minimal-example-module","title":"\ud83d\uddbc\ufe0f Full Minimal Example Module","text":"<pre><code>import logging\nfrom inkycal.modules.template import InkycalModule\nfrom inkycal.utils.canvas import Canvas\n\nlogger = logging.getLogger(__name__)\n\nclass Simple(InkycalModule):\n    name = \"Simple - Hello World\"\n\n    requires = {\n        \"username\": {\"label\": \"Your name\"}\n    }\n\n    optional = {\n        \"show_smiley\": {\n            \"label\": \"Show a smiley?\",\n            \"options\": [True, False],\n            \"default\": True,\n        }\n    }\n\n    def __init__(self, config):\n        super().__init__(config)\n        cfg = config[\"config\"]\n\n        self.username = cfg[\"username\"]\n        self.show_smiley = bool(cfg.get(\"show_smiley\", True))\n\n    def generate_image(self):\n        w = self.width - 2 * self.padding_left\n        h = self.height - 2 * self.padding_top\n\n        canvas = Canvas(im_size=(w, h), font=self.font, font_size=self.fontsize)\n\n        text = f\"Hello {self.username}\"\n        if self.show_smiley:\n            text += \" \ud83d\ude42\"\n\n        canvas.write(xy=(0, 0), box_size=(w, h), text=text)\n\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"dev_doc/#registering-your-module","title":"\u2795 Registering Your Module","text":"<p>You must tell Inkycal where to find your new module.</p>"},{"location":"dev_doc/#1-update-inkycalmodules__init__py","title":"1. Update <code>inkycal/modules/__init__.py</code>","text":"<pre><code>from .simple import Simple\n</code></pre>"},{"location":"dev_doc/#2-update-inkycal__init__py","title":"2. Update <code>inkycal/__init__.py</code>","text":"<pre><code>import inkycal.modules.simple\n</code></pre> <p>Your module is now available inside the Web-UI.</p>"},{"location":"dev_doc/#debugging-techniques","title":"\ud83e\udded Debugging Techniques","text":""},{"location":"dev_doc/#preview-without-hardware","title":"Preview without hardware:","text":"<pre><code>black, colour = module.generate_image()\nblack.show()\ncolour.show()\n</code></pre>"},{"location":"dev_doc/#save-previews","title":"Save previews:","text":"<pre><code>black.save(\"preview_black.png\")\ncolour.save(\"preview_colour.png\")\n</code></pre>"},{"location":"dev_doc/#logging","title":"Logging:","text":"<pre><code>logger.debug(\"Value is %s\", my_value)\n</code></pre> <p>Logs on the Pi are stored at:</p> <pre><code>/var/log/inkycal.log\n</code></pre>"},{"location":"dev_doc/#advanced-development-tips","title":"\ud83d\ude80 Advanced Development Tips","text":""},{"location":"dev_doc/#1-multi-section-layouts","title":"1. Multi-section layouts","text":"<p>You can subdivide your module region and use multiple canvas objects.</p>"},{"location":"dev_doc/#2-use-external-apis","title":"2. Use external APIs","text":"<p>Modules can fetch weather, calendar, news, etc.</p>"},{"location":"dev_doc/#3-icon-rendering","title":"3. Icon rendering","text":"<p>The Canvas provides <code>draw_icon()</code> to render SVG-style icons cleanly and centered.</p>"},{"location":"dev_doc/#4-enhanced-performance","title":"4. Enhanced performance","text":"<p>Cache API responses to speed up repeated renders.</p>"},{"location":"dev_doc/#youre-ready-to-build-modules","title":"\ud83c\udf89 You're Ready to Build Modules!","text":"<p>You now know how to:</p> <ul> <li>Define required/optional fields</li> <li>Parse Web-UI configuration correctly</li> <li>Use Canvas to render clean layouts</li> <li>Debug and preview without e-paper hardware</li> <li>Register your module with Inkycal</li> </ul> <p>If you want to add:</p> <ul> <li>A Module API Reference</li> <li>A Layout Design Guide</li> <li>A Testing Guide (pytest/unittest)</li> <li>A Module Generator Tool</li> </ul> <p>Just tell me \u2014 I can create those too!</p>"},{"location":"hardware/","title":"\ud83d\udee0\ufe0f Hardware Setup Guide","text":"<p>This guide explains everything you need to physically assemble, connect, and prepare your hardware for running Inkycal. It covers supported displays, wiring, tools, troubleshooting, and best practices.</p> <p>Whether you're using a Raspberry Pi Zero, Pi 3/4, or another board, this page ensures your device is safely and correctly connected.</p>"},{"location":"hardware/#supported-hardware","title":"\ud83d\udce6 Supported Hardware","text":"<p>Inkycal works with:</p>"},{"location":"hardware/#raspberry-pi-boards","title":"\u2714 Raspberry Pi boards","text":"<ul> <li>Raspberry Pi Zero / Zero W / Zero 2 W  </li> <li>Raspberry Pi 3 (all models)  </li> <li>Raspberry Pi 4 (all models)  </li> <li>Raspberry Pi 5 (supported; SPI must be enabled)  </li> </ul> <p>Tip: Zero W and Zero 2 W are most popular due to low power usage.</p>"},{"location":"hardware/#supported-epaper-displays","title":"\u2714 Supported ePaper Displays","text":"<p>Inkycal works with Waveshare ePaper displays using the official drivers. Common supported models include (but are not limited to):</p> Size Type Colour support Notes 2.7\" BW No Simple and fast refresh 4.2\" BW or Red Some models support red/yellow 5.83\" BW or Colour Popular choice 7.5\" BW or Colour Recommended for Inkycal 9.7\" BW Requires optimization disabled 12.48\" BW Requires bcm2835 drivers <p>Full list is returned by:</p> <pre><code>from inkycal.display import Display\nprint(Display.get_display_names())\n</code></pre>"},{"location":"hardware/#pins-wiring","title":"\ud83d\udd0c Pins &amp; Wiring","text":"<p>Most Waveshare ePaper displays connect via the 40-pin GPIO header using SPI.</p>"},{"location":"hardware/#standard-spi-wiring-waveshare-hat-or-breakout","title":"Standard SPI Wiring (Waveshare HAT or breakout)","text":"Signal Pi Pin Description VCC 3.3V Power supply GND GND Ground DIN GPIO 10 MOSI CLK GPIO 11 SCLK CS GPIO 8 Chip select DC GPIO 25 Data/Command RST GPIO 17 Reset BUSY GPIO 24 Busy status <p>If you're using a Waveshare ePaper HAT, these connections are already made\u2014no soldering needed.</p>"},{"location":"hardware/#enabling-spi-on-raspberry-pi","title":"\ud83d\udd27 Enabling SPI on Raspberry Pi","text":"<p>The ePaper display will not work unless SPI is enabled.</p> <p>Enable it using either:</p>"},{"location":"hardware/#option-a-raspberry-pi-os-bookworm-bullseye","title":"Option A \u2014 Raspberry Pi OS (Bookworm / Bullseye)","text":"<pre><code>sudo raspi-config\n</code></pre> <p>Navigate to:</p> <pre><code>Interface Options \u2192 SPI \u2192 Enable\n</code></pre> <p>Reboot when prompted.</p>"},{"location":"hardware/#option-b-modify-config-manually","title":"Option B \u2014 Modify config manually","text":"<pre><code>sudo sed -i s/#dtparam=spi=on/dtparam=spi=on/ /boot/firmware/config.txt\n</code></pre>"},{"location":"hardware/#optional-pisugar-support","title":"\ud83d\udd0b Optional: PiSugar Support","text":"<p>PiSugar boards allow battery-powered Inkycal devices with deep-sleep scheduling.</p> <p>Benefits: - Weeks of battery life - Auto-shutdown on low battery - Auto-wake timer - Cleaner cable-free installation  </p> <p>Enable PiSugar support in settings.json:</p> <pre><code>\"use_pi_sugar\": true\n</code></pre> <p>More info: https://github.com/aceinnolab/Inkycal/wiki/PiSugar-support</p>"},{"location":"hardware/#power-requirements","title":"\u26a1 Power Requirements","text":"<p>Different displays draw significantly different power.</p> Display size Power usage Recommended power source 2\u20135\" Very low Pi Zero USB power 7.5\" Moderate 1A+ power supply 9.7\" High on refresh 2A power supply 12.48\" Highest Official Pi PSU strongly recommended <p>Never power the display from the Pi\u2019s 5V pin unless the manufacturer specifically instructs you to.</p>"},{"location":"hardware/#hardware-testing","title":"\ud83e\uddea Hardware Testing","text":"<p>After installation you can test SPI access:</p> <pre><code>ls /dev/spi*\n</code></pre> <p>Expected output:</p> <pre><code>/dev/spidev0.0\n/dev/spidev0.1\n</code></pre> <p>Then test display access via Inkycal:</p> <pre><code>from inkycal.display import Display\nd = Display(\"waveshare_7in5_colour\")\nd.render_text(\"Display works!\")\n</code></pre>"},{"location":"hardware/#troubleshooting","title":"\ud83d\udea8 Troubleshooting","text":""},{"location":"hardware/#display-stays-white","title":"\u274c Display stays white","text":"<ul> <li>SPI is disabled \u2192 enable via <code>raspi-config</code></li> <li>Incorrect wiring (BUSY / RST often reversed on clones)</li> <li>Wrong display model selected in settings.json</li> </ul>"},{"location":"hardware/#importerror-driver-not-found","title":"\u274c ImportError: driver not found","text":"<p>Model name isn't in <code>supported_models</code>.</p> <p>Check available names:</p> <pre><code>from inkycal.display import Display\nprint(Display.get_display_names())\n</code></pre>"},{"location":"hardware/#filenotfounderror-spi-device-not-found","title":"\u274c FileNotFoundError: SPI device not found","text":"<p>User is running Raspberry Pi OS inside a virtual machine \u2192 Use real hardware.</p> <p>Or:</p> <p>SPI disabled \u2192 enable it.</p>"},{"location":"hardware/#display-refreshes-but-shows-messyghosted-text","title":"\u274c Display refreshes but shows messy/ghosted text","text":"<p>Run calibration:</p> <pre><code>d = Display(\"waveshare_7in5_colour\")\nd.calibrate(3)\n</code></pre>"},{"location":"hardware/#1248-display-does-not-work","title":"\u274c 12.48\" display does not work","text":"<p>Requires bcm2835 driver:</p> <pre><code>wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.71.tar.gz\ntar zxvf bcm2835-1.71.tar.gz\ncd bcm2835-1.71/\nsudo ./configure &amp;&amp; sudo make &amp;&amp; sudo make check &amp;&amp; sudo make install\n</code></pre>"},{"location":"hardware/#mounting-enclosures","title":"\ud83d\uddbc\ufe0f Mounting &amp; Enclosures","text":"<p>Many users mount their ePaper display:</p> <ul> <li>in a picture frame  </li> <li>behind acrylic glass  </li> <li>inside a custom 3D-printed enclosure  </li> <li>on a wall using adhesive strips  </li> </ul>"},{"location":"hardware/#tips","title":"Tips","text":"<ul> <li>Do not press hard on the front surface.  </li> <li>Avoid static electricity (ePaper is sensitive).  </li> <li>Keep the flat flex cable relaxed \u2014 sharp bends can damage it.</li> </ul>"},{"location":"hardware/#maintenance","title":"\ud83e\uddfc Maintenance","text":"<p>ePaper displays last many years with proper use.</p> <p>Best practices:</p> <ul> <li>Calibrate every 5\u20137 refresh cycles </li> <li>Do not refresh excessively (avoid &gt;100 updates/day)  </li> <li>Use <code>optimize=False</code> for 9.7\" displays to avoid artefacts  </li> </ul>"},{"location":"hardware/#summary","title":"\ud83c\udf89 Summary","text":"<p>You now know how to:</p> <ul> <li>select and wire a compatible ePaper display  </li> <li>enable SPI and prepare Raspberry Pi OS  </li> <li>test the display using Inkycal  </li> <li>troubleshoot common hardware issues  </li> <li>safely mount and maintain your hardware  </li> </ul> <p>Once your hardware is ready, continue to:</p> <p>\ud83d\udc49 <code>installation</code> \ud83d\udc49 <code>quickstart</code></p>"},{"location":"inkycal/","title":"\ud83e\udde9 Inkycal Architecture Overview","text":"<p>Inkycal is designed to be modular, extensible, and hardware-friendly, while keeping the rendering pipeline predictable and fast across a wide range of e-paper displays.</p> <p>This document explains the software architecture, the life-cycle of a typical Inkycal run, and how modules, utilities, and rendering layers work together.</p>"},{"location":"inkycal/#high-level-architecture","title":"\ud83d\ude80 High-Level Architecture","text":"<pre><code>+-----------------------------+\n|        inky_run.py          |\n| (CLI entrypoint / startup)  |\n+--------------+--------------+\n               |\n               v\n+-----------------------------+\n|          Inkycal            |\n|  (main controller/runtime)  |\n+--------------+--------------+\n               |\n               +--&gt; Loads settings.json\n               +--&gt; Instantiates modules\n               +--&gt; Composes final image\n               +--&gt; Sends output to Display\n               |\n               v\n+-----------------------------+\n|         Modules             |\n| (Calendar, Weather, Image,  |\n|  plus user-defined modules) |\n+-----------------------------+\n               |\n               v\n+-----------------------------+\n|          Canvas             |\n|     abstract text + icon    |\n|     rendering \u2192 PIL images  |\n+-----------------------------+\n               |\n               v\n+-----------------------------+\n|          Display            |\n|   hardware communication    |\n| (SPI drivers for waveshare  |\n|    and other e-paper models)|\n+-----------------------------+\n</code></pre>"},{"location":"inkycal/#core-components","title":"\ud83e\udde0 Core Components","text":""},{"location":"inkycal/#1-inkycal-main-runtime","title":"1. <code>Inkycal</code> Main Runtime","text":"<p>Located in:</p> <pre><code>inkycal/main.py\n</code></pre> <p>Responsibilities:</p> <ul> <li>Loads settings.json</li> <li>Initializes the selected Display driver</li> <li>Loads and validates modules</li> <li>Calls <code>generate_image()</code> on each module</li> <li>Composes module images into a single display image</li> <li>Sends final images to the e-paper device</li> <li>Performs calibration (optional)</li> <li>Handles auto-shutdown (PiSugar)</li> </ul> <p>The main class acts as the \u201corchestrator\u201d of the entire system.</p>"},{"location":"inkycal/#2-modules-system","title":"2. Modules System","text":"<p>Modules live in:</p> <pre><code>inkycal/modules/\n</code></pre> <p>All modules inherit from:</p> <pre><code>InkycalModule\n</code></pre> <p>Each module: - Receives its config from the web-UI - Gets a drawing area with defined width, height, and padding - Generates two images: black (required) and colour (optional) - Uses <code>Canvas</code> for text, icons, borders, layout, etc. - Returns <code>(image_black, image_colour)</code> to the main controller</p> <p>Examples of built-in modules:</p> Module Purpose <code>Calendar</code> Monthly calendar + events <code>Weather</code> Forecasts + icons <code>Image</code> Arbitrary images/photos Custom modules Plug-and-play third-party extensions <p>Development documentation: \ud83d\udc49 <code>modules/custom.md</code> \ud83d\udc49 <code>dev_doc.md</code></p>"},{"location":"inkycal/#3-canvas-rendering-layer","title":"3. Canvas Rendering Layer","text":"<p>Located in:</p> <pre><code>inkycal/utils/canvas.py\n</code></pre> <p>The Canvas system abstracts all rendering:</p> <ul> <li>Text (auto-wrapping, multi-line, font scaling)</li> <li>Numeric alignment</li> <li>Weather icons</li> <li>Transparent overlays</li> <li>Red/black preview compositing</li> <li>Pixel optimization for e-paper constraints</li> </ul> <p>Canvas produces two separate images:</p> <pre><code>image_black\nimage_colour\n</code></pre> <p>These map directly to most tri-color e-paper devices.</p> <p>Full documentation: \ud83d\udc49 <code>api/canvas.md</code></p>"},{"location":"inkycal/#4-display-hardware-driver","title":"4. Display Hardware Driver","text":"<p>Drivers live in:</p> <pre><code>inkycal/display/drivers/\n</code></pre> <p>Each supported E-Paper model has its own driver implementing:</p> <ul> <li>SPI initialization</li> <li>Framebuffer conversion</li> <li>Refreshing behaviour</li> <li>Sleep and deep-sleep modes</li> </ul> <p>The <code>Display</code> class:</p> <ul> <li>Loads the appropriate driver</li> <li>Handles calibration cycles</li> <li>Handles resolution checks</li> <li>Calls <code>.display()</code> on the driver</li> </ul> <p>API reference: \ud83d\udc49 <code>api/display.md</code></p>"},{"location":"inkycal/#5-utility-helpers","title":"5. Utility Helpers","text":"<p>Found under:</p> <pre><code>inkycal/utils/\n</code></pre> <p>Includes:</p> <ul> <li>Timezone resolution (<code>get_system_tz</code>)</li> <li>Network availability checks</li> <li>Pixel operations</li> <li>Line chart rendering</li> <li>Font enumeration</li> <li>ICS calendar parsing</li> </ul> <p>Documentation: \ud83d\udc49 <code>api/utils.md</code></p>"},{"location":"inkycal/#rendering-pipeline","title":"\ud83d\udd04 Rendering Pipeline","text":"<p>Every Inkycal run follows the same flow:</p> <pre><code>User starts inky_run.py\n        |\n        v\n1. Inkycal loads settings.json\n2. Inkycal loads modules\n3. Each module generates:\n       image_black, image_colour\n4. Inkycal assembles module images into final canvas\n5. Display.init()\n6. Display.render(black, colour)\n7. Display.sleep()\n</code></pre> <p>If calibration is due:</p> <pre><code>8. Display.calibrate()\n</code></pre>"},{"location":"inkycal/#settings-to-modules-pipeline","title":"\ud83e\uddf1 Settings-to-Modules Pipeline","text":"<pre><code>settings.json\n    |\n    v\nInkycal\n    |\n    |-- loads module list\n    |-- validates required parameters\n    v\nModule(config)\n    |\n    |-- You get width, height, padding\n    |-- You create a Canvas(im_size)\n    v\ngenerate_image() \u2192 (black_img, colour_img)\n</code></pre>"},{"location":"inkycal/#module-layout-strategy","title":"\ud83e\udde9 Module Layout Strategy","text":"<p>Modules are rendered vertically in order defined in <code>settings.json</code>.</p> <p>Example:</p> <pre><code>+------------------------+\n|     Module 1 (Top)     |\n+------------------------+\n|     Module 2           |\n+------------------------+\n|     Module 3 (Bottom)  |\n+------------------------+\n</code></pre> <p>Each module receives a slice of the full display height.</p>"},{"location":"inkycal/#e-paper-rendering-constraints","title":"\ud83e\uddee E-Paper Rendering Constraints","text":"<p>E-Ink displays have unique limitations:</p> <ul> <li>Few colors (black / white / red or yellow)</li> <li>Slow refresh (2\u201330 seconds)</li> <li>Ghosting requires calibration cycles</li> <li>No partial refresh for many models</li> </ul> <p>Inkycal's rendering system:</p> <ul> <li>Converts images to 1-bit + red channels</li> <li>Avoids anti-aliasing unless necessary</li> <li>Uses optimized preview rendering for development</li> </ul>"},{"location":"inkycal/#directory-structure-overview","title":"\ud83d\uddc2\ufe0f Directory Structure Overview","text":"<pre><code>Inkycal/\n\u2502\n\u251c\u2500\u2500 inkycal/\n\u2502   \u251c\u2500\u2500 main.py           # Inkycal runtime\n\u2502   \u251c\u2500\u2500 display/          # E-Paper drivers\n\u2502   \u251c\u2500\u2500 modules/          # Built-in modules\n\u2502   \u251c\u2500\u2500 utils/            # Canvas, fonts, helpers\n\u2502   \u251c\u2500\u2500 settings.py       # Constants &amp; defaults\n\u2502   \u2514\u2500\u2500 web/              # Web UI (optional)\n\u2502\n\u251c\u2500\u2500 tests/                # Unit tests\n\u251c\u2500\u2500 docsource/            # Documentation\n\u251c\u2500\u2500 inky_run.py           # Main entrypoint\n\u2514\u2500\u2500 setup.py / pyproject   # Packaging\n</code></pre>"},{"location":"inkycal/#design-goals","title":"\ud83e\udde0 Design Goals","text":"<ul> <li> <p>Developer Friendly   Easy to extend via modules.</p> </li> <li> <p>Hardware Friendly   All rendering optimized for slow, low-power e-paper displays.</p> </li> <li> <p>Stable Public API   Modules and Canvas are stable interfaces.</p> </li> <li> <p>Safe Defaults   Calibration, ghosting protection, timezone detection, etc.</p> </li> </ul>"},{"location":"inkycal/#extending-inkycal","title":"\ud83e\uddea Extending Inkycal","text":"<p>To build a module:</p> <ol> <li>Create a file under <code>inkycal/modules/</code></li> <li>Subclass <code>InkycalModule</code></li> <li>Implement <code>generate_image()</code></li> <li>Register module in:</li> <li><code>inkycal/modules/__init__.py</code></li> <li><code>inkycal/__init__.py</code></li> </ol> <p>Development guides:</p> <p>\ud83d\udc49 <code>dev_doc.md</code> \ud83d\udc49 <code>modules/custom.md</code> </p>"},{"location":"inkycal/#summary","title":"\ud83c\udfaf Summary","text":"<p>Inkycal\u2019s architecture is centered on three main pillars:</p> <ol> <li>Modules \u2192 Provide pluggable content blocks  </li> <li>Canvas \u2192 Provides safe and consistent rendering  </li> <li>Display \u2192 Handles hardware-specific communication  </li> </ol> <p>This separation makes Inkycal:</p> <ul> <li>Maintainable  </li> <li>Extensible  </li> <li>Robust on slow hardware  </li> <li>Easy to debug and test  </li> </ul>"},{"location":"installation/","title":"\ud83d\udce6 Installation Guide","text":"<p>Welcome to the Inkycal installation guide. Whether you're installing Inkycal on a Raspberry Pi, setting it up on a desktop system, or using the preconfigured InkycalOS Lite image, this guide will walk you through each step.</p>"},{"location":"installation/#1-choose-your-installation-method","title":"\ud83d\ude80 1. Choose Your Installation Method","text":"<p>Inkycal can be installed in three different ways:</p> Method Recommended For Difficulty Notes InkycalOS Lite (preconfigured) Raspberry Pi Zero / Zero W \u2b50 Very Easy Fastest and most reliable method Install on Raspberry Pi OS Full control, custom setups \u2b50\u2b50 Medium Requires manual configuration Install on non-GPIO devices Development, preview, debugging \u2b50 Easy No display output"},{"location":"installation/#2-using-inkycalos-lite-recommended","title":"\ud83c\udfaf 2. Using InkycalOS Lite (Recommended)","text":"<p>If you want the fastest, most reliable installation, use the prebuilt InkycalOS Lite image.</p>"},{"location":"installation/#what-you-get","title":"\u2705 What you get:","text":"<ul> <li>Fully configured Raspberry Pi OS Lite  </li> <li>SPI enabled  </li> <li>Dependencies preinstalled  </li> <li>Inkycal installed &amp; autostart configured  </li> <li>Best possible performance on Pi Zero  </li> </ul>"},{"location":"installation/#how-to-get-it","title":"\ud83d\udce5 How to get it","text":"<p>InkycalOS Lite is available to supporters of the project. Check the GitHub Sponsors page or use the PayPal link provided in the repository README.</p>"},{"location":"installation/#installation-steps","title":"\u25b6\ufe0f Installation steps","text":"<ol> <li>Flash the downloaded <code>.img</code> file using Raspberry Pi Imager.</li> <li>Copy your <code>settings.json</code> to the boot partition.</li> <li>Insert the SD card and power the Pi.</li> <li>Inkycal boots automatically.</li> </ol> <p>You're done. \ud83c\udf89</p>"},{"location":"installation/#3-install-on-raspberry-pi-os-manual-installation","title":"\ud83d\udc0d 3. Install on Raspberry Pi OS (Manual Installation)","text":"<p>This method gives you full control. Recommended for advanced users, developers, or custom hardware setups.</p>"},{"location":"installation/#step-1-flash-raspberry-pi-os","title":"Step 1 \u2014 Flash Raspberry Pi OS","text":"<p>Use Raspberry Pi Imager and write:</p> <p>\u26a0\ufe0f Recommended version: Raspberry Pi OS Lite (bookworm) \u2014 the newest release may have kernel issues.</p> <p>Configure in Imager:</p> Setting Value Hostname <code>inkycal</code> SSH Enable Username choose one Password choose one Wi-Fi Configure if needed Timezone Your local timezone"},{"location":"installation/#step-2-prepare-the-sd-card","title":"Step 2 \u2014 Prepare the SD Card","text":"<ol> <li> <p>Generate your <code>settings.json</code> in the Inkycal Web UI https://inkycal.aceinnolab.com/ui</p> </li> <li> <p>Copy <code>settings.json</code> to the root of the SD card.</p> </li> </ol> <p>Insert the SD card into the Pi and boot.</p>"},{"location":"installation/#step-3-connect-via-ssh","title":"Step 3 \u2014 Connect via SSH","text":"<p>After ~2\u20133 minutes, connect:</p> <pre><code>ssh username@inkycal.local\n</code></pre> <p>(on Windows/macOS you can also use Termius)</p>"},{"location":"installation/#step-4-raspberry-pi-setup","title":"Step 4 \u2014 Raspberry Pi Setup","text":"<p>Expand filesystem:</p> <pre><code>sudo raspi-config --expand-rootfs\n</code></pre> <p>Enable SPI:</p> <pre><code># TODO: update ot use raspi-config, non-interactive\nsudo sed -i s/#dtparam=spi=on/dtparam=spi=on/ /boot/firmware/config.txt\n``\n\nSet timezone (optional):\n```sh\nsudo dpkg-reconfigure tzdata\n</code></pre> <p>Required for 12.48\" only:</p> <pre><code>wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.71.tar.gz\ntar zxvf bcm2835-1.71.tar.gz\ncd bcm2835-1.71/\nsudo ./configure &amp;&amp; sudo make &amp;&amp; sudo make check &amp;&amp; sudo make install\n</code></pre>"},{"location":"installation/#step-5-install-dependencies","title":"Step 5 \u2014 Install Dependencies","text":"<ul> <li>Update system:</li> </ul> <pre><code>sudo apt-get update -y\n</code></pre> <ul> <li>Enable swap (strongly recommended on the Raspberry Pi Zero)</li> </ul> <pre><code>sudo sh -c 'mkdir -p /etc/rpi/swap.conf.d &amp;&amp;\ncat &lt;&lt;EOF | cmp -s - /etc/rpi/swap.conf.d/80-use-swapfile.conf || cat &lt;&lt;EOF &gt;/etc/rpi/swap.conf.d/80-use-swapfile.conf\n[Main]\nMechanism=swapfile\n\n[File]\nFixedSizeMiB=1024\nEOF\nEOF'\n</code></pre> <ul> <li>Prevent memory overflow while installing:</li> </ul> <pre><code>export TMPDIR=/var/tmp\n</code></pre> <ul> <li>Install apt dependencies:</li> </ul> <pre><code>sudo apt-get install git python3-dev python3-setuptools zlib1g-dev \\\nlibjpeg-dev libffi-dev libopenblas-dev libopenjp2-7 wkhtmltopdf \\\nrustc build-essential libssl-dev -y\n</code></pre>"},{"location":"installation/#step-6-clone-install-inkycal","title":"Step 6 - Clone &amp; Install Inkycal","text":"<ul> <li>Clone the repo</li> </ul> <pre><code>cd $HOME\ngit clone https://github.com/aceinnolab/Inkycal\ncd Inkycal\n</code></pre> <p>Create virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate\n</code></pre> <p>Install dependencies using piwheels to avoid multi-hour builds:</p> <pre><code>pip install --upgrade pip wheel setuptools --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\npip install -e . --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\npip install -r raspberry_os_requirements.txt --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\n</code></pre>"},{"location":"installation/#step-7-enable-autostart","title":"Step 7 \u2014 Enable Autostart","text":"<ul> <li>Add Inkycal to crontab (no sudo):</li> </ul> <pre><code>CRON_LINE='@reboot sleep 60 &amp;&amp; cd $HOME/Inkycal &amp;&amp; venv/bin/python inky_run.py &amp;'\n( crontab -l 2&gt;/dev/null | grep -qxF \"$CRON_LINE\" ) || \\\n( crontab -l 2&gt;/dev/null; echo \"$CRON_LINE\" ) | crontab -\n</code></pre>"},{"location":"installation/#install-on-non-gpio-devices-development-mode","title":"Install on Non-GPIO Devices (Development Mode)","text":"<p>You can run Inkycal on macOS, Linux, Windows \u2014 useful for:</p> <ul> <li>Debugging</li> <li>Developing new modules</li> <li>Rendering previews</li> </ul> <p>You won\u2019t be able to show images on real hardware.</p> <pre><code>git clone https://github.com/aceinnolab/Inkycal\ncd Inkycal\npython3 -m venv venv\nsource venv/bin/activate\npip install -e .\n</code></pre> <p>Run:</p> <pre><code>python inky_run.py\n</code></pre>"},{"location":"installation/#pisugar-support","title":"PiSugar Support","text":"<p>If you\u2019re using a PiSugar battery board, see:</p> <p>https://github.com/aceinnolab/Inkycal/wiki/PiSugar-support</p> <p>This covers:</p> <ul> <li>Driver installation</li> <li>Configuration</li> <li>Auto-shutdown</li> <li>Power monitoring</li> </ul>"},{"location":"installation/#troubleshooting-summary","title":"\ud83c\udd98 Troubleshooting Summary","text":"<p>Display stays white</p> <p>Likely missing BCM2835 driver for 12.48\u201d.</p> <p>Slow installation on Pi Zero W</p> <p>Use piwheels + swap (already covered above).</p> <p>settings.json missing</p> <p>Ensure it is placed at: * /boot/settings.json * Same directory as inky_run.py</p>"},{"location":"quickstart/","title":"\ud83d\ude80 Quickstart","text":"<p>This guide walks you through setting up Inkycal from start to finish in just a few minutes. If you want a deeper explanation of each step, see the Installation and User Guide sections.</p>"},{"location":"quickstart/#1-what-you-need","title":"1. What You Need","text":"<ul> <li>Raspberry Pi Zero W / Zero 2 / 3 / 4</li> <li>Supported e-paper display (Waveshare / Pimoroni / similar)</li> <li>MicroSD card (min. 4GB)</li> <li>Wi-Fi connection</li> <li>A computer with Raspberry Pi Imager</li> </ul> <p>Optional but recommended:</p> <ul> <li>InkycalOS Lite \u2013 a preconfigured plug-and-play OS image (available for GitHub Sponsors)</li> </ul>"},{"location":"quickstart/#2-flash-raspberry-pi-os","title":"2. Flash Raspberry Pi OS","text":"<ol> <li>Download Raspberry Pi Imager </li> <li>Select:</li> </ol> Setting Value OS Raspberry Pi OS Lite (recommended version\u2014see Installation) Hostname <code>inkycal</code> Enable SSH Yes Username choose any Password set one Wi-Fi configure SSID + password Timezone set your local zone <ol> <li>Write the image to the microSD card.</li> </ol>"},{"location":"quickstart/#3-create-your-settingsjson","title":"3. Create Your <code>settings.json</code>","text":"<p>Go to:</p> <p>\ud83d\udc49 https://inkycal.aceinnolab.com/ui</p> <p>There you can:</p> <ul> <li>Choose your display model  </li> <li>Add modules (Calendar, Weather, RSS, etc.)  </li> <li>Configure layout &amp; language  </li> <li>Download your <code>settings.json</code></li> </ul> <p>Place the file in: /boot/settings.json on the SD card.</p>"},{"location":"quickstart/#4-first-boot","title":"4. First Boot","text":"<p>Insert the microSD card \u2192 power the Pi.</p> <p>Wait ~3 minutes for first boot.</p> <p>Then connect via SSH:</p> <pre><code>ssh &lt;username&gt;@inkycal.local\n</code></pre>"},{"location":"quickstart/#5-install-inkycal","title":"5. Install Inkycal","text":"<p>Inside the Pi, run:</p> <pre><code>sudo apt update -y\nsudo raspi-config --expand-rootfs\nsudo sed -i s/#dtparam=spi=on/dtparam=spi=on/ /boot/firmware/config.txt\nsudo dpkg-reconfigure tzdata\n</code></pre> <p>Then install Inkycal</p> <pre><code>cd $HOME\ngit clone https://github.com/aceinnolab/Inkycal\ncd Inkycal\npython -m venv venv\nsource venv/bin/activate\npip install --upgrade pip wheel setuptools --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\npip install -e . --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\npip install -r raspberry_os_requirements.txt --index-url https://www.piwheels.org/simple --extra-index-url https://pypi.org/simple\n</code></pre>"},{"location":"quickstart/#6-start-inkycal","title":"6. Start Inkycal","text":"<pre><code>venv/bin/python inky_run.py\n</code></pre> <p>If everything is set up correctly: * Inkycal loads your modules * Renders a full e-paper image * Displays it on your hardware</p>"},{"location":"quickstart/#7-auto-start-on-boot-optional","title":"7. Auto-Start on Boot (optional)","text":"<pre><code>CRON_LINE='@reboot sleep 60 &amp;&amp; cd $HOME/Inkycal &amp;&amp; venv/bin/python inky_run.py &amp;'\n( crontab -l 2&gt;/dev/null | grep -qxF \"$CRON_LINE\" ) || \\\n( crontab -l 2&gt;/dev/null; echo \"$CRON_LINE\" ) | crontab -\n</code></pre>"},{"location":"quickstart/#8-updating-inkycal","title":"8. Updating Inkycal","text":"<pre><code>cd ~/Inkycal\ngit pull\nsource venv/bin/activate\npip install -e .\n</code></pre>"},{"location":"quickstart/#9-want-the-easy-way-recommended","title":"9. Want the Easy Way? (Recommended)","text":"<p>If you\u2019re using a Pi Zero (slow installation), consider InkycalOS Lite.</p> <p>\u2714 Preinstalled dependencies \u2714 SPI enabled \u2714 Inkycal auto-start \u2714 Faster boot / render \u2714 Saves hours of installation time</p> <p>Available via the GitHub Sponsor page.</p>"},{"location":"reference/","title":"\ud83d\udcd8 Inkycal API Reference","text":"<p>Welcome to the full API reference for Inkycal.</p> <p>This page contains:</p> <ul> <li>A complete list of all available modules  </li> <li>API documentation for the Canvas and Display classes  </li> <li>Utilities included in <code>inkycal.utils</code> </li> <li>Auto-generated API docs (if mkdocstrings is enabled)</li> </ul>"},{"location":"reference/#architecture-summary","title":"\ud83e\udde9 Architecture Summary","text":"<p>Inkycal is composed of:</p> Component Location Description Modules <code>inkycal/modules/</code> Pluggable units (Calendar, Weather, Stocks, etc.) Display Interface <code>inkycal/display/</code> Hardware drivers for supported ePaper displays Canvas Engine <code>inkycal/utils/canvas.py</code> Text / icon / drawing engine used by all modules Utilities <code>inkycal/utils/</code> Helpers (timezone, borders, networking, line charts) <p>Most modules extend:</p> <pre><code>inkycal.modules.template.InkycalModule\n</code></pre>"},{"location":"reference/#built-in-modules","title":"\ud83d\udce6 Built-in Modules","text":"<p>Inkycal ships with the following modules, available via the Web-UI and automatically registered via:</p> <pre><code>inkycal.modules.__init__.py\n</code></pre>"},{"location":"reference/#module-index","title":"Module Index","text":"Name Class Import Path Agenda <code>Agenda</code> <code>inkycal.modules.inkycal_agenda.Agenda</code> Calendar <code>Calendar</code> <code>inkycal.modules.inkycal_calendar.Calendar</code> Feeds <code>Feeds</code> <code>inkycal.modules.inkycal_feeds.Feeds</code> Image <code>Inkyimage</code> <code>inkycal.modules.inky_image.Inkyimage</code> Jokes <code>Jokes</code> <code>inkycal.modules.inkycal_jokes.Jokes</code> Server Status <code>Inkyserver</code> <code>inkycal.modules.inkycal_server.Inkyserver</code> Slideshow <code>Slideshow</code> <code>inkycal.modules.inkycal_slideshow.Slideshow</code> Stocks <code>Stocks</code> <code>inkycal.modules.inkycal_stocks.Stocks</code> Text File Renderer <code>TextToDisplay</code> <code>inkycal.modules.inkycal_textfile_to_display.TextToDisplay</code> Tindie Stats <code>Tindie</code> <code>inkycal.modules.inkycal_tindie.Tindie</code> Todoist <code>Todoist</code> <code>inkycal.modules.inkycal_todoist.Todoist</code> Weather <code>Weather</code> <code>inkycal.modules.inkycal_weather.Weather</code> Webshot <code>Webshot</code> <code>inkycal.modules.inkycal_webshot.Webshot</code> XKCD <code>Xkcd</code> <code>inkycal.modules.inkycal_xkcd.Xkcd</code>"},{"location":"reference/#module-reference-auto-generated","title":"\ud83d\udcda Module Reference (Auto-Generated)","text":""},{"location":"reference/#template-module","title":"Template Module","text":"<pre><code>::: inkycal.modules.template\n</code></pre>"},{"location":"reference/#calendar","title":"Calendar","text":"<p>Inkycal Calendar Module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_calendar.Calendar","title":"<code>Calendar</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Calendar class Create monthly calendar and show events from given iCalendars</p> Source code in <code>inkycal/modules/inkycal_calendar.py</code> <pre><code>class Calendar(InkycalModule):\n    \"\"\"Calendar class\n    Create monthly calendar and show events from given iCalendars\n    \"\"\"\n\n    name = \"Calendar - Show monthly calendar with events from iCalendars\"\n\n    optional = {\n        \"week_starts_on\": {\n            \"label\": \"When does your week start? (default=Monday)\",\n            \"options\": [\"Monday\", \"Sunday\"],\n            \"default\": \"Monday\",\n        },\n        \"show_events\": {\n            \"label\": \"Show parsed events? (default = True)\",\n            \"options\": [True, False],\n            \"default\": True,\n        },\n        \"ical_urls\": {\n            \"label\": \"iCalendar URL/s, separate multiple ones with a comma\",\n        },\n        \"ical_files\": {\n            \"label\": \"iCalendar filepaths, separated with a comma\",\n        },\n        \"date_format\": {\n            \"label\": \"Use an arrow-supported token for custom date formatting \"\n                     + \"see https://arrow.readthedocs.io/en/stable/#supported-tokens, e.g. D MMM\",\n            \"default\": \"D MMM\",\n        },\n        \"time_format\": {\n            \"label\": \"Use an arrow-supported token for custom time formatting \"\n                     + \"see https://arrow.readthedocs.io/en/stable/#supported-tokens, e.g. HH:mm\",\n            \"default\": \"HH:mm\",\n        },\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_calendar module\"\"\"\n\n        super().__init__(config)\n        config = config['config']\n\n        self.ical = None\n        self.month_events = None\n        self._upcoming_events = None\n        self._days_with_events = None\n\n        # optional parameters\n        self.week_start = config['week_starts_on']\n        self.show_events = config['show_events']\n        self.date_format = config[\"date_format\"]\n        self.time_format = config['time_format']\n        self.language = config['language']\n\n        if config['ical_urls'] and isinstance(config['ical_urls'], str):\n            self.ical_urls = config['ical_urls'].split(',')\n        else:\n            self.ical_urls = config['ical_urls']\n\n        if config['ical_files'] and isinstance(config['ical_files'], str):\n            self.ical_files = config['ical_files'].split(',')\n        else:\n            self.ical_files = config['ical_files']\n\n        # additional configuration\n        self.timezone = get_system_tz()\n        self.num_font = FONTS.noto_sans_semicondensed\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    @staticmethod\n    def flatten(values):\n        \"\"\"Flatten the values.\"\"\"\n        return [x for y in values for x in y]\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        events_height = 0\n\n        logger.debug(f'Image size: {im_size}')\n\n        canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n        # Allocate space for month-names, weekdays etc.\n        month_name_height = int(im_height * 0.10) # 10% of the available height\n        weekdays_height = int(canvas.get_line_height() * 1.25) # slightly more height for some padding\n        logger.debug(f\"month_name_height: {month_name_height}\")\n        logger.debug(f\"weekdays_height: {weekdays_height}\")\n\n        if self.show_events:\n            logger.debug(\"Allocating space for events\")\n            calendar_height = int(im_height * 0.6)\n            events_height = (\n                    im_height - month_name_height - weekdays_height - calendar_height\n            )\n            logger.debug(f'calendar-section size: {im_width} x {calendar_height} px')\n            logger.debug(f'events-section size: {im_width} x {events_height} px')\n        else:\n            logger.debug(\"Not allocating space for events\")\n            calendar_height = im_height - month_name_height - weekdays_height\n            logger.debug(f'calendar-section size: {im_width} x {calendar_height} px')\n\n        # Create a 7x6 grid and calculate icon sizes\n        calendar_rows, calendar_cols = 6, 7\n        icon_width = im_width // calendar_cols\n        icon_height = calendar_height // calendar_rows\n        logger.debug(f\"icon_size: {icon_width}x{icon_height}px\")\n\n        # Calculate spacings for calendar area\n        x_spacing_calendar = int((im_width % calendar_cols) / 2)\n        y_spacing_calendar = int((im_height % calendar_rows) / 2)\n\n        logger.debug(f\"x_spacing_calendar: {x_spacing_calendar}\")\n        logger.debug(f\"y_spacing_calendar :{y_spacing_calendar}\")\n\n        # Calculate positions for days of month\n        grid_start_y = month_name_height + weekdays_height + y_spacing_calendar\n        grid_start_x = x_spacing_calendar\n\n        grid_coordinates = [\n            (grid_start_x + icon_width * x, grid_start_y + icon_height * y)\n            for y in range(calendar_rows)\n            for x in range(calendar_cols)\n        ]\n\n        weekday_pos = [\n            (grid_start_x + icon_width * _, month_name_height)\n            for _ in range(calendar_cols)\n        ]\n\n        now = arrow.now(tz=self.timezone)\n\n        # Set week-start of calendar to specified week-start\n        if self.week_start == \"Monday\":\n            cal.setfirstweekday(cal.MONDAY)\n            week_start = now.shift(days=-now.weekday())\n        else:\n            cal.setfirstweekday(cal.SUNDAY)\n            week_start = now.shift(days=-now.isoweekday())\n\n        # Write the name of current month\n        canvas.write(\n            xy=(0,0),\n            box_size=(im_width, month_name_height),\n            text= str(now.format('MMMM', locale=self.language)),\n            autofit=True,\n        )\n\n        # Set up week-names in local language and add to main section\n        weekday_names = [\n            week_start.shift(days=+_).format('ddd', locale=self.language)\n            for _ in range(7)\n        ]\n        logger.debug(f'weekday names: {weekday_names}')\n\n        for index, weekday in enumerate(weekday_pos):\n            canvas.write(\n                xy=weekday,\n                box_size=(icon_width, weekdays_height),\n                text=weekday_names[index],\n                autofit=True,\n                fill_height=0.9,\n            )\n\n        # Create a calendar template and flatten (remove nesting)\n        calendar_flat = self.flatten(cal.monthcalendar(now.year, now.month))\n        # logger.debug(f\" calendar_flat: {calendar_flat}\")\n\n        # Map days of month to co-ordinates of grid -&gt; 3: (row2_x,col3_y)\n        grid = {}\n        for i in calendar_flat:\n            if i != 0:\n                grid[i] = grid_coordinates[calendar_flat.index(i)]\n        # logger.debug(f\"grid:{grid}\")\n\n        # remove zeros from calendar since they are not required\n        calendar_flat = [num for num in calendar_flat if num != 0]\n\n        # ensure all numbers have the same size\n        fontsize_numbers = int(min(icon_width, icon_height) * 0.5)\n\n        canvas.set_font(self.font, fontsize_numbers)\n        # Add the numbers on the correct positions\n        for number in calendar_flat:\n            if number != int(now.day):\n                canvas.write(\n                    xy=grid[number],\n                    box_size=(icon_width, icon_height),\n                    text= str(number)\n                )\n\n        canvas.set_font(self.font, self.fontsize)\n\n        # special handling of current day\n        day_str = str(now.day)\n\n        # Icon canvas\n        icon = Image.new(\"RGBA\", (icon_width, icon_height), (0, 0, 0, 0))\n        draw = ImageDraw.Draw(icon)\n\n        # --- Larger circle (properly centered) ---\n        cx = icon_width // 2\n        cy = icon_height // 2\n        radius = int(icon_width * 0.40)\n\n        draw.ellipse(\n            (cx - radius, cy - radius, cx + radius, cy + radius),\n            fill=\"black\"\n        )\n\n        # --- Load number font ---\n        font = ImageFont.truetype(self.num_font.value, fontsize_numbers)\n\n        # --- Perfect vertical + horizontal centering using anchor=\"mm\" ---\n        draw.text(\n            (cx, cy),\n            day_str,\n            fill=\"white\",\n            font=font,\n            anchor=\"mm\"  # \u2190 the magic incantation\n        )\n\n        # --- Paste onto main canvas ---\n        cell_x, cell_y = grid[int(now.day)]\n\n        # center the icon inside its grid cell\n        paste_x = cell_x + (icon_width - icon.width) // 2\n        paste_y = cell_y + (icon_height - icon.height) // 2\n\n        canvas.image_black.paste(icon, (paste_x, paste_y), icon)\n        canvas.image_colour.paste(icon, (paste_x, paste_y), icon)\n\n\n\n\n        # If events should be loaded and shown...\n        if self.show_events:\n\n            # If this month requires 5 instead of 6 rows, increase event section height\n            if len(cal.monthcalendar(now.year, now.month)) == 5:\n                events_height += icon_height\n\n            # If this month requires 4 instead of 6 rows, increase event section height\n            elif len(cal.monthcalendar(now.year, now.month)) == 4:\n                events_height += icon_height * 2\n\n            # import the ical-parser\n            # pylint: disable=import-outside-toplevel\n            from inkycal.utils.ical_parser import iCalendar\n\n            # find out how many lines can fit at max in the event section\n            line_spacing = 2\n            line_height = canvas.get_line_height() + line_spacing\n            max_event_lines = events_height // (line_height + line_spacing)\n\n            # generate list of coordinates for each line\n            events_offset = im_height - events_height\n            event_lines = [\n                (0, events_offset + int(events_height / max_event_lines * _))\n                for _ in range(max_event_lines)\n            ]\n\n            # logger.debug(f\"event_lines {event_lines}\")\n\n            # timeline for filtering events within this month\n            month_start = arrow.get(now.floor('month'))\n            month_end = arrow.get(now.ceil('month'))\n\n            # fetch events from given iCalendars\n            self.ical = iCalendar()\n            parser = self.ical\n\n            if self.ical_urls:\n                parser.load_url(self.ical_urls)\n            if self.ical_files:\n                parser.load_from_file(self.ical_files)\n\n            # Filter events for full month (even past ones) for drawing event icons\n            month_events = parser.get_events(month_start, month_end, self.timezone)\n            parser.sort()\n            self.month_events = month_events\n\n            # Initialize days_with_events as an empty list\n            days_with_events = []\n\n            # Handle multi-day events by adding all days between start and end\n            for event in month_events:\n\n                # Convert start and end dates to arrow objects with timezone\n                start = arrow.get(event['begin'].date(), tzinfo=self.timezone)\n                end = arrow.get(event['end'].date(), tzinfo=self.timezone)\n\n                # Use arrow's range function for generating dates\n                for day in arrow.Arrow.range('day', start, end):\n                    day_num = int(day.format('D'))  # get day number using arrow's format method\n                    if day_num not in days_with_events:\n                        days_with_events.append(day_num)\n\n            # remove duplicates (more than one event in a single day)\n            days_with_events = sorted(set(days_with_events))\n            self._days_with_events = days_with_events\n\n            # Draw a border with specified parameters around days with events\n            for days in days_with_events:\n                if days in grid:\n                    draw_border(\n                        canvas.image_colour,\n                        grid[days],\n                        (icon_width, icon_height),\n                        radius=6\n                    )\n\n            # Filter upcoming events until 4 weeks in the future\n            parser.clear_events()\n            upcoming_events = parser.get_events(now, now.shift(weeks=4), self.timezone)\n            self._upcoming_events = upcoming_events\n\n            # delete events which won't be able to fit (more events than lines)\n            upcoming_events = upcoming_events[:max_event_lines]\n\n            # Check if any events were found in the given timerange\n            if upcoming_events:\n\n                # Find out how much space (width) the date format requires\n                lang = self.language\n\n                date_width = int(max((\n                    self.font.getlength(events['begin'].format(self.date_format, locale=lang))\n                    for events in upcoming_events)) * 1.1\n                                 )\n\n                time_width = int(max((\n                    self.font.getlength(events['begin'].format(self.time_format, locale=lang))\n                    for events in upcoming_events)) * 1.1\n                                 )\n\n                text_bbox_height = self.font.getbbox(\"hg\")\n                line_height = text_bbox_height[3] + line_spacing\n\n                event_width_s = im_width - date_width - time_width\n                event_width_l = im_width - date_width\n\n                # Display upcoming events below calendar TODO: not used?\n                # tomorrow = now.shift(days=1).floor('day')\n                # in_two_days = now.shift(days=2).floor('day')\n\n                cursor = 0\n                for event in upcoming_events:\n                    if cursor &lt; len(event_lines):\n                        event_duration = (event['end'] - event['begin']).days\n                        if event_duration &gt; 1:\n                            # Format the duration using Arrow's localization\n                            days_translation = arrow.get().shift(days=event_duration).humanize(only_distance=True,\n                                                                                               locale=lang)\n                            the_name = f\"{event['title']} ({days_translation})\"\n                        else:\n                            the_name = event['title']\n                        the_date = event['begin'].format(self.date_format, locale=lang)\n                        the_time = event['begin'].format(self.time_format, locale=lang)\n                        # logger.debug(f\"name:{the_name}   date:{the_date} time:{the_time}\")\n\n                        if now &lt; event['end']:\n                            canvas.write(\n                                xy=event_lines[cursor],\n                                box_size=(date_width, line_height),\n                                text=the_date,\n                                alignment='left',\n                            )\n\n                            # Check if event is all day\n                            if parser.all_day(event):\n                                canvas.write(\n                                    xy=(date_width, event_lines[cursor][1]),\n                                    box_size= (event_width_l, line_height),\n                                    text=the_name,\n                                    alignment='left',\n                                )\n                            else:\n                                canvas.write(\n                                    xy=(date_width, event_lines[cursor][1]),\n                                    box_size=(time_width, line_height),\n                                    text=the_time,\n                                    alignment='left',\n                                )\n\n                                canvas.write(\n                                    xy=(date_width + time_width, event_lines[cursor][1]),\n                                    box_size=(event_width_s, line_height),\n                                    text=the_name,\n                                    alignment='left',\n                                )\n                            cursor += 1\n            else:\n                symbol = '- '\n                length = canvas.get_text_width(symbol)\n                multiplier = int(im_width // length)\n                symbol = symbol * multiplier\n\n                canvas.write(\n                    xy=event_lines[0],\n                    box_size=(im_width, line_height),\n                    text=symbol,\n                    alignment='left',\n                    )\n\n        # return the images ready for the display\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_calendar.Calendar.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_calendar module</p> Source code in <code>inkycal/modules/inkycal_calendar.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_calendar module\"\"\"\n\n    super().__init__(config)\n    config = config['config']\n\n    self.ical = None\n    self.month_events = None\n    self._upcoming_events = None\n    self._days_with_events = None\n\n    # optional parameters\n    self.week_start = config['week_starts_on']\n    self.show_events = config['show_events']\n    self.date_format = config[\"date_format\"]\n    self.time_format = config['time_format']\n    self.language = config['language']\n\n    if config['ical_urls'] and isinstance(config['ical_urls'], str):\n        self.ical_urls = config['ical_urls'].split(',')\n    else:\n        self.ical_urls = config['ical_urls']\n\n    if config['ical_files'] and isinstance(config['ical_files'], str):\n        self.ical_files = config['ical_files'].split(',')\n    else:\n        self.ical_files = config['ical_files']\n\n    # additional configuration\n    self.timezone = get_system_tz()\n    self.num_font = FONTS.noto_sans_semicondensed\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_calendar.Calendar.flatten","title":"<code>flatten(values)</code>  <code>staticmethod</code>","text":"<p>Flatten the values.</p> Source code in <code>inkycal/modules/inkycal_calendar.py</code> <pre><code>@staticmethod\ndef flatten(values):\n    \"\"\"Flatten the values.\"\"\"\n    return [x for y in values for x in y]\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_calendar.Calendar.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_calendar.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    events_height = 0\n\n    logger.debug(f'Image size: {im_size}')\n\n    canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n    # Allocate space for month-names, weekdays etc.\n    month_name_height = int(im_height * 0.10) # 10% of the available height\n    weekdays_height = int(canvas.get_line_height() * 1.25) # slightly more height for some padding\n    logger.debug(f\"month_name_height: {month_name_height}\")\n    logger.debug(f\"weekdays_height: {weekdays_height}\")\n\n    if self.show_events:\n        logger.debug(\"Allocating space for events\")\n        calendar_height = int(im_height * 0.6)\n        events_height = (\n                im_height - month_name_height - weekdays_height - calendar_height\n        )\n        logger.debug(f'calendar-section size: {im_width} x {calendar_height} px')\n        logger.debug(f'events-section size: {im_width} x {events_height} px')\n    else:\n        logger.debug(\"Not allocating space for events\")\n        calendar_height = im_height - month_name_height - weekdays_height\n        logger.debug(f'calendar-section size: {im_width} x {calendar_height} px')\n\n    # Create a 7x6 grid and calculate icon sizes\n    calendar_rows, calendar_cols = 6, 7\n    icon_width = im_width // calendar_cols\n    icon_height = calendar_height // calendar_rows\n    logger.debug(f\"icon_size: {icon_width}x{icon_height}px\")\n\n    # Calculate spacings for calendar area\n    x_spacing_calendar = int((im_width % calendar_cols) / 2)\n    y_spacing_calendar = int((im_height % calendar_rows) / 2)\n\n    logger.debug(f\"x_spacing_calendar: {x_spacing_calendar}\")\n    logger.debug(f\"y_spacing_calendar :{y_spacing_calendar}\")\n\n    # Calculate positions for days of month\n    grid_start_y = month_name_height + weekdays_height + y_spacing_calendar\n    grid_start_x = x_spacing_calendar\n\n    grid_coordinates = [\n        (grid_start_x + icon_width * x, grid_start_y + icon_height * y)\n        for y in range(calendar_rows)\n        for x in range(calendar_cols)\n    ]\n\n    weekday_pos = [\n        (grid_start_x + icon_width * _, month_name_height)\n        for _ in range(calendar_cols)\n    ]\n\n    now = arrow.now(tz=self.timezone)\n\n    # Set week-start of calendar to specified week-start\n    if self.week_start == \"Monday\":\n        cal.setfirstweekday(cal.MONDAY)\n        week_start = now.shift(days=-now.weekday())\n    else:\n        cal.setfirstweekday(cal.SUNDAY)\n        week_start = now.shift(days=-now.isoweekday())\n\n    # Write the name of current month\n    canvas.write(\n        xy=(0,0),\n        box_size=(im_width, month_name_height),\n        text= str(now.format('MMMM', locale=self.language)),\n        autofit=True,\n    )\n\n    # Set up week-names in local language and add to main section\n    weekday_names = [\n        week_start.shift(days=+_).format('ddd', locale=self.language)\n        for _ in range(7)\n    ]\n    logger.debug(f'weekday names: {weekday_names}')\n\n    for index, weekday in enumerate(weekday_pos):\n        canvas.write(\n            xy=weekday,\n            box_size=(icon_width, weekdays_height),\n            text=weekday_names[index],\n            autofit=True,\n            fill_height=0.9,\n        )\n\n    # Create a calendar template and flatten (remove nesting)\n    calendar_flat = self.flatten(cal.monthcalendar(now.year, now.month))\n    # logger.debug(f\" calendar_flat: {calendar_flat}\")\n\n    # Map days of month to co-ordinates of grid -&gt; 3: (row2_x,col3_y)\n    grid = {}\n    for i in calendar_flat:\n        if i != 0:\n            grid[i] = grid_coordinates[calendar_flat.index(i)]\n    # logger.debug(f\"grid:{grid}\")\n\n    # remove zeros from calendar since they are not required\n    calendar_flat = [num for num in calendar_flat if num != 0]\n\n    # ensure all numbers have the same size\n    fontsize_numbers = int(min(icon_width, icon_height) * 0.5)\n\n    canvas.set_font(self.font, fontsize_numbers)\n    # Add the numbers on the correct positions\n    for number in calendar_flat:\n        if number != int(now.day):\n            canvas.write(\n                xy=grid[number],\n                box_size=(icon_width, icon_height),\n                text= str(number)\n            )\n\n    canvas.set_font(self.font, self.fontsize)\n\n    # special handling of current day\n    day_str = str(now.day)\n\n    # Icon canvas\n    icon = Image.new(\"RGBA\", (icon_width, icon_height), (0, 0, 0, 0))\n    draw = ImageDraw.Draw(icon)\n\n    # --- Larger circle (properly centered) ---\n    cx = icon_width // 2\n    cy = icon_height // 2\n    radius = int(icon_width * 0.40)\n\n    draw.ellipse(\n        (cx - radius, cy - radius, cx + radius, cy + radius),\n        fill=\"black\"\n    )\n\n    # --- Load number font ---\n    font = ImageFont.truetype(self.num_font.value, fontsize_numbers)\n\n    # --- Perfect vertical + horizontal centering using anchor=\"mm\" ---\n    draw.text(\n        (cx, cy),\n        day_str,\n        fill=\"white\",\n        font=font,\n        anchor=\"mm\"  # \u2190 the magic incantation\n    )\n\n    # --- Paste onto main canvas ---\n    cell_x, cell_y = grid[int(now.day)]\n\n    # center the icon inside its grid cell\n    paste_x = cell_x + (icon_width - icon.width) // 2\n    paste_y = cell_y + (icon_height - icon.height) // 2\n\n    canvas.image_black.paste(icon, (paste_x, paste_y), icon)\n    canvas.image_colour.paste(icon, (paste_x, paste_y), icon)\n\n\n\n\n    # If events should be loaded and shown...\n    if self.show_events:\n\n        # If this month requires 5 instead of 6 rows, increase event section height\n        if len(cal.monthcalendar(now.year, now.month)) == 5:\n            events_height += icon_height\n\n        # If this month requires 4 instead of 6 rows, increase event section height\n        elif len(cal.monthcalendar(now.year, now.month)) == 4:\n            events_height += icon_height * 2\n\n        # import the ical-parser\n        # pylint: disable=import-outside-toplevel\n        from inkycal.utils.ical_parser import iCalendar\n\n        # find out how many lines can fit at max in the event section\n        line_spacing = 2\n        line_height = canvas.get_line_height() + line_spacing\n        max_event_lines = events_height // (line_height + line_spacing)\n\n        # generate list of coordinates for each line\n        events_offset = im_height - events_height\n        event_lines = [\n            (0, events_offset + int(events_height / max_event_lines * _))\n            for _ in range(max_event_lines)\n        ]\n\n        # logger.debug(f\"event_lines {event_lines}\")\n\n        # timeline for filtering events within this month\n        month_start = arrow.get(now.floor('month'))\n        month_end = arrow.get(now.ceil('month'))\n\n        # fetch events from given iCalendars\n        self.ical = iCalendar()\n        parser = self.ical\n\n        if self.ical_urls:\n            parser.load_url(self.ical_urls)\n        if self.ical_files:\n            parser.load_from_file(self.ical_files)\n\n        # Filter events for full month (even past ones) for drawing event icons\n        month_events = parser.get_events(month_start, month_end, self.timezone)\n        parser.sort()\n        self.month_events = month_events\n\n        # Initialize days_with_events as an empty list\n        days_with_events = []\n\n        # Handle multi-day events by adding all days between start and end\n        for event in month_events:\n\n            # Convert start and end dates to arrow objects with timezone\n            start = arrow.get(event['begin'].date(), tzinfo=self.timezone)\n            end = arrow.get(event['end'].date(), tzinfo=self.timezone)\n\n            # Use arrow's range function for generating dates\n            for day in arrow.Arrow.range('day', start, end):\n                day_num = int(day.format('D'))  # get day number using arrow's format method\n                if day_num not in days_with_events:\n                    days_with_events.append(day_num)\n\n        # remove duplicates (more than one event in a single day)\n        days_with_events = sorted(set(days_with_events))\n        self._days_with_events = days_with_events\n\n        # Draw a border with specified parameters around days with events\n        for days in days_with_events:\n            if days in grid:\n                draw_border(\n                    canvas.image_colour,\n                    grid[days],\n                    (icon_width, icon_height),\n                    radius=6\n                )\n\n        # Filter upcoming events until 4 weeks in the future\n        parser.clear_events()\n        upcoming_events = parser.get_events(now, now.shift(weeks=4), self.timezone)\n        self._upcoming_events = upcoming_events\n\n        # delete events which won't be able to fit (more events than lines)\n        upcoming_events = upcoming_events[:max_event_lines]\n\n        # Check if any events were found in the given timerange\n        if upcoming_events:\n\n            # Find out how much space (width) the date format requires\n            lang = self.language\n\n            date_width = int(max((\n                self.font.getlength(events['begin'].format(self.date_format, locale=lang))\n                for events in upcoming_events)) * 1.1\n                             )\n\n            time_width = int(max((\n                self.font.getlength(events['begin'].format(self.time_format, locale=lang))\n                for events in upcoming_events)) * 1.1\n                             )\n\n            text_bbox_height = self.font.getbbox(\"hg\")\n            line_height = text_bbox_height[3] + line_spacing\n\n            event_width_s = im_width - date_width - time_width\n            event_width_l = im_width - date_width\n\n            # Display upcoming events below calendar TODO: not used?\n            # tomorrow = now.shift(days=1).floor('day')\n            # in_two_days = now.shift(days=2).floor('day')\n\n            cursor = 0\n            for event in upcoming_events:\n                if cursor &lt; len(event_lines):\n                    event_duration = (event['end'] - event['begin']).days\n                    if event_duration &gt; 1:\n                        # Format the duration using Arrow's localization\n                        days_translation = arrow.get().shift(days=event_duration).humanize(only_distance=True,\n                                                                                           locale=lang)\n                        the_name = f\"{event['title']} ({days_translation})\"\n                    else:\n                        the_name = event['title']\n                    the_date = event['begin'].format(self.date_format, locale=lang)\n                    the_time = event['begin'].format(self.time_format, locale=lang)\n                    # logger.debug(f\"name:{the_name}   date:{the_date} time:{the_time}\")\n\n                    if now &lt; event['end']:\n                        canvas.write(\n                            xy=event_lines[cursor],\n                            box_size=(date_width, line_height),\n                            text=the_date,\n                            alignment='left',\n                        )\n\n                        # Check if event is all day\n                        if parser.all_day(event):\n                            canvas.write(\n                                xy=(date_width, event_lines[cursor][1]),\n                                box_size= (event_width_l, line_height),\n                                text=the_name,\n                                alignment='left',\n                            )\n                        else:\n                            canvas.write(\n                                xy=(date_width, event_lines[cursor][1]),\n                                box_size=(time_width, line_height),\n                                text=the_time,\n                                alignment='left',\n                            )\n\n                            canvas.write(\n                                xy=(date_width + time_width, event_lines[cursor][1]),\n                                box_size=(event_width_s, line_height),\n                                text=the_name,\n                                alignment='left',\n                            )\n                        cursor += 1\n        else:\n            symbol = '- '\n            length = canvas.get_text_width(symbol)\n            multiplier = int(im_width // length)\n            symbol = symbol * multiplier\n\n            canvas.write(\n                xy=event_lines[0],\n                box_size=(im_width, line_height),\n                text=symbol,\n                alignment='left',\n                )\n\n    # return the images ready for the display\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#weather","title":"Weather","text":"<p>Inkycal weather module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_weather.Weather","title":"<code>Weather</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Weather class parses weather details from openweathermap</p> Source code in <code>inkycal/modules/inkycal_weather.py</code> <pre><code>class Weather(InkycalModule):\n    \"\"\"Weather class\n    parses weather details from openweathermap\n    \"\"\"\n    name = \"Weather (openweathermap) - Get weather forecasts from openweathermap\"\n\n    requires = {\n\n        \"api_key\": {\n            \"label\": \"Please enter openweathermap api-key. You can create one for free on openweathermap\",\n        },\n\n        \"location\": {\n            \"label\": \"Please enter your location in the following format: City, Country-Code. \" +\n                     \"You can also enter the location ID found in the url \" +\n                     \"e.g. https://openweathermap.org/city/4893171 -&gt; ID is 4893171\"\n        }\n    }\n\n    optional = {\n\n        \"round_temperature\": {\n            \"label\": \"Round temperature to the nearest degree?\",\n            \"options\": [True, False],\n        },\n\n        \"round_wind_speed\": {\n            \"label\": \"Round windspeed?\",\n            \"options\": [True, False],\n        },\n\n        \"forecast_interval\": {\n            \"label\": \"Please select the forecast interval\",\n            \"options\": [\"daily\", \"hourly\"],\n        },\n\n        \"units\": {\n            \"label\": \"Which units should be used?\",\n            \"options\": [\"metric\", \"imperial\"],\n        },\n\n        \"hour_format\": {\n            \"label\": \"Which hour format do you prefer?\",\n            \"options\": [24, 12],\n        },\n\n        \"use_beaufort\": {\n            \"label\": \"Use beaufort scale for windspeed?\",\n            \"options\": [True, False],\n        },\n\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_weather module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        self.timezone = get_system_tz()\n\n        # Check if all required parameters are present\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # required parameters\n        self.api_key = config['api_key']\n        self.location = config['location']\n\n        # optional parameters\n        self.round_temperature = config['round_temperature']\n        self.round_wind_speed = config['round_windspeed']\n        self.forecast_interval = config['forecast_interval']\n        self.hour_format = int(config['hour_format'])\n        if config['units'] == \"imperial\":\n            self.temp_unit = \"fahrenheit\"\n        else:\n            self.temp_unit = \"celsius\"\n\n        if config['use_beaufort']:\n            self.wind_unit = \"beaufort\"\n        elif config['units'] == \"imperial\":\n            self.wind_unit = \"miles_hour\"\n        else:\n            self.wind_unit = \"meters_sec\"\n        self.locale = config['language']\n        # additional configuration\n\n        self.owm = OpenWeatherMap(\n            api_key=self.api_key,\n            city_id=self.location,\n            wind_unit=self.wind_unit,\n            temp_unit=self.temp_unit,\n            language=self.locale,\n            tz_name=self.timezone\n        )\n\n        self.weatherfont= FONTS.weather_icons\n\n        if self.wind_unit == \"beaufort\":\n            self.windDispUnit = \"bft\"\n        elif self.wind_unit == \"knots\":\n            self.windDispUnit = \"kn\"\n        elif self.wind_unit == \"km_hour\":\n            self.windDispUnit = \"km/h\"\n        elif self.wind_unit == \"miles_hour\":\n            self.windDispUnit = \"mph\"\n        else:\n            self.windDispUnit = \"m/s\"\n        if self.temp_unit == \"fahrenheit\":\n            self.tempDispUnit = \"F\"\n        elif self.temp_unit == \"celsius\":\n            self.tempDispUnit = \"\u00b0\"\n\n        # give an OK message\n        logger.debug(f\"{__name__} loaded\")\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'Image size: {im_size}')\n\n        # Create an image for black pixels and one for coloured pixels\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Check if internet is available\n        if internet_available():\n            logger.debug('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise NetworkNotReachableError\n\n        def get_moon_phase():\n            \"\"\"Calculate the current (approximate) moon phase\n\n            Returns:\n                The corresponding moonphase-icon.\n            \"\"\"\n\n            dec = decimal.Decimal\n            diff = now - arrow.get(2001, 1, 1)\n            days = dec(diff.days) + (dec(diff.seconds) / dec(86400))\n            lunations = dec(\"0.20439731\") + (days * dec(\"0.03386319269\"))\n            position = lunations % dec(1)\n            index = math.floor((position * dec(8)) + dec(\"0.5\"))\n            return {\n                0: '\\uf095',\n                1: '\\uf099',\n                2: '\\uf09c',\n                3: '\\uf0a0',\n                4: '\\uf0a3',\n                5: '\\uf0a7',\n                6: '\\uf0aa',\n                7: '\\uf0ae'\n            }[int(index) &amp; 7]\n\n        def is_negative(temp: str):\n            \"\"\"Check if temp is below freezing point of water (0\u00b0C/32\u00b0F)\n            returns True if temp below freezing point, else False\"\"\"\n            answer = False\n\n            if self.temp_unit == 'celsius' and round(float(temp.split(self.tempDispUnit)[0])) &lt;= 0:\n                answer = True\n            elif self.temp_unit == 'fahrenheit' and round(float(temp.split(self.tempDispUnit)[0])) &lt;= 32:\n                answer = True\n            return answer\n\n        # Lookup-table for weather icons and weather codes\n        weather_icons = {\n            '01d': '\\uf00d',\n            '02d': '\\uf002',\n            '03d': '\\uf013',\n            '04d': '\\uf012',\n            '09d': '\\uf01a',\n            '10d': '\\uf019',\n            '11d': '\\uf01e',\n            '13d': '\\uf01b',\n            '50d': '\\uf014',\n            '01n': '\\uf02e',\n            '02n': '\\uf013',\n            '03n': '\\uf013',\n            '04n': '\\uf013',\n            '09n': '\\uf037',\n            '10n': '\\uf036',\n            '11n': '\\uf03b',\n            '13n': '\\uf038',\n            '50n': '\\uf023'\n        }\n\n        #   column1    column2    column3    column4    column5    column6    column7\n        # |----------|----------|----------|----------|----------|----------|----------|\n        # |  time    | temperat.| moonphase| forecast1| forecast2| forecast3| forecast4|\n        # | current  |----------|----------|----------|----------|----------|----------|\n        # | weather  | humidity |  sunrise |  icon1   |  icon2   |  icon3   |  icon4   |\n        # |  icon    |----------|----------|----------|----------|----------|----------|\n        # |          | windspeed|  sunset  | temperat.| temperat.| temperat.| temperat.|\n        # |----------|----------|----------|----------|----------|----------|----------|\n\n        # Calculate size rows and columns\n        col_width = im_width // 7\n\n        # Ratio width height\n        image_ratio = im_width / im_height\n\n        if image_ratio &gt;= 4:\n            row_height = im_height // 3\n        else:\n            logger.info('Please consider decreasing the height.')\n            row_height = int((im_height * (1 - im_height / im_width)) / 3)\n\n        logger.debug(f\"row_height: {row_height} | col_width: {col_width}\")\n\n        # Calculate spacings for better centering\n        spacing_top = int((im_width % col_width) / 2)\n\n        # Define sizes for weather icons\n        icon_small = int(col_width / 3)\n\n        # Calculate the x-axis position of each col\n        col1 = spacing_top\n        col2 = col1 + col_width\n        col3 = col2 + col_width\n        col4 = col3 + col_width\n        col5 = col4 + col_width\n        col6 = col5 + col_width\n        col7 = col6 + col_width\n\n        # Calculate the y-axis position of each row\n        line_gap = int((im_height - spacing_top - 3 * row_height) // 4)\n\n        row1 = line_gap\n        row2 = row1 + line_gap + row_height\n        row3 = row2 + line_gap + row_height\n\n        # Draw lines on each row and border\n        # draw = ImageDraw.Draw(canvas.image_black)\n        # draw.line((0, 0, im_width, 0), fill='red')\n        # draw.line((0, im_height-1, im_width, im_height-1), fill='red')\n        # draw.line((0, row1, im_width, row1), fill='black')\n        # draw.line((0, row1+row_height, im_width, row1+row_height), fill='black')\n        # draw.line((0, row2, im_width, row2), fill='black')\n        # draw.line((0, row2+row_height, im_width, row2+row_height), fill='black')\n        # draw.line((0, row3, im_width, row3), fill='black')\n        # draw.line((0, row3+row_height, im_width, row3+row_height), fill='black')\n\n        # Positions for current weather details\n        weather_icon_pos = (col1, 0)\n        temperature_icon_pos = (col2, row1)\n        temperature_pos = (col2 + icon_small, row1)\n        humidity_icon_pos = (col2, row2)\n        humidity_pos = (col2 + icon_small, row2)\n        windspeed_icon_pos = (col2, row3)\n        windspeed_pos = (col2 + icon_small, row3)\n\n        # Positions for sunrise, sunset, moonphase\n        moonphase_pos = (col3, row1)\n        sunrise_icon_pos = (col3, row2)\n        sunrise_time_pos = (col3 + icon_small, row2)\n        sunset_icon_pos = (col3, row3)\n        sunset_time_pos = (col3 + icon_small, row3)\n\n        # Positions for forecast 1\n        stamp_fc1 = (col4, row1) # noqa\n        icon_fc1 = (col4, row1 + row_height) # noqa\n        temp_fc1 = (col4, row3) # noqa\n\n        # Positions for forecast 2\n        stamp_fc2 = (col5, row1) # noqa\n        icon_fc2 = (col5, row1 + row_height) # noqa\n        temp_fc2 = (col5, row3) # noqa\n\n        # Positions for forecast 3\n        stamp_fc3 = (col6, row1) # noqa\n        icon_fc3 = (col6, row1 + row_height) # noqa\n        temp_fc3 = (col6, row3) # noqa\n\n        # Positions for forecast 4\n        stamp_fc4 = (col7, row1) # noqa\n        icon_fc4 = (col7, row1 + row_height) # noqa\n        temp_fc4 = (col7, row3) # noqa\n\n        # Create current-weather and weather-forecast objects\n        logging.debug('looking up location by ID')\n        current_weather = self.owm.get_current_weather()\n        weather_forecasts = self.owm.get_weather_forecast()\n\n        # Set decimals\n        dec_temp = 0 if self.round_temperature == True else 1\n        dec_wind = 0 if self.round_wind_speed == True else 1\n\n        logging.debug(f'temperature unit: {self.temp_unit}')\n        logging.debug(f'decimals temperature: {dec_temp} | decimals wind: {dec_wind}')\n\n        # Get current time\n        now = arrow.utcnow().to(self.timezone)\n\n        fc_data = {}\n\n        if self.forecast_interval == 'hourly':\n\n            logger.debug(\"getting hourly forecasts\")\n\n            # Add next 4 forecasts to fc_data dictionary, since we only have\n            fc_data = {}\n            for index, forecast in enumerate(weather_forecasts[0:4]):\n                fc_data['fc' + str(index + 1)] = {\n                    'temp': f\"{forecast['temp']:.{dec_temp}f}{self.tempDispUnit}\",\n                    'icon': forecast[\"icon\"],\n                    'stamp': arrow.get(forecast[\"datetime\"]).format(\"h a\" if self.hour_format == 12 else \"H:mm\")\n                }\n\n        elif self.forecast_interval == 'daily':\n\n            logger.debug(\"getting daily forecasts\")\n\n            daily_forecasts = [self.owm.get_forecast_for_day(days) for days in range(1, 5)]\n\n            for index, forecast in enumerate(daily_forecasts):\n                fc_data['fc' + str(index + 1)] = {\n                    'temp': f'{forecast[\"temp_min\"]:.{dec_temp}f}{self.tempDispUnit}/{forecast[\"temp_max\"]:.{dec_temp}f}{self.tempDispUnit}',\n                    'icon': forecast['icon'],\n                    'stamp': arrow.get(forecast['datetime']).format(\"ddd\", locale=self.locale)\n                }\n        else:\n            logger.error(f\"Invalid forecast interval specified: {self.forecast_interval}. Check your settings!\")\n\n        for key, val in fc_data.items():\n            logger.debug((key, val))\n\n        # Get some current weather details\n\n        temperature = f\"{current_weather['temp']:.{dec_temp}f}{self.tempDispUnit}\"\n\n        weather_icon = current_weather[\"weather_icon_name\"]\n        humidity = str(current_weather[\"humidity\"])\n\n        sunrise_raw = arrow.get(current_weather[\"sunrise\"]).to(self.timezone)\n        sunset_raw = arrow.get(current_weather[\"sunset\"]).to(self.timezone)\n\n        logger.debug(f'weather_icon: {weather_icon}')\n\n        if self.hour_format == 12:\n            logger.debug('using 12 hour format for sunrise/sunset')\n            sunrise = sunrise_raw.format('h:mm a')\n            sunset = sunset_raw.format('h:mm a')\n        else:\n            # 24 hours format\n            logger.debug('using 24 hour format for sunrise/sunset')\n            sunrise = sunrise_raw.format('H:mm')\n            sunset = sunset_raw.format('H:mm')\n\n        # Format the wind-speed to user preference\n        logging.debug(f'getting wind speed in {self.windDispUnit}')\n        wind = f\"{current_weather['wind']:.{dec_wind}f} {self.windDispUnit}\"\n\n        moon_phase = get_moon_phase()\n\n        # Fill weather details in col 1 (current weather icon)\n        canvas.draw_icon(\n            xy=weather_icon_pos,\n            box_size=(col_width, im_height),\n            icon=weather_icons[weather_icon],\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        # Fill weather details in col 2 (temp, humidity, wind)\n        canvas.draw_icon(\n            xy=temperature_icon_pos,\n            box_size=(icon_small, row_height),\n            icon='\\uf053',\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n        canvas.write(\n            xy=temperature_pos,\n            box_size=(col_width - icon_small, row_height),\n            text=temperature,\n            colour=\"colour\" if is_negative(temperature) else \"black\"\n        )\n\n        canvas.draw_icon(\n            xy=humidity_icon_pos,\n            box_size=(icon_small, row_height),\n            icon='\\uf07a',\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.write(\n            xy=humidity_pos,\n            box_size=(col_width - icon_small, row_height),\n            text=f\"{humidity} %\",\n        )\n\n        canvas.draw_icon(\n            xy=windspeed_icon_pos,\n            box_size=(icon_small, icon_small),\n            icon='\\uf050',\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.write(\n            xy=windspeed_pos,\n            box_size=(col_width - icon_small, row_height),\n            text=wind\n        )\n\n        # Fill weather details in col 3 (moonphase, sunrise, sunset)\n        canvas.draw_icon(\n            xy=moonphase_pos,\n            box_size=(col_width, row_height),\n            icon=moon_phase,\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.draw_icon(\n            xy=sunrise_icon_pos,\n            box_size=(icon_small, icon_small),\n            icon='\\uf051',\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.write(\n            xy=sunrise_time_pos,\n            box_size=(col_width - icon_small, row_height),\n            text=sunrise\n        )\n\n        canvas.draw_icon(\n            xy=sunset_icon_pos,\n            box_size=(icon_small, icon_small),\n            icon='\\uf052',\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.write(\n            xy=sunset_time_pos,\n            box_size=(col_width - icon_small, row_height),\n            text=sunset\n        )\n        # Add the forecast data to the correct places\n        for pos in range(1, len(fc_data) + 1):\n            stamp = fc_data[f'fc{pos}']['stamp']\n            # check if we're using daily forecasts\n            if \"day\" in stamp:\n                stamp = arrow.get(fc_data[f'fc{pos}']['stamp'], \"dddd\").format(\"dddd\", locale=self.locale)\n\n            icon = weather_icons[fc_data[f'fc{pos}']['icon']]\n            temp = fc_data[f'fc{pos}']['temp']\n\n            canvas.write(\n                xy=eval(f'stamp_fc{pos}'),\n                box_size=(col_width, row_height),\n                text=stamp\n            )\n\n            canvas.draw_icon(\n                xy=eval(f'icon_fc{pos}'),\n                box_size=(col_width, row_height + line_gap * 2),\n                icon=icon,\n                colour=\"colour\",\n                font=self.weatherfont\n            )\n\n            canvas.write(\n                xy=eval(f'temp_fc{pos}'),\n                box_size=(col_width, row_height),\n                text=temp\n            )\n\n        border_h = row3 + row_height\n        border_w = col_width - 3  # leave 3 pixels gap\n\n        # Add borders around each subsection\n        draw_border(canvas.image_black, (col1, row1), (col_width * 3 - 3, border_h),\n                    shrinkage=(0, 0))\n\n        for _ in range(4, 8):\n            draw_border(canvas.image_black, (eval(f'col{_}'), row1), (border_w, border_h),\n                        shrinkage=(0, 0))\n\n        # return the images ready for the display\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_weather.Weather.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_weather module</p> Source code in <code>inkycal/modules/inkycal_weather.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_weather module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    self.timezone = get_system_tz()\n\n    # Check if all required parameters are present\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # required parameters\n    self.api_key = config['api_key']\n    self.location = config['location']\n\n    # optional parameters\n    self.round_temperature = config['round_temperature']\n    self.round_wind_speed = config['round_windspeed']\n    self.forecast_interval = config['forecast_interval']\n    self.hour_format = int(config['hour_format'])\n    if config['units'] == \"imperial\":\n        self.temp_unit = \"fahrenheit\"\n    else:\n        self.temp_unit = \"celsius\"\n\n    if config['use_beaufort']:\n        self.wind_unit = \"beaufort\"\n    elif config['units'] == \"imperial\":\n        self.wind_unit = \"miles_hour\"\n    else:\n        self.wind_unit = \"meters_sec\"\n    self.locale = config['language']\n    # additional configuration\n\n    self.owm = OpenWeatherMap(\n        api_key=self.api_key,\n        city_id=self.location,\n        wind_unit=self.wind_unit,\n        temp_unit=self.temp_unit,\n        language=self.locale,\n        tz_name=self.timezone\n    )\n\n    self.weatherfont= FONTS.weather_icons\n\n    if self.wind_unit == \"beaufort\":\n        self.windDispUnit = \"bft\"\n    elif self.wind_unit == \"knots\":\n        self.windDispUnit = \"kn\"\n    elif self.wind_unit == \"km_hour\":\n        self.windDispUnit = \"km/h\"\n    elif self.wind_unit == \"miles_hour\":\n        self.windDispUnit = \"mph\"\n    else:\n        self.windDispUnit = \"m/s\"\n    if self.temp_unit == \"fahrenheit\":\n        self.tempDispUnit = \"F\"\n    elif self.temp_unit == \"celsius\":\n        self.tempDispUnit = \"\u00b0\"\n\n    # give an OK message\n    logger.debug(f\"{__name__} loaded\")\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_weather.Weather.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_weather.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'Image size: {im_size}')\n\n    # Create an image for black pixels and one for coloured pixels\n    canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n    # Check if internet is available\n    if internet_available():\n        logger.debug('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise NetworkNotReachableError\n\n    def get_moon_phase():\n        \"\"\"Calculate the current (approximate) moon phase\n\n        Returns:\n            The corresponding moonphase-icon.\n        \"\"\"\n\n        dec = decimal.Decimal\n        diff = now - arrow.get(2001, 1, 1)\n        days = dec(diff.days) + (dec(diff.seconds) / dec(86400))\n        lunations = dec(\"0.20439731\") + (days * dec(\"0.03386319269\"))\n        position = lunations % dec(1)\n        index = math.floor((position * dec(8)) + dec(\"0.5\"))\n        return {\n            0: '\\uf095',\n            1: '\\uf099',\n            2: '\\uf09c',\n            3: '\\uf0a0',\n            4: '\\uf0a3',\n            5: '\\uf0a7',\n            6: '\\uf0aa',\n            7: '\\uf0ae'\n        }[int(index) &amp; 7]\n\n    def is_negative(temp: str):\n        \"\"\"Check if temp is below freezing point of water (0\u00b0C/32\u00b0F)\n        returns True if temp below freezing point, else False\"\"\"\n        answer = False\n\n        if self.temp_unit == 'celsius' and round(float(temp.split(self.tempDispUnit)[0])) &lt;= 0:\n            answer = True\n        elif self.temp_unit == 'fahrenheit' and round(float(temp.split(self.tempDispUnit)[0])) &lt;= 32:\n            answer = True\n        return answer\n\n    # Lookup-table for weather icons and weather codes\n    weather_icons = {\n        '01d': '\\uf00d',\n        '02d': '\\uf002',\n        '03d': '\\uf013',\n        '04d': '\\uf012',\n        '09d': '\\uf01a',\n        '10d': '\\uf019',\n        '11d': '\\uf01e',\n        '13d': '\\uf01b',\n        '50d': '\\uf014',\n        '01n': '\\uf02e',\n        '02n': '\\uf013',\n        '03n': '\\uf013',\n        '04n': '\\uf013',\n        '09n': '\\uf037',\n        '10n': '\\uf036',\n        '11n': '\\uf03b',\n        '13n': '\\uf038',\n        '50n': '\\uf023'\n    }\n\n    #   column1    column2    column3    column4    column5    column6    column7\n    # |----------|----------|----------|----------|----------|----------|----------|\n    # |  time    | temperat.| moonphase| forecast1| forecast2| forecast3| forecast4|\n    # | current  |----------|----------|----------|----------|----------|----------|\n    # | weather  | humidity |  sunrise |  icon1   |  icon2   |  icon3   |  icon4   |\n    # |  icon    |----------|----------|----------|----------|----------|----------|\n    # |          | windspeed|  sunset  | temperat.| temperat.| temperat.| temperat.|\n    # |----------|----------|----------|----------|----------|----------|----------|\n\n    # Calculate size rows and columns\n    col_width = im_width // 7\n\n    # Ratio width height\n    image_ratio = im_width / im_height\n\n    if image_ratio &gt;= 4:\n        row_height = im_height // 3\n    else:\n        logger.info('Please consider decreasing the height.')\n        row_height = int((im_height * (1 - im_height / im_width)) / 3)\n\n    logger.debug(f\"row_height: {row_height} | col_width: {col_width}\")\n\n    # Calculate spacings for better centering\n    spacing_top = int((im_width % col_width) / 2)\n\n    # Define sizes for weather icons\n    icon_small = int(col_width / 3)\n\n    # Calculate the x-axis position of each col\n    col1 = spacing_top\n    col2 = col1 + col_width\n    col3 = col2 + col_width\n    col4 = col3 + col_width\n    col5 = col4 + col_width\n    col6 = col5 + col_width\n    col7 = col6 + col_width\n\n    # Calculate the y-axis position of each row\n    line_gap = int((im_height - spacing_top - 3 * row_height) // 4)\n\n    row1 = line_gap\n    row2 = row1 + line_gap + row_height\n    row3 = row2 + line_gap + row_height\n\n    # Draw lines on each row and border\n    # draw = ImageDraw.Draw(canvas.image_black)\n    # draw.line((0, 0, im_width, 0), fill='red')\n    # draw.line((0, im_height-1, im_width, im_height-1), fill='red')\n    # draw.line((0, row1, im_width, row1), fill='black')\n    # draw.line((0, row1+row_height, im_width, row1+row_height), fill='black')\n    # draw.line((0, row2, im_width, row2), fill='black')\n    # draw.line((0, row2+row_height, im_width, row2+row_height), fill='black')\n    # draw.line((0, row3, im_width, row3), fill='black')\n    # draw.line((0, row3+row_height, im_width, row3+row_height), fill='black')\n\n    # Positions for current weather details\n    weather_icon_pos = (col1, 0)\n    temperature_icon_pos = (col2, row1)\n    temperature_pos = (col2 + icon_small, row1)\n    humidity_icon_pos = (col2, row2)\n    humidity_pos = (col2 + icon_small, row2)\n    windspeed_icon_pos = (col2, row3)\n    windspeed_pos = (col2 + icon_small, row3)\n\n    # Positions for sunrise, sunset, moonphase\n    moonphase_pos = (col3, row1)\n    sunrise_icon_pos = (col3, row2)\n    sunrise_time_pos = (col3 + icon_small, row2)\n    sunset_icon_pos = (col3, row3)\n    sunset_time_pos = (col3 + icon_small, row3)\n\n    # Positions for forecast 1\n    stamp_fc1 = (col4, row1) # noqa\n    icon_fc1 = (col4, row1 + row_height) # noqa\n    temp_fc1 = (col4, row3) # noqa\n\n    # Positions for forecast 2\n    stamp_fc2 = (col5, row1) # noqa\n    icon_fc2 = (col5, row1 + row_height) # noqa\n    temp_fc2 = (col5, row3) # noqa\n\n    # Positions for forecast 3\n    stamp_fc3 = (col6, row1) # noqa\n    icon_fc3 = (col6, row1 + row_height) # noqa\n    temp_fc3 = (col6, row3) # noqa\n\n    # Positions for forecast 4\n    stamp_fc4 = (col7, row1) # noqa\n    icon_fc4 = (col7, row1 + row_height) # noqa\n    temp_fc4 = (col7, row3) # noqa\n\n    # Create current-weather and weather-forecast objects\n    logging.debug('looking up location by ID')\n    current_weather = self.owm.get_current_weather()\n    weather_forecasts = self.owm.get_weather_forecast()\n\n    # Set decimals\n    dec_temp = 0 if self.round_temperature == True else 1\n    dec_wind = 0 if self.round_wind_speed == True else 1\n\n    logging.debug(f'temperature unit: {self.temp_unit}')\n    logging.debug(f'decimals temperature: {dec_temp} | decimals wind: {dec_wind}')\n\n    # Get current time\n    now = arrow.utcnow().to(self.timezone)\n\n    fc_data = {}\n\n    if self.forecast_interval == 'hourly':\n\n        logger.debug(\"getting hourly forecasts\")\n\n        # Add next 4 forecasts to fc_data dictionary, since we only have\n        fc_data = {}\n        for index, forecast in enumerate(weather_forecasts[0:4]):\n            fc_data['fc' + str(index + 1)] = {\n                'temp': f\"{forecast['temp']:.{dec_temp}f}{self.tempDispUnit}\",\n                'icon': forecast[\"icon\"],\n                'stamp': arrow.get(forecast[\"datetime\"]).format(\"h a\" if self.hour_format == 12 else \"H:mm\")\n            }\n\n    elif self.forecast_interval == 'daily':\n\n        logger.debug(\"getting daily forecasts\")\n\n        daily_forecasts = [self.owm.get_forecast_for_day(days) for days in range(1, 5)]\n\n        for index, forecast in enumerate(daily_forecasts):\n            fc_data['fc' + str(index + 1)] = {\n                'temp': f'{forecast[\"temp_min\"]:.{dec_temp}f}{self.tempDispUnit}/{forecast[\"temp_max\"]:.{dec_temp}f}{self.tempDispUnit}',\n                'icon': forecast['icon'],\n                'stamp': arrow.get(forecast['datetime']).format(\"ddd\", locale=self.locale)\n            }\n    else:\n        logger.error(f\"Invalid forecast interval specified: {self.forecast_interval}. Check your settings!\")\n\n    for key, val in fc_data.items():\n        logger.debug((key, val))\n\n    # Get some current weather details\n\n    temperature = f\"{current_weather['temp']:.{dec_temp}f}{self.tempDispUnit}\"\n\n    weather_icon = current_weather[\"weather_icon_name\"]\n    humidity = str(current_weather[\"humidity\"])\n\n    sunrise_raw = arrow.get(current_weather[\"sunrise\"]).to(self.timezone)\n    sunset_raw = arrow.get(current_weather[\"sunset\"]).to(self.timezone)\n\n    logger.debug(f'weather_icon: {weather_icon}')\n\n    if self.hour_format == 12:\n        logger.debug('using 12 hour format for sunrise/sunset')\n        sunrise = sunrise_raw.format('h:mm a')\n        sunset = sunset_raw.format('h:mm a')\n    else:\n        # 24 hours format\n        logger.debug('using 24 hour format for sunrise/sunset')\n        sunrise = sunrise_raw.format('H:mm')\n        sunset = sunset_raw.format('H:mm')\n\n    # Format the wind-speed to user preference\n    logging.debug(f'getting wind speed in {self.windDispUnit}')\n    wind = f\"{current_weather['wind']:.{dec_wind}f} {self.windDispUnit}\"\n\n    moon_phase = get_moon_phase()\n\n    # Fill weather details in col 1 (current weather icon)\n    canvas.draw_icon(\n        xy=weather_icon_pos,\n        box_size=(col_width, im_height),\n        icon=weather_icons[weather_icon],\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    # Fill weather details in col 2 (temp, humidity, wind)\n    canvas.draw_icon(\n        xy=temperature_icon_pos,\n        box_size=(icon_small, row_height),\n        icon='\\uf053',\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n    canvas.write(\n        xy=temperature_pos,\n        box_size=(col_width - icon_small, row_height),\n        text=temperature,\n        colour=\"colour\" if is_negative(temperature) else \"black\"\n    )\n\n    canvas.draw_icon(\n        xy=humidity_icon_pos,\n        box_size=(icon_small, row_height),\n        icon='\\uf07a',\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    canvas.write(\n        xy=humidity_pos,\n        box_size=(col_width - icon_small, row_height),\n        text=f\"{humidity} %\",\n    )\n\n    canvas.draw_icon(\n        xy=windspeed_icon_pos,\n        box_size=(icon_small, icon_small),\n        icon='\\uf050',\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    canvas.write(\n        xy=windspeed_pos,\n        box_size=(col_width - icon_small, row_height),\n        text=wind\n    )\n\n    # Fill weather details in col 3 (moonphase, sunrise, sunset)\n    canvas.draw_icon(\n        xy=moonphase_pos,\n        box_size=(col_width, row_height),\n        icon=moon_phase,\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    canvas.draw_icon(\n        xy=sunrise_icon_pos,\n        box_size=(icon_small, icon_small),\n        icon='\\uf051',\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    canvas.write(\n        xy=sunrise_time_pos,\n        box_size=(col_width - icon_small, row_height),\n        text=sunrise\n    )\n\n    canvas.draw_icon(\n        xy=sunset_icon_pos,\n        box_size=(icon_small, icon_small),\n        icon='\\uf052',\n        colour=\"colour\",\n        font=self.weatherfont\n    )\n\n    canvas.write(\n        xy=sunset_time_pos,\n        box_size=(col_width - icon_small, row_height),\n        text=sunset\n    )\n    # Add the forecast data to the correct places\n    for pos in range(1, len(fc_data) + 1):\n        stamp = fc_data[f'fc{pos}']['stamp']\n        # check if we're using daily forecasts\n        if \"day\" in stamp:\n            stamp = arrow.get(fc_data[f'fc{pos}']['stamp'], \"dddd\").format(\"dddd\", locale=self.locale)\n\n        icon = weather_icons[fc_data[f'fc{pos}']['icon']]\n        temp = fc_data[f'fc{pos}']['temp']\n\n        canvas.write(\n            xy=eval(f'stamp_fc{pos}'),\n            box_size=(col_width, row_height),\n            text=stamp\n        )\n\n        canvas.draw_icon(\n            xy=eval(f'icon_fc{pos}'),\n            box_size=(col_width, row_height + line_gap * 2),\n            icon=icon,\n            colour=\"colour\",\n            font=self.weatherfont\n        )\n\n        canvas.write(\n            xy=eval(f'temp_fc{pos}'),\n            box_size=(col_width, row_height),\n            text=temp\n        )\n\n    border_h = row3 + row_height\n    border_w = col_width - 3  # leave 3 pixels gap\n\n    # Add borders around each subsection\n    draw_border(canvas.image_black, (col1, row1), (col_width * 3 - 3, border_h),\n                shrinkage=(0, 0))\n\n    for _ in range(4, 8):\n        draw_border(canvas.image_black, (eval(f'col{_}'), row1), (border_w, border_h),\n                    shrinkage=(0, 0))\n\n    # return the images ready for the display\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#feeds","title":"Feeds","text":"<p>Feeds module for InkyCal Project Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_feeds.Feeds","title":"<code>Feeds</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>RSS class parses rss/atom feeds from given urls</p> Source code in <code>inkycal/modules/inkycal_feeds.py</code> <pre><code>class Feeds(InkycalModule):\n    \"\"\"RSS class\n    parses rss/atom feeds from given urls\n    \"\"\"\n\n    name = \"RSS / Atom - Display feeds from given RSS/ATOM feeds\"\n\n    requires = {\n        \"feed_urls\": {\n            \"label\": \"Please enter ATOM or RSS feed URL/s, separated by a comma\",\n        },\n\n    }\n\n    optional = {\n\n        \"shuffle_feeds\": {\n            \"label\": \"Should the parsed RSS feeds be shuffled? (default=True)\",\n            \"options\": [True, False],\n            \"default\": True\n        },\n\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_feeds module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # Check if all required parameters are present\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # required parameters\n        if config[\"feed_urls\"] and isinstance(config['feed_urls'], str):\n            self.feed_urls = config[\"feed_urls\"].split(\",\")\n        else:\n            self.feed_urls = config[\"feed_urls\"]\n\n        # optional parameters\n        self.shuffle_feeds = config[\"shuffle_feeds\"]\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def _validate(self):\n        \"\"\"Validate module-specific parameters\"\"\"\n\n        if not isinstance(self.shuffle_feeds, bool):\n            print('shuffle_feeds has to be a boolean: True/False')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'Image size: {im_size}')\n\n        canvas = Canvas(im_size, self.font, self.fontsize)\n\n        # Check if internet is available\n        if internet_available():\n            logger.debug('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise NetworkNotReachableError\n\n        # Set some parameters for formatting feeds\n        line_spacing = 1\n\n        line_width = im_width\n        line_height = canvas.get_line_height() + line_spacing\n        max_lines = (im_height // (line_height + line_spacing))\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        # Create list containing all feeds from all urls\n        parsed_feeds = []\n        for feeds in self.feed_urls:\n            text = feedparser.parse(feeds)\n            for posts in text.entries:\n                if \"summary\" in posts:\n                    summary = posts[\"summary\"]\n                    parsed_feeds.append(f\"\u2022{posts.title}: {re.sub('&lt;[^&lt;]+?&gt;', '', posts.summary)}\")\n                # if \"description\" in posts:\n\n        if parsed_feeds:\n            parsed_feeds = [i.split(\"\\n\") for i in parsed_feeds]\n            parsed_feeds = [i for i in parsed_feeds if i]\n\n        # Shuffle the list to prevent showing the same content\n        if self.shuffle_feeds:\n            shuffle(parsed_feeds)\n\n        # Trim down the list to the max number of lines\n        del parsed_feeds[max_lines:]\n\n        # Wrap long text from feeds (line-breaking)\n        flatten = lambda z: [x for y in z for x in y]\n        filtered_feeds, counter = [], 0\n\n        for posts in parsed_feeds:\n            wrapped = canvas.text_wrap(posts[0], max_width=line_width)\n            counter += len(wrapped)\n            if counter &lt; max_lines:\n                filtered_feeds.append(wrapped)\n        filtered_feeds = flatten(filtered_feeds)\n\n        logger.debug(f'filtered feeds -&gt; {filtered_feeds}')\n\n        # Check if feeds could be parsed and can be displayed\n        if len(filtered_feeds) == 0 and len(parsed_feeds) &gt; 0:\n            print('Feeds could be parsed, but the text is too long to be displayed:/')\n        elif len(filtered_feeds) == 0 and len(parsed_feeds) == 0:\n            print('No feeds could be parsed :/')\n        else:\n            # Write feeds on image\n            for _ in range(len(filtered_feeds)):\n                canvas.write(\n                    xy=line_positions[_],\n                    box_size=(line_width, line_height),\n                    text=filtered_feeds[_],\n                    alignment=\"left\"\n                )\n        # return images\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_feeds.Feeds.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_feeds module</p> Source code in <code>inkycal/modules/inkycal_feeds.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_feeds module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # Check if all required parameters are present\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # required parameters\n    if config[\"feed_urls\"] and isinstance(config['feed_urls'], str):\n        self.feed_urls = config[\"feed_urls\"].split(\",\")\n    else:\n        self.feed_urls = config[\"feed_urls\"]\n\n    # optional parameters\n    self.shuffle_feeds = config[\"shuffle_feeds\"]\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_feeds.Feeds.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_feeds.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'Image size: {im_size}')\n\n    canvas = Canvas(im_size, self.font, self.fontsize)\n\n    # Check if internet is available\n    if internet_available():\n        logger.debug('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise NetworkNotReachableError\n\n    # Set some parameters for formatting feeds\n    line_spacing = 1\n\n    line_width = im_width\n    line_height = canvas.get_line_height() + line_spacing\n    max_lines = (im_height // (line_height + line_spacing))\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    # Create list containing all feeds from all urls\n    parsed_feeds = []\n    for feeds in self.feed_urls:\n        text = feedparser.parse(feeds)\n        for posts in text.entries:\n            if \"summary\" in posts:\n                summary = posts[\"summary\"]\n                parsed_feeds.append(f\"\u2022{posts.title}: {re.sub('&lt;[^&lt;]+?&gt;', '', posts.summary)}\")\n            # if \"description\" in posts:\n\n    if parsed_feeds:\n        parsed_feeds = [i.split(\"\\n\") for i in parsed_feeds]\n        parsed_feeds = [i for i in parsed_feeds if i]\n\n    # Shuffle the list to prevent showing the same content\n    if self.shuffle_feeds:\n        shuffle(parsed_feeds)\n\n    # Trim down the list to the max number of lines\n    del parsed_feeds[max_lines:]\n\n    # Wrap long text from feeds (line-breaking)\n    flatten = lambda z: [x for y in z for x in y]\n    filtered_feeds, counter = [], 0\n\n    for posts in parsed_feeds:\n        wrapped = canvas.text_wrap(posts[0], max_width=line_width)\n        counter += len(wrapped)\n        if counter &lt; max_lines:\n            filtered_feeds.append(wrapped)\n    filtered_feeds = flatten(filtered_feeds)\n\n    logger.debug(f'filtered feeds -&gt; {filtered_feeds}')\n\n    # Check if feeds could be parsed and can be displayed\n    if len(filtered_feeds) == 0 and len(parsed_feeds) &gt; 0:\n        print('Feeds could be parsed, but the text is too long to be displayed:/')\n    elif len(filtered_feeds) == 0 and len(parsed_feeds) == 0:\n        print('No feeds could be parsed :/')\n    else:\n        # Write feeds on image\n        for _ in range(len(filtered_feeds)):\n            canvas.write(\n                xy=line_positions[_],\n                box_size=(line_width, line_height),\n                text=filtered_feeds[_],\n                alignment=\"left\"\n            )\n    # return images\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#stocks","title":"Stocks","text":"<p>Stocks Module for Inkycal Project</p> <p>Version 0.6: Dropped matplotlib dependency in favour of render_line_chart function Version 0.5: Added improved precision by using new priceHint parameter of yfinance Version 0.4: Added charts Version 0.3: Added support for web-UI of Inkycal 2.0.0 Version 0.2: Migration to Inkycal 2.0.0 Version 0.1: Migration to Inkycal 2.0.0b</p> <p>by https://github.com/worstface</p>"},{"location":"reference/#inkycal.modules.inkycal_stocks.Stocks","title":"<code>Stocks</code>","text":"<p>               Bases: <code>InkycalModule</code></p> Source code in <code>inkycal/modules/inkycal_stocks.py</code> <pre><code>class Stocks(InkycalModule):\n    name = \"Stocks - Displays stock market infos from Yahoo finance\"\n\n    # required parameters\n    requires = {\n\n        \"tickers\": {\n\n            \"label\": \"You can display any information by using \"\n                     \"the respective symbols that are used by Yahoo! Finance. \"\n                     \"Separate multiple symbols with a comma sign e.g. \"\n                     \"TSLA, U, NVDA, EURUSD=X\"\n        }\n    }\n\n    def __init__(self, config):\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # If tickers is a string from web-ui, convert to a list, else use\n        # tickers as-is i.e. for tests\n        if config['tickers'] and isinstance(config['tickers'], str):\n            self.tickers = config['tickers'].replace(\" \", \"\").split(',')  # returns list\n        else:\n            self.tickers = config['tickers']\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'image size: {im_width} x {im_height} px')\n\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Create tmp path\n        tmpPath = 'temp/'\n\n        if not os.path.exists(tmpPath):\n            print(f\"Creating tmp directory {tmpPath}\")\n            os.mkdir(tmpPath)\n\n        # Check if internet is available\n        if internet_available():\n            logger.info('Connection test passed')\n        else:\n            raise Exception('Network could not be reached :/')\n\n        # Set some parameters for formatting feeds\n        line_spacing = 1\n        line_height = canvas.get_line_height()\n        line_width = im_width\n        max_lines = (im_height // (line_height + line_spacing))\n\n        logger.debug(f\"max_lines: {max_lines}\")\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        logger.debug(f'line positions: {line_positions}')\n\n        parsed_tickers = []\n        parsed_tickers_colour = []\n        chartSpace = Image.new('RGBA', (im_width, im_height), \"white\")\n        chartSpace_colour = Image.new('RGBA', (im_width, im_height), \"white\")\n\n        tickerCount = range(len(self.tickers))\n\n        for _ in tickerCount:\n            ticker = self.tickers[_]\n            logger.info(f'preparing data for {ticker}...')\n\n            yfTicker = yf.Ticker(ticker)\n\n            try:\n                stockInfo = yfTicker.info\n            except Exception as exceptionMessage:\n                logger.warning(f\"Failed to get '{ticker}' ticker info: {exceptionMessage}\")\n\n            try:\n                stockName = stockInfo['shortName']\n            except Exception:\n                stockName = ticker\n                logger.warning(f\"Failed to get '{stockName}' ticker name! Using \"\n                               \"the ticker symbol as name instead.\")\n\n            try:\n                stockCurrency = stockInfo['currency']\n                if stockCurrency == 'USD':\n                    stockCurrency = '$'\n                elif stockCurrency == 'EUR':\n                    stockCurrency = '\u20ac'\n            except Exception:\n                stockCurrency = ''\n                logger.warning(f\"Failed to get ticker currency!\")\n\n            try:\n                precision = stockInfo['priceHint']\n            except Exception:\n                precision = 2\n                logger.warning(f\"Failed to get '{stockName}' ticker price hint! Using \"\n                               \"default precision of 2 instead.\")\n\n            stockHistory = yfTicker.history(\"1mo\")\n            stockHistoryLen = len(stockHistory)\n            logger.info(f'fetched {stockHistoryLen} datapoints ...')\n            previousQuote = (stockHistory.tail(2)['Close'].iloc[0])\n            currentQuote = (stockHistory.tail(1)['Close'].iloc[0])\n            currentHigh = (stockHistory.tail(1)['High'].iloc[0])\n            currentLow = (stockHistory.tail(1)['Low'].iloc[0])\n            currentOpen = (stockHistory.tail(1)['Open'].iloc[0])\n            currentGain = currentQuote - previousQuote\n            currentGainPercentage = (1 - currentQuote / previousQuote) * -100\n            firstQuote = stockHistory.tail(stockHistoryLen)['Close'].iloc[0]\n            logger.info(f'firstQuote {firstQuote} ...')\n\n            def floatStr(precision, number):\n                return \"%0.*f\" % (precision, number)\n\n            def percentageStr(number):\n                return '({:+.2f}%)'.format(number)\n\n            def gainStr(precision, number):\n                return \"%+.*f\" % (precision, number)\n\n            stockNameLine = '{} ({})'.format(stockName, stockCurrency)\n            stockCurrentValueLine = '{} {} {}'.format(\n                floatStr(precision, currentQuote), gainStr(precision, currentGain),\n                percentageStr(currentGainPercentage))\n            stockDayValueLine = '1d OHL: {}/{}/{}'.format(\n                floatStr(precision, currentOpen), floatStr(precision, currentHigh), floatStr(precision, currentLow))\n            maxQuote = max(stockHistory.High)\n            minQuote = min(stockHistory.Low)\n            logger.info(f'high {maxQuote} low {minQuote} ...')\n            stockMonthValueLine = '{}d OHL: {}/{}/{}'.format(\n                stockHistoryLen, floatStr(precision, firstQuote), floatStr(precision, maxQuote),\n                floatStr(precision, minQuote))\n\n            logger.info(stockNameLine)\n            logger.info(stockCurrentValueLine)\n            logger.info(stockDayValueLine)\n            logger.info(stockMonthValueLine)\n            parsed_tickers.append(stockNameLine)\n            parsed_tickers.append(stockCurrentValueLine)\n            parsed_tickers.append(stockDayValueLine)\n            parsed_tickers.append(stockMonthValueLine)\n\n            parsed_tickers_colour.append(\"\")\n            if currentGain &lt; 0:\n                parsed_tickers_colour.append(stockCurrentValueLine)\n            else:\n                parsed_tickers_colour.append(\"\")\n            if currentOpen &gt; currentQuote:\n                parsed_tickers_colour.append(stockDayValueLine)\n            else:\n                parsed_tickers_colour.append(\"\")\n            if firstQuote &gt; currentQuote:\n                parsed_tickers_colour.append(stockMonthValueLine)\n            else:\n                parsed_tickers_colour.append(\"\")\n\n            if _ &lt; len(tickerCount):\n                parsed_tickers.append(\"\")\n                parsed_tickers_colour.append(\"\")\n\n            logger.info(f'creating chart data...')\n            chartData = stockHistory.reset_index()\n            chartCloseData = chartData.loc[:, 'Close']\n            chartTimeData = chartData.loc[:, 'Date']\n\n            logger.info('creating chart plot with Pillow...')\n            # We only need the Close series; time axis is implicit (index)\n            close_values = list(chartCloseData)\n\n            # Decide chart size \u2014 similar to your thumbnail size\n            chart_w = int(im_width / 4)\n            chart_h = int(line_height * 4)\n\n            chartImage = render_line_chart(\n                values=close_values,\n                size=(chart_w, chart_h),\n                line_width=2,\n                line_color=\"black\",\n                bg_color=\"white\",\n                padding=2,\n            )\n\n            logger.info(f'chartSpace is...{im_width} {im_height}')\n            chartPasteX = im_width - chartImage.width\n            chartPasteY = line_height * 5 * _\n            logger.info(f'pasting chart image with index {_} to...{chartPasteX} {chartPasteY}')\n\n            if firstQuote &gt; currentQuote:\n                chartSpace_colour.paste(chartImage, (chartPasteX, chartPasteY))\n            else:\n                chartSpace.paste(chartImage, (chartPasteX, chartPasteY))\n        canvas.image_black.paste(chartSpace)\n        canvas.image_colour.paste(chartSpace_colour)\n\n        # Write/Draw something on the black image\n        for _ in range(len(parsed_tickers)):\n            if _ + 1 &gt; max_lines:\n                logger.error('Ran out of lines for parsed_ticker_colour')\n                break\n            canvas.write(\n                xy=line_positions[_],\n                box_size= (line_width, line_height),\n                text=parsed_tickers[_],\n                alignment='left'\n            )\n\n        # Write/Draw something on the colour image\n        for _ in range(len(parsed_tickers_colour)):\n            if _ + 1 &gt; max_lines:\n                logger.error('Ran out of lines for parsed_tickers_colour')\n                break\n            canvas.write(\n                xy=line_positions[_],\n                box_size= (line_width, line_height),\n                text=parsed_tickers[_],\n                alignment='left'\n            )\n\n        # Save image of black and colour channel in image-folder\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_stocks.Stocks.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_stocks.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'image size: {im_width} x {im_height} px')\n\n    canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n    # Create tmp path\n    tmpPath = 'temp/'\n\n    if not os.path.exists(tmpPath):\n        print(f\"Creating tmp directory {tmpPath}\")\n        os.mkdir(tmpPath)\n\n    # Check if internet is available\n    if internet_available():\n        logger.info('Connection test passed')\n    else:\n        raise Exception('Network could not be reached :/')\n\n    # Set some parameters for formatting feeds\n    line_spacing = 1\n    line_height = canvas.get_line_height()\n    line_width = im_width\n    max_lines = (im_height // (line_height + line_spacing))\n\n    logger.debug(f\"max_lines: {max_lines}\")\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    logger.debug(f'line positions: {line_positions}')\n\n    parsed_tickers = []\n    parsed_tickers_colour = []\n    chartSpace = Image.new('RGBA', (im_width, im_height), \"white\")\n    chartSpace_colour = Image.new('RGBA', (im_width, im_height), \"white\")\n\n    tickerCount = range(len(self.tickers))\n\n    for _ in tickerCount:\n        ticker = self.tickers[_]\n        logger.info(f'preparing data for {ticker}...')\n\n        yfTicker = yf.Ticker(ticker)\n\n        try:\n            stockInfo = yfTicker.info\n        except Exception as exceptionMessage:\n            logger.warning(f\"Failed to get '{ticker}' ticker info: {exceptionMessage}\")\n\n        try:\n            stockName = stockInfo['shortName']\n        except Exception:\n            stockName = ticker\n            logger.warning(f\"Failed to get '{stockName}' ticker name! Using \"\n                           \"the ticker symbol as name instead.\")\n\n        try:\n            stockCurrency = stockInfo['currency']\n            if stockCurrency == 'USD':\n                stockCurrency = '$'\n            elif stockCurrency == 'EUR':\n                stockCurrency = '\u20ac'\n        except Exception:\n            stockCurrency = ''\n            logger.warning(f\"Failed to get ticker currency!\")\n\n        try:\n            precision = stockInfo['priceHint']\n        except Exception:\n            precision = 2\n            logger.warning(f\"Failed to get '{stockName}' ticker price hint! Using \"\n                           \"default precision of 2 instead.\")\n\n        stockHistory = yfTicker.history(\"1mo\")\n        stockHistoryLen = len(stockHistory)\n        logger.info(f'fetched {stockHistoryLen} datapoints ...')\n        previousQuote = (stockHistory.tail(2)['Close'].iloc[0])\n        currentQuote = (stockHistory.tail(1)['Close'].iloc[0])\n        currentHigh = (stockHistory.tail(1)['High'].iloc[0])\n        currentLow = (stockHistory.tail(1)['Low'].iloc[0])\n        currentOpen = (stockHistory.tail(1)['Open'].iloc[0])\n        currentGain = currentQuote - previousQuote\n        currentGainPercentage = (1 - currentQuote / previousQuote) * -100\n        firstQuote = stockHistory.tail(stockHistoryLen)['Close'].iloc[0]\n        logger.info(f'firstQuote {firstQuote} ...')\n\n        def floatStr(precision, number):\n            return \"%0.*f\" % (precision, number)\n\n        def percentageStr(number):\n            return '({:+.2f}%)'.format(number)\n\n        def gainStr(precision, number):\n            return \"%+.*f\" % (precision, number)\n\n        stockNameLine = '{} ({})'.format(stockName, stockCurrency)\n        stockCurrentValueLine = '{} {} {}'.format(\n            floatStr(precision, currentQuote), gainStr(precision, currentGain),\n            percentageStr(currentGainPercentage))\n        stockDayValueLine = '1d OHL: {}/{}/{}'.format(\n            floatStr(precision, currentOpen), floatStr(precision, currentHigh), floatStr(precision, currentLow))\n        maxQuote = max(stockHistory.High)\n        minQuote = min(stockHistory.Low)\n        logger.info(f'high {maxQuote} low {minQuote} ...')\n        stockMonthValueLine = '{}d OHL: {}/{}/{}'.format(\n            stockHistoryLen, floatStr(precision, firstQuote), floatStr(precision, maxQuote),\n            floatStr(precision, minQuote))\n\n        logger.info(stockNameLine)\n        logger.info(stockCurrentValueLine)\n        logger.info(stockDayValueLine)\n        logger.info(stockMonthValueLine)\n        parsed_tickers.append(stockNameLine)\n        parsed_tickers.append(stockCurrentValueLine)\n        parsed_tickers.append(stockDayValueLine)\n        parsed_tickers.append(stockMonthValueLine)\n\n        parsed_tickers_colour.append(\"\")\n        if currentGain &lt; 0:\n            parsed_tickers_colour.append(stockCurrentValueLine)\n        else:\n            parsed_tickers_colour.append(\"\")\n        if currentOpen &gt; currentQuote:\n            parsed_tickers_colour.append(stockDayValueLine)\n        else:\n            parsed_tickers_colour.append(\"\")\n        if firstQuote &gt; currentQuote:\n            parsed_tickers_colour.append(stockMonthValueLine)\n        else:\n            parsed_tickers_colour.append(\"\")\n\n        if _ &lt; len(tickerCount):\n            parsed_tickers.append(\"\")\n            parsed_tickers_colour.append(\"\")\n\n        logger.info(f'creating chart data...')\n        chartData = stockHistory.reset_index()\n        chartCloseData = chartData.loc[:, 'Close']\n        chartTimeData = chartData.loc[:, 'Date']\n\n        logger.info('creating chart plot with Pillow...')\n        # We only need the Close series; time axis is implicit (index)\n        close_values = list(chartCloseData)\n\n        # Decide chart size \u2014 similar to your thumbnail size\n        chart_w = int(im_width / 4)\n        chart_h = int(line_height * 4)\n\n        chartImage = render_line_chart(\n            values=close_values,\n            size=(chart_w, chart_h),\n            line_width=2,\n            line_color=\"black\",\n            bg_color=\"white\",\n            padding=2,\n        )\n\n        logger.info(f'chartSpace is...{im_width} {im_height}')\n        chartPasteX = im_width - chartImage.width\n        chartPasteY = line_height * 5 * _\n        logger.info(f'pasting chart image with index {_} to...{chartPasteX} {chartPasteY}')\n\n        if firstQuote &gt; currentQuote:\n            chartSpace_colour.paste(chartImage, (chartPasteX, chartPasteY))\n        else:\n            chartSpace.paste(chartImage, (chartPasteX, chartPasteY))\n    canvas.image_black.paste(chartSpace)\n    canvas.image_colour.paste(chartSpace_colour)\n\n    # Write/Draw something on the black image\n    for _ in range(len(parsed_tickers)):\n        if _ + 1 &gt; max_lines:\n            logger.error('Ran out of lines for parsed_ticker_colour')\n            break\n        canvas.write(\n            xy=line_positions[_],\n            box_size= (line_width, line_height),\n            text=parsed_tickers[_],\n            alignment='left'\n        )\n\n    # Write/Draw something on the colour image\n    for _ in range(len(parsed_tickers_colour)):\n        if _ + 1 &gt; max_lines:\n            logger.error('Ran out of lines for parsed_tickers_colour')\n            break\n        canvas.write(\n            xy=line_positions[_],\n            box_size= (line_width, line_height),\n            text=parsed_tickers[_],\n            alignment='left'\n        )\n\n    # Save image of black and colour channel in image-folder\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#image-module","title":"Image Module","text":"<p>Inkycal Image Module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_image.Inkyimage","title":"<code>Inkyimage</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Displays an image from URL or local path</p> Source code in <code>inkycal/modules/inkycal_image.py</code> <pre><code>class Inkyimage(InkycalModule):\n    \"\"\"Displays an image from URL or local path\"\"\"\n\n    name = \"Inkycal Image - show an image from a URL or local path\"\n\n    requires = {\n        \"path\": {\n            \"label\": \"Path to a local folder, e.g. /home/pi/Desktop/images. \"\n            \"Only PNG and JPG/JPEG images are used for the slideshow.\"\n        },\n        \"palette\": {\"label\": \"Which palette should be used for converting images?\", \"options\": [\"bw\", \"bwr\", \"bwy\"]},\n    }\n\n    optional = {\n        \"autoflip\": {\"label\": \"Should the image be flipped automatically?\", \"options\": [True, False]},\n        \"orientation\": {\"label\": \"Please select the desired orientation\", \"options\": [\"vertical\", \"horizontal\"]},\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize module\"\"\"\n\n        super().__init__(config)\n\n        config = config[\"config\"]\n\n        # required parameters\n        for param in self.requires:\n            if not param in config:\n                raise Exception(f\"config is missing {param}\")\n\n        # optional parameters\n        self.path = config[\"path\"]\n        self.palette = config[\"palette\"]\n        self.autoflip = config[\"autoflip\"]\n        self.orientation = config[\"orientation\"]\n        self.dither = True\n        if \"dither\" in config and config[\"dither\"] == False:\n            self.dither = False\n\n        # give an OK message\n        logger.debug(f\"{__name__} loaded\")\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n\n        logger.info(f\"Image size: {im_size}\")\n\n        # initialize custom image class\n        im = Images()\n\n        # use the image at the first index\n        im.load(self.path)\n\n        # Remove background if present\n        im.remove_alpha()\n\n        # if auto-flip was enabled, flip the image\n        if self.autoflip:\n            im.autoflip(self.orientation)\n\n        # resize the image so it can fit on the epaper\n        im.resize(width=im_width, height=im_height)\n\n        # convert images according to specified palette\n        im_black, im_colour = image_to_palette(image=im.image.convert(\"RGB\"), palette=self.palette, dither=self.dither)\n\n        # with the images now send, clear the current image\n        im.clear()\n\n        # return images\n        return im_black, im_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_image.Inkyimage.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize module</p> Source code in <code>inkycal/modules/inkycal_image.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize module\"\"\"\n\n    super().__init__(config)\n\n    config = config[\"config\"]\n\n    # required parameters\n    for param in self.requires:\n        if not param in config:\n            raise Exception(f\"config is missing {param}\")\n\n    # optional parameters\n    self.path = config[\"path\"]\n    self.palette = config[\"palette\"]\n    self.autoflip = config[\"autoflip\"]\n    self.orientation = config[\"orientation\"]\n    self.dither = True\n    if \"dither\" in config and config[\"dither\"] == False:\n        self.dither = False\n\n    # give an OK message\n    logger.debug(f\"{__name__} loaded\")\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_image.Inkyimage.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_image.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n\n    logger.info(f\"Image size: {im_size}\")\n\n    # initialize custom image class\n    im = Images()\n\n    # use the image at the first index\n    im.load(self.path)\n\n    # Remove background if present\n    im.remove_alpha()\n\n    # if auto-flip was enabled, flip the image\n    if self.autoflip:\n        im.autoflip(self.orientation)\n\n    # resize the image so it can fit on the epaper\n    im.resize(width=im_width, height=im_height)\n\n    # convert images according to specified palette\n    im_black, im_colour = image_to_palette(image=im.image.convert(\"RGB\"), palette=self.palette, dither=self.dither)\n\n    # with the images now send, clear the current image\n    im.clear()\n\n    # return images\n    return im_black, im_colour\n</code></pre>"},{"location":"reference/#agenda","title":"Agenda","text":"<p>Inkycal Agenda Module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_agenda.Agenda","title":"<code>Agenda</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Agenda class Create agenda and show events from given icalendars</p> Source code in <code>inkycal/modules/inkycal_agenda.py</code> <pre><code>class Agenda(InkycalModule):\n    \"\"\"Agenda class\n    Create agenda and show events from given icalendars\n    \"\"\"\n\n    name = \"Agenda - Display upcoming events from given iCalendars\"\n\n    requires = {\n        \"ical_urls\": {\n            \"label\": \"iCalendar URL/s, separate multiple ones with a comma\",\n        },\n\n    }\n\n    optional = {\n        \"ical_files\": {\n            \"label\": \"iCalendar filepaths, separated with a comma\",\n        },\n\n        \"date_format\": {\n            \"label\": \"Use an arrow-supported token for custom date formatting \" +\n                     \"see https://arrow.readthedocs.io/en/stable/#supported-tokens, e.g. ddd D MMM\",\n            \"default\": \"ddd D MMM\",\n        },\n\n        \"time_format\": {\n            \"label\": \"Use an arrow-supported token for custom time formatting \" +\n                     \"see https://arrow.readthedocs.io/en/stable/#supported-tokens, e.g. HH:mm\",\n            \"default\": \"HH:mm\",\n        },\n\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_agenda module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # Check if all required parameters are present\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # module specific parameters\n        self.date_format = config['date_format']\n        self.time_format = config['time_format']\n        self.language = config['language']\n\n        # Check if ical_files is an empty string\n        if config['ical_urls'] and isinstance(config['ical_urls'], str):\n            self.ical_urls = config['ical_urls'].split(',')\n        else:\n            self.ical_urls = config['ical_urls']\n\n        # Check if ical_files is an empty string\n        if config['ical_files'] and isinstance(config['ical_files'], str):\n            self.ical_files = config['ical_files'].split(',')\n        else:\n            self.ical_files = config['ical_files']\n\n        # Additional config\n        self.timezone = get_system_tz()\n\n        self.icon_font = FONTS.material_icons\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n\n        logger.debug(f'Image size: {im_size}')\n\n        canvas = Canvas(im_size, self.font, self.fontsize)\n\n        # Calculate the max number of lines that can fit on the image\n        line_spacing = 1\n\n        line_height = canvas.get_line_height() + line_spacing\n        max_lines = im_height // line_height\n        logger.debug(f'max lines: {max_lines}')\n\n        # Create timeline for agenda\n        now = arrow.now()\n        today = now.floor('day')\n\n        # Create a list of dates for the next days\n        agenda_events = [\n            {\n                'begin': today.shift(days=+_),\n                'title': today.shift(days=+_).format(\n                    self.date_format, locale=self.language)\n            }\n            for _ in range(max_lines)]\n\n        # Load icalendar from config\n        ical = iCalendar()\n\n        if self.ical_urls:\n            ical.load_url(self.ical_urls)\n\n        if self.ical_files:\n            ical.load_from_file(self.ical_files)\n\n        # Load events from all icalendar in timerange\n        upcoming_events = ical.get_events(today, agenda_events[-1]['begin'],\n                                            self.timezone)\n\n        # Sort events by beginning time\n        ical.sort()\n        # parser.show_events()\n\n        # Set the width for date, time and event titles\n        date_strings = [date['begin'].format(self.date_format, locale=self.language) for date in agenda_events]\n        longest_date = max(date_strings, key=len)\n\n        date_width = canvas.get_text_width(longest_date)\n        logger.debug(f'date_width: {date_width}')\n\n        # Calculate positions for each line\n        line_pos = [(0, int(line * line_height)) for line in range(max_lines)]\n        logger.debug(f'line_pos: {line_pos}')\n\n        # Check if any events were filtered\n        if upcoming_events:\n            logger.info('Managed to parse events from urls')\n\n            # Find out how much space the event times take\n\n            time_width = int(max([self.font.getlength(\n                events['begin'].format(self.time_format, locale=self.language))\n                for events in upcoming_events]) + 10)\n            logger.debug(f'time_width: {time_width}')\n\n            # Calculate x-pos for time\n            x_time = int(date_width/3)\n            logger.debug(f'x-time: {x_time}')\n\n            # Find out how much space is left for event titles\n            event_width = im_width - time_width \n            logger.debug(f'width for events: {event_width}')\n\n            # Calculate x-pos for event titles\n            x_event = int(date_width/3) + time_width\n            logger.debug(f'x-event: {x_event}')\n\n            # Merge list of dates and list of events\n            agenda_events += upcoming_events\n\n            # Sort the combined list in chronological order of dates\n            by_date = lambda event: event['begin']\n            agenda_events.sort(key=by_date)\n\n            # Delete more entries than can be displayed (max lines)\n            del agenda_events[max_lines:]\n\n            cursor = 0\n            for _ in agenda_events:\n                title = _['title']\n\n                # Check if item is a date\n                if 'end' not in _:\n                    ImageDraw.Draw(canvas.image_colour).line(\n                        (0, line_pos[cursor][1], im_width, line_pos[cursor][1]),\n                        fill='black')\n\n                    canvas.write(\n                        xy=line_pos[cursor],\n                        box_size=(date_width, line_height),\n                        text=title,\n                        alignment=\"left\")\n\n                    cursor += 1\n\n                # Check if item is an event\n                if 'end' in _:\n                    time = _['begin'].format(self.time_format, locale=self.language)\n\n                    # Check if event is all day, if not, add the time\n                    if not ical.all_day(_):\n                        canvas.write(\n                            xy=(x_time, line_pos[cursor][1]),\n                            box_size=(time_width, line_height),\n                            text=time,\n                            alignment=\"right\")\n                    else:\n                        canvas.set_font(font=self.icon_font, font_size=self.fontsize)\n\n                        canvas.write(\n                            xy=(x_time, line_pos[cursor][1]),\n                            box_size=(time_width, line_height),\n                            text=\"\\ue878\",\n                            alignment=\"right\")\n\n                    canvas.set_font(font=self.font, font_size=self.fontsize)\n                    canvas.write(\n                        xy=(x_event, line_pos[cursor][1]),\n                        box_size=(event_width, line_height),\n                        text=' \u2022 ' + title,\n                        alignment=\"left\")\n                    cursor += 1\n\n        # If no events were found, write only dates and lines\n        else:\n            logger.info('no events found')\n\n            cursor = 0\n            for _ in agenda_events:\n                title = _['title']\n                ImageDraw.Draw(canvas.image_colour).line(\n                    (0, line_pos[cursor][1], im_width, line_pos[cursor][1]),\n                    fill='black')\n\n                canvas.write(\n                    xy=line_pos[cursor],\n                    box_size=(date_width, line_height),\n                    text=title,\n                    alignment=\"left\")\n                cursor += 1\n\n        # return the images ready for the display\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_agenda.Agenda.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_agenda module</p> Source code in <code>inkycal/modules/inkycal_agenda.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_agenda module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # Check if all required parameters are present\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # module specific parameters\n    self.date_format = config['date_format']\n    self.time_format = config['time_format']\n    self.language = config['language']\n\n    # Check if ical_files is an empty string\n    if config['ical_urls'] and isinstance(config['ical_urls'], str):\n        self.ical_urls = config['ical_urls'].split(',')\n    else:\n        self.ical_urls = config['ical_urls']\n\n    # Check if ical_files is an empty string\n    if config['ical_files'] and isinstance(config['ical_files'], str):\n        self.ical_files = config['ical_files'].split(',')\n    else:\n        self.ical_files = config['ical_files']\n\n    # Additional config\n    self.timezone = get_system_tz()\n\n    self.icon_font = FONTS.material_icons\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_agenda.Agenda.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_agenda.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n\n    logger.debug(f'Image size: {im_size}')\n\n    canvas = Canvas(im_size, self.font, self.fontsize)\n\n    # Calculate the max number of lines that can fit on the image\n    line_spacing = 1\n\n    line_height = canvas.get_line_height() + line_spacing\n    max_lines = im_height // line_height\n    logger.debug(f'max lines: {max_lines}')\n\n    # Create timeline for agenda\n    now = arrow.now()\n    today = now.floor('day')\n\n    # Create a list of dates for the next days\n    agenda_events = [\n        {\n            'begin': today.shift(days=+_),\n            'title': today.shift(days=+_).format(\n                self.date_format, locale=self.language)\n        }\n        for _ in range(max_lines)]\n\n    # Load icalendar from config\n    ical = iCalendar()\n\n    if self.ical_urls:\n        ical.load_url(self.ical_urls)\n\n    if self.ical_files:\n        ical.load_from_file(self.ical_files)\n\n    # Load events from all icalendar in timerange\n    upcoming_events = ical.get_events(today, agenda_events[-1]['begin'],\n                                        self.timezone)\n\n    # Sort events by beginning time\n    ical.sort()\n    # parser.show_events()\n\n    # Set the width for date, time and event titles\n    date_strings = [date['begin'].format(self.date_format, locale=self.language) for date in agenda_events]\n    longest_date = max(date_strings, key=len)\n\n    date_width = canvas.get_text_width(longest_date)\n    logger.debug(f'date_width: {date_width}')\n\n    # Calculate positions for each line\n    line_pos = [(0, int(line * line_height)) for line in range(max_lines)]\n    logger.debug(f'line_pos: {line_pos}')\n\n    # Check if any events were filtered\n    if upcoming_events:\n        logger.info('Managed to parse events from urls')\n\n        # Find out how much space the event times take\n\n        time_width = int(max([self.font.getlength(\n            events['begin'].format(self.time_format, locale=self.language))\n            for events in upcoming_events]) + 10)\n        logger.debug(f'time_width: {time_width}')\n\n        # Calculate x-pos for time\n        x_time = int(date_width/3)\n        logger.debug(f'x-time: {x_time}')\n\n        # Find out how much space is left for event titles\n        event_width = im_width - time_width \n        logger.debug(f'width for events: {event_width}')\n\n        # Calculate x-pos for event titles\n        x_event = int(date_width/3) + time_width\n        logger.debug(f'x-event: {x_event}')\n\n        # Merge list of dates and list of events\n        agenda_events += upcoming_events\n\n        # Sort the combined list in chronological order of dates\n        by_date = lambda event: event['begin']\n        agenda_events.sort(key=by_date)\n\n        # Delete more entries than can be displayed (max lines)\n        del agenda_events[max_lines:]\n\n        cursor = 0\n        for _ in agenda_events:\n            title = _['title']\n\n            # Check if item is a date\n            if 'end' not in _:\n                ImageDraw.Draw(canvas.image_colour).line(\n                    (0, line_pos[cursor][1], im_width, line_pos[cursor][1]),\n                    fill='black')\n\n                canvas.write(\n                    xy=line_pos[cursor],\n                    box_size=(date_width, line_height),\n                    text=title,\n                    alignment=\"left\")\n\n                cursor += 1\n\n            # Check if item is an event\n            if 'end' in _:\n                time = _['begin'].format(self.time_format, locale=self.language)\n\n                # Check if event is all day, if not, add the time\n                if not ical.all_day(_):\n                    canvas.write(\n                        xy=(x_time, line_pos[cursor][1]),\n                        box_size=(time_width, line_height),\n                        text=time,\n                        alignment=\"right\")\n                else:\n                    canvas.set_font(font=self.icon_font, font_size=self.fontsize)\n\n                    canvas.write(\n                        xy=(x_time, line_pos[cursor][1]),\n                        box_size=(time_width, line_height),\n                        text=\"\\ue878\",\n                        alignment=\"right\")\n\n                canvas.set_font(font=self.font, font_size=self.fontsize)\n                canvas.write(\n                    xy=(x_event, line_pos[cursor][1]),\n                    box_size=(event_width, line_height),\n                    text=' \u2022 ' + title,\n                    alignment=\"left\")\n                cursor += 1\n\n    # If no events were found, write only dates and lines\n    else:\n        logger.info('no events found')\n\n        cursor = 0\n        for _ in agenda_events:\n            title = _['title']\n            ImageDraw.Draw(canvas.image_colour).line(\n                (0, line_pos[cursor][1], im_width, line_pos[cursor][1]),\n                fill='black')\n\n            canvas.write(\n                xy=line_pos[cursor],\n                box_size=(date_width, line_height),\n                text=title,\n                alignment=\"left\")\n            cursor += 1\n\n    # return the images ready for the display\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#todoist","title":"Todoist","text":"<p>Inkycal Todoist Module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_todoist.Todoist","title":"<code>Todoist</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Todoist api class parses todos from the todoist api.</p> Source code in <code>inkycal/modules/inkycal_todoist.py</code> <pre><code>class Todoist(InkycalModule):\n    \"\"\"Todoist api class\n    parses todos from the todoist api.\n    \"\"\"\n\n    name = \"Todoist API - show your todos from todoist\"\n\n    requires = {\n        'api_key': {\n            \"label\": \"Please enter your Todoist API-key\",\n        },\n    }\n\n    optional = {\n        'project_filter': {\n            \"label\": \"Show Todos only from following project (separated by a comma). Leave empty to show \" +\n                     \"todos from all projects\",\n        },\n        'show_priority': {\n            \"label\": \"Show priority indicators for tasks (P1, P2, P3)\",\n            \"default\": True\n        }\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_rss module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # Check if all required parameters are present\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # module specific parameters\n        self.api_key = config['api_key']\n\n        # if project filter is set, initialize it\n        if config['project_filter'] and isinstance(config['project_filter'], str):\n            self.project_filter = config['project_filter'].split(',')\n        else:\n            self.project_filter = config['project_filter']\n\n        # Priority display option\n        self.show_priority = config.get('show_priority', True)\n\n        self._api = TodoistAPI(config['api_key'])\n\n        # Cache file path for storing last successful response\n        self.cache_file = os.path.join(os.path.dirname(__file__), '..', '..', 'temp', 'todoist_cache.json')\n        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def _validate(self):\n        \"\"\"Validate module-specific parameters\"\"\"\n        if not isinstance(self.api_key, str):\n            print('api_key has to be a string: \"Yourtopsecretkey123\" ')\n\n\n    def _fetch_with_retry(\n            self,\n            fetch_func: Callable[[], Iterable[T]],\n            *,\n            max_retries: int = 3,\n            retry_statuses: set[int] = {502, 503, 504},\n    ) -&gt; list[T]:\n        \"\"\"\n        Fetch data with retry logic and exponential backoff.\n\n        Retries on:\n        - Connection errors\n        - HTTP errors with retryable status codes\n\n        Args:\n            fetch_func: Callable returning an iterable of results.\n            max_retries: Maximum number of attempts.\n            retry_statuses: HTTP status codes that should trigger a retry.\n\n        Returns:\n            A list of fetched items.\n\n        Raises:\n            requests.exceptions.RequestException\n            RuntimeError: If all retries are exhausted.\n        \"\"\"\n        for attempt in range(1, max_retries + 1):\n            try:\n                return list(fetch_func())\n\n            except requests.exceptions.HTTPError as exc:\n                status = exc.response.status_code if exc.response else None\n                if status not in retry_statuses or attempt == max_retries:\n                    raise\n\n            except requests.exceptions.ConnectionError:\n                if attempt == max_retries:\n                    raise\n\n            delay = 2 ** (attempt - 1)\n            logger.warning(\n                \"API request failed (attempt %d/%d), retrying in %ds...\",\n                attempt,\n                max_retries,\n                delay,\n            )\n            time.sleep(delay)\n\n        raise RuntimeError(\"Max retries exceeded\")\n\n    def _save_cache(self, projects, tasks):\n        \"\"\"Save API response to cache file\"\"\"\n        try:\n            cache_data = {\n                'timestamp': datetime.now().isoformat(),\n                'projects': [{'id': p.id, 'name': p.name} for p in projects],\n                'tasks': [{\n                    'content': t.content,\n                    'project_id': t.project_id,\n                    'priority': t.priority,\n                    'due': {'date': str(t.due.date)} if t.due else None\n                } for t in tasks]\n            }\n            with open(self.cache_file, 'w') as f:\n                json.dump(cache_data, f)\n            logger.debug(\"Saved Todoist data to cache\")\n        except Exception as e:\n            logger.warning(f\"Failed to save cache: {e}\")\n\n    def _load_cache(self):\n        \"\"\"Load cached API response\"\"\"\n        try:\n            if os.path.exists(self.cache_file):\n                with open(self.cache_file, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            logger.warning(f\"Failed to load cache: {e}\")\n        return None\n\n    def _create_error_image(self, im_size, error_msg=None, cached_data=None):\n        \"\"\"Create an error message image when API fails\"\"\"\n        im_width, im_height = im_size\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Display error message\n        line_spacing = 1\n        line_height = canvas.get_line_height() + line_spacing\n\n        messages = []\n        if error_msg:\n            messages.append(\"Todoist temporarily unavailable\")\n\n        if cached_data and 'timestamp' in cached_data:\n            timestamp = arrow.get(cached_data['timestamp']).format('D-MMM-YY HH:mm')\n            messages.append(f\"Showing cached data from:\")\n            messages.append(timestamp)\n        else:\n            messages.append(\"No cached data available\")\n            messages.append(\"Please check your connection\")\n\n        # Center the messages vertically\n        total_height = len(messages) * line_height\n        start_y = (im_height - total_height) // 2\n\n        for i, msg in enumerate(messages):\n            y_pos = start_y + (i * line_height)\n            # First line in red (colour image), rest in black\n            canvas.write(\n                xy= (0, y_pos),\n                box_size=(im_width, line_height),\n                text=msg,\n                colour=\"colour\" if i == 0 else \"black\"\n            )\n\n        return canvas.image_black, canvas.image_colour\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'Image size: {im_size}')\n\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Check if internet is available\n        if not internet_available():\n            logger.error(\"Network not reachable. Trying to use cached data.\")\n            cached_data = self._load_cache()\n            if cached_data:\n                # Process cached data below\n                all_projects = [type('Project', (), p) for p in cached_data['projects']]\n                all_active_tasks = [type('Task', (), {\n                    'content': t['content'],\n                    'project_id': t['project_id'],\n                    'priority': t['priority'],\n                    'due': type('Due', (), {'date': t['due']['date']}) if t['due'] else None\n                }) for t in cached_data['tasks']]\n            else:\n                return self._create_error_image(im_size, \"Network error\", None)\n        else:\n            logger.info('Connection test passed')\n\n            # Try to fetch fresh data from API\n            try:\n                all_projects = self._fetch_with_retry(self._api.get_projects)[0] or []\n                all_tasks_api = self._fetch_with_retry(self._api.get_tasks) or []\n                all_active_tasks = []\n                for task_list in all_tasks_api:\n                    all_active_tasks.extend(task_list)\n                 # Save to cache on successful fetch\n                self._save_cache(all_projects, all_active_tasks)\n            except Exception as e:\n                logger.error(f\"Failed to fetch Todoist data: {e}\")\n                # Try to use cached data\n                cached_data = self._load_cache()\n                if cached_data:\n                    logger.info(\"Using cached Todoist data\")\n                    all_projects = [type('Project', (), p) for p in cached_data['projects']]\n                    all_active_tasks = [type('Task', (), {\n                        'content': t['content'],\n                        'project_id': t['project_id'],\n                        'priority': t['priority'],\n                        'due': type('Due', (), {'date': t['due']['date']}) if t['due'] else None\n                    }) for t in cached_data['tasks']]\n                else:\n                    # No cached data available, show error\n                    return self._create_error_image(im_size, str(e), None)\n\n        # Set some parameters for formatting todos\n        line_spacing = 1\n        line_height = canvas.get_line_height() + line_spacing\n        max_lines = im_height // line_height\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        # Process the fetched or cached data\n        filtered_project_ids_and_names = {project.id: project.name for project in all_projects}\n\n        logger.debug(f\"all_projects: {all_projects}\")\n\n        # Filter entries in all_projects if filter was given\n        if self.project_filter:\n            filtered_projects = [project for project in all_projects if project.name in self.project_filter]\n            filtered_project_ids_and_names = {project.id: project.name for project in filtered_projects}\n            filtered_project_ids = [project for project in filtered_project_ids_and_names]\n            logger.debug(f\"filtered projects: {filtered_projects}\")\n\n            # If filter was activated and no project was found with that name,\n            # raise an exception to avoid showing a blank image\n            if not filtered_projects:\n                logger.error('No project found from project filter!')\n                logger.error('Please double check spellings in project_filter')\n                raise Exception('No matching project found in filter. Please '\n                                'double check spellings in project_filter or leave'\n                                'empty')\n            # filtered version of all active tasks\n            all_active_tasks = [task for task in all_active_tasks if task.project_id in filtered_project_ids]\n\n        # Simplify the tasks for faster processing\n        simplified = []\n        for task in all_active_tasks:\n            # Format priority indicator using circle symbols\n            priority_text = \"\"\n            if self.show_priority and task.priority &gt; 1:\n                # Todoist uses reversed priority (4 = highest, 1 = lowest)\n                if task.priority == 4:  # P1 - filled circle (red)\n                    priority_text = \"\u25cf \"  # Filled circle for highest priority\n                elif task.priority == 3:  # P2 - filled circle (black)\n                    priority_text = \"\u25cf \"  # Filled circle for high priority\n                elif task.priority == 2:  # P3 - empty circle (black)\n                    priority_text = \"\u25cb \"  # Empty circle for medium priority\n\n            # Check if task is overdue\n            # Parse date in local timezone to ensure correct comparison\n            try:\n                due_date = arrow.get(task.due.date, \"YYYY-MM-DD\").replace(tzinfo='local') if task.due else None\n            except Exception as e:\n                logger.warning(f\"Could not parse due date of task: {task} with due date: {task.due} reason: \", e)\n                continue\n            today = arrow.now('local').floor('day')\n            is_overdue = due_date and due_date &lt; today if due_date else False\n\n            # Format due date display\n            if due_date:\n                if due_date.floor('day') == today:\n                    due_display = \"TODAY\"\n                else:\n                    due_display = due_date.format(\"D-MMM-YY\")\n            else:\n                due_display = \"\"\n\n            simplified.append({\n                'name': task.content,\n                'due': due_display,\n                'due_date': due_date,\n                'is_overdue': is_overdue,\n                'priority': task.priority,\n                'priority_text': priority_text,\n                'project': filtered_project_ids_and_names[task.project_id] if task.project_id in filtered_project_ids_and_names else None\n            })\n\n        logger.debug(f'simplified: {simplified}')\n\n        project_lengths = []\n        due_lengths = []\n        priority_lengths = []\n\n        for task in simplified:\n            if task[\"project\"]:\n                project_lengths.append(int(canvas.get_text_width(task['project']) * 1.1))\n            if task[\"due\"]:\n                due_lengths.append(int(canvas.get_text_width(task['due']) * 1.1))\n            if task[\"priority_text\"]:\n                priority_lengths.append(int(canvas.get_text_width(task['priority_text']) * 1.1))\n\n        # Get maximum width of project names for selected font\n        project_offset = int(max(project_lengths)) if project_lengths else 0\n\n        # Get maximum width of project dues for selected font\n        due_offset = int(max(due_lengths)) if due_lengths else 0\n\n        # Get maximum width of priority indicators\n        priority_offset = int(max(priority_lengths)) if priority_lengths else 0\n\n        # create a dict with names of filtered groups\n        groups = {group_name:[] for group_name in filtered_project_ids_and_names.values()}\n        for task in simplified:\n            group_of_current_task = task[\"project\"]\n            if group_of_current_task in groups:\n                groups[group_of_current_task].append(task)\n\n        # Sort tasks within each project group by due date first, then priority\n        for project_name in groups:\n            groups[project_name].sort(\n                key=lambda task: (\n                    task['due_date'] is None,  # Tasks with dates come first\n                    task['due_date'] if task['due_date'] else arrow.get('9999-12-31'),  # Sort by date\n                    -task['priority']  # Then by priority (higher priority first)\n                )\n            )\n\n        logger.debug(f\"grouped: {groups}\")\n\n        # Add the parsed todos on the image\n        cursor = 0\n        for name, todos in groups.items():\n            if todos:\n                for todo in todos:\n                    if cursor &lt; max_lines:\n                        line_x, line_y = line_positions[cursor]\n\n                        if todo['project']:\n                            # Add todos project name\n                            canvas.write(\n                                xy=line_positions[cursor],\n                                box_size=(project_offset, line_height),\n                                text= todo['project'],\n                                colour=\"colour\",\n                                alignment='left'\n                            )\n\n                        # Add todos due if not empty\n                        if todo['due']:\n                            # Show overdue dates in red, normal dates in black\n                            canvas.write(\n                                xy=(line_x + project_offset, line_y),\n                                box_size=(due_offset, line_height),\n                                text= todo['due'],\n                                colour=\"colour\" if todo.get('is_overdue', False) else \"black\",\n                                alignment='left'\n                            )\n\n                        # Add priority indicator if present\n                        if todo['priority_text']:\n                            # P1 (priority 4) in red, P2 and P3 in black\n                            canvas.write(\n                                xy=(line_x + project_offset + due_offset, line_y),\n                                box_size=(priority_offset, line_height),\n                                text=todo['priority_text'],\n                                colour=\"colour\" if todo['priority'] == 4 else \"black\",\n                                alignment='left'\n                            )\n                        if todo['name']:\n                            # Add todos name\n                            canvas.write(\n                                xy=(line_x + project_offset + due_offset + priority_offset, line_y),\n                                box_size=(im_width - project_offset - due_offset - priority_offset, line_height),\n                                text=todo['name'],\n                                alignment='left'\n                            )\n                        cursor += 1\n                    else:\n                        logger.error('More todos than available lines')\n                        break\n\n        # return the images ready for the display\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_todoist.Todoist.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_rss module</p> Source code in <code>inkycal/modules/inkycal_todoist.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_rss module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # Check if all required parameters are present\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # module specific parameters\n    self.api_key = config['api_key']\n\n    # if project filter is set, initialize it\n    if config['project_filter'] and isinstance(config['project_filter'], str):\n        self.project_filter = config['project_filter'].split(',')\n    else:\n        self.project_filter = config['project_filter']\n\n    # Priority display option\n    self.show_priority = config.get('show_priority', True)\n\n    self._api = TodoistAPI(config['api_key'])\n\n    # Cache file path for storing last successful response\n    self.cache_file = os.path.join(os.path.dirname(__file__), '..', '..', 'temp', 'todoist_cache.json')\n    os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_todoist.Todoist.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_todoist.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'Image size: {im_size}')\n\n    canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n    # Check if internet is available\n    if not internet_available():\n        logger.error(\"Network not reachable. Trying to use cached data.\")\n        cached_data = self._load_cache()\n        if cached_data:\n            # Process cached data below\n            all_projects = [type('Project', (), p) for p in cached_data['projects']]\n            all_active_tasks = [type('Task', (), {\n                'content': t['content'],\n                'project_id': t['project_id'],\n                'priority': t['priority'],\n                'due': type('Due', (), {'date': t['due']['date']}) if t['due'] else None\n            }) for t in cached_data['tasks']]\n        else:\n            return self._create_error_image(im_size, \"Network error\", None)\n    else:\n        logger.info('Connection test passed')\n\n        # Try to fetch fresh data from API\n        try:\n            all_projects = self._fetch_with_retry(self._api.get_projects)[0] or []\n            all_tasks_api = self._fetch_with_retry(self._api.get_tasks) or []\n            all_active_tasks = []\n            for task_list in all_tasks_api:\n                all_active_tasks.extend(task_list)\n             # Save to cache on successful fetch\n            self._save_cache(all_projects, all_active_tasks)\n        except Exception as e:\n            logger.error(f\"Failed to fetch Todoist data: {e}\")\n            # Try to use cached data\n            cached_data = self._load_cache()\n            if cached_data:\n                logger.info(\"Using cached Todoist data\")\n                all_projects = [type('Project', (), p) for p in cached_data['projects']]\n                all_active_tasks = [type('Task', (), {\n                    'content': t['content'],\n                    'project_id': t['project_id'],\n                    'priority': t['priority'],\n                    'due': type('Due', (), {'date': t['due']['date']}) if t['due'] else None\n                }) for t in cached_data['tasks']]\n            else:\n                # No cached data available, show error\n                return self._create_error_image(im_size, str(e), None)\n\n    # Set some parameters for formatting todos\n    line_spacing = 1\n    line_height = canvas.get_line_height() + line_spacing\n    max_lines = im_height // line_height\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    # Process the fetched or cached data\n    filtered_project_ids_and_names = {project.id: project.name for project in all_projects}\n\n    logger.debug(f\"all_projects: {all_projects}\")\n\n    # Filter entries in all_projects if filter was given\n    if self.project_filter:\n        filtered_projects = [project for project in all_projects if project.name in self.project_filter]\n        filtered_project_ids_and_names = {project.id: project.name for project in filtered_projects}\n        filtered_project_ids = [project for project in filtered_project_ids_and_names]\n        logger.debug(f\"filtered projects: {filtered_projects}\")\n\n        # If filter was activated and no project was found with that name,\n        # raise an exception to avoid showing a blank image\n        if not filtered_projects:\n            logger.error('No project found from project filter!')\n            logger.error('Please double check spellings in project_filter')\n            raise Exception('No matching project found in filter. Please '\n                            'double check spellings in project_filter or leave'\n                            'empty')\n        # filtered version of all active tasks\n        all_active_tasks = [task for task in all_active_tasks if task.project_id in filtered_project_ids]\n\n    # Simplify the tasks for faster processing\n    simplified = []\n    for task in all_active_tasks:\n        # Format priority indicator using circle symbols\n        priority_text = \"\"\n        if self.show_priority and task.priority &gt; 1:\n            # Todoist uses reversed priority (4 = highest, 1 = lowest)\n            if task.priority == 4:  # P1 - filled circle (red)\n                priority_text = \"\u25cf \"  # Filled circle for highest priority\n            elif task.priority == 3:  # P2 - filled circle (black)\n                priority_text = \"\u25cf \"  # Filled circle for high priority\n            elif task.priority == 2:  # P3 - empty circle (black)\n                priority_text = \"\u25cb \"  # Empty circle for medium priority\n\n        # Check if task is overdue\n        # Parse date in local timezone to ensure correct comparison\n        try:\n            due_date = arrow.get(task.due.date, \"YYYY-MM-DD\").replace(tzinfo='local') if task.due else None\n        except Exception as e:\n            logger.warning(f\"Could not parse due date of task: {task} with due date: {task.due} reason: \", e)\n            continue\n        today = arrow.now('local').floor('day')\n        is_overdue = due_date and due_date &lt; today if due_date else False\n\n        # Format due date display\n        if due_date:\n            if due_date.floor('day') == today:\n                due_display = \"TODAY\"\n            else:\n                due_display = due_date.format(\"D-MMM-YY\")\n        else:\n            due_display = \"\"\n\n        simplified.append({\n            'name': task.content,\n            'due': due_display,\n            'due_date': due_date,\n            'is_overdue': is_overdue,\n            'priority': task.priority,\n            'priority_text': priority_text,\n            'project': filtered_project_ids_and_names[task.project_id] if task.project_id in filtered_project_ids_and_names else None\n        })\n\n    logger.debug(f'simplified: {simplified}')\n\n    project_lengths = []\n    due_lengths = []\n    priority_lengths = []\n\n    for task in simplified:\n        if task[\"project\"]:\n            project_lengths.append(int(canvas.get_text_width(task['project']) * 1.1))\n        if task[\"due\"]:\n            due_lengths.append(int(canvas.get_text_width(task['due']) * 1.1))\n        if task[\"priority_text\"]:\n            priority_lengths.append(int(canvas.get_text_width(task['priority_text']) * 1.1))\n\n    # Get maximum width of project names for selected font\n    project_offset = int(max(project_lengths)) if project_lengths else 0\n\n    # Get maximum width of project dues for selected font\n    due_offset = int(max(due_lengths)) if due_lengths else 0\n\n    # Get maximum width of priority indicators\n    priority_offset = int(max(priority_lengths)) if priority_lengths else 0\n\n    # create a dict with names of filtered groups\n    groups = {group_name:[] for group_name in filtered_project_ids_and_names.values()}\n    for task in simplified:\n        group_of_current_task = task[\"project\"]\n        if group_of_current_task in groups:\n            groups[group_of_current_task].append(task)\n\n    # Sort tasks within each project group by due date first, then priority\n    for project_name in groups:\n        groups[project_name].sort(\n            key=lambda task: (\n                task['due_date'] is None,  # Tasks with dates come first\n                task['due_date'] if task['due_date'] else arrow.get('9999-12-31'),  # Sort by date\n                -task['priority']  # Then by priority (higher priority first)\n            )\n        )\n\n    logger.debug(f\"grouped: {groups}\")\n\n    # Add the parsed todos on the image\n    cursor = 0\n    for name, todos in groups.items():\n        if todos:\n            for todo in todos:\n                if cursor &lt; max_lines:\n                    line_x, line_y = line_positions[cursor]\n\n                    if todo['project']:\n                        # Add todos project name\n                        canvas.write(\n                            xy=line_positions[cursor],\n                            box_size=(project_offset, line_height),\n                            text= todo['project'],\n                            colour=\"colour\",\n                            alignment='left'\n                        )\n\n                    # Add todos due if not empty\n                    if todo['due']:\n                        # Show overdue dates in red, normal dates in black\n                        canvas.write(\n                            xy=(line_x + project_offset, line_y),\n                            box_size=(due_offset, line_height),\n                            text= todo['due'],\n                            colour=\"colour\" if todo.get('is_overdue', False) else \"black\",\n                            alignment='left'\n                        )\n\n                    # Add priority indicator if present\n                    if todo['priority_text']:\n                        # P1 (priority 4) in red, P2 and P3 in black\n                        canvas.write(\n                            xy=(line_x + project_offset + due_offset, line_y),\n                            box_size=(priority_offset, line_height),\n                            text=todo['priority_text'],\n                            colour=\"colour\" if todo['priority'] == 4 else \"black\",\n                            alignment='left'\n                        )\n                    if todo['name']:\n                        # Add todos name\n                        canvas.write(\n                            xy=(line_x + project_offset + due_offset + priority_offset, line_y),\n                            box_size=(im_width - project_offset - due_offset - priority_offset, line_height),\n                            text=todo['name'],\n                            alignment='left'\n                        )\n                    cursor += 1\n                else:\n                    logger.error('More todos than available lines')\n                    break\n\n    # return the images ready for the display\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#webshot","title":"Webshot","text":"<p>Webshot module for Inkycal by https://github.com/worstface</p>"},{"location":"reference/#inkycal.modules.inkycal_webshot.Webshot","title":"<code>Webshot</code>","text":"<p>               Bases: <code>InkycalModule</code></p> Source code in <code>inkycal/modules/inkycal_webshot.py</code> <pre><code>class Webshot(InkycalModule):\n    name = \"Webshot - Displays screenshots of webpages\"\n\n    # required parameters\n    requires = {\n\n        \"url\": {\n            \"label\": \"Please enter the url\",\n        },\n        \"palette\": {\n            \"label\": \"Which color palette should be used for the webshots?\",\n            \"options\": [\"bw\", \"bwr\", \"bwy\"]\n        }\n    }\n\n    optional = {\n\n        \"crop_x\": {\n            \"label\": \"Please enter the crop x-position\",\n        },\n        \"crop_y\": {\n            \"label\": \"Please enter the crop y-position\",\n        },\n        \"crop_w\": {\n            \"label\": \"Please enter the crop width\",\n        },\n        \"crop_h\": {\n            \"label\": \"Please enter the crop height\",\n        },\n        \"rotation\": {\n            \"label\": \"Please enter the rotation. Must be either 0, 90, 180 or 270\",\n        },\n    }\n\n    def __init__(self, config):\n\n        super().__init__(config)\n\n        config = config['config']\n\n        self.url = config['url']\n        self.palette = config['palette']\n\n        if \"crop_h\" in config and isinstance(config[\"crop_h\"], str):\n            self.crop_h = int(config[\"crop_h\"])\n        else:\n            self.crop_h = 2000\n\n        if \"crop_w\" in config and isinstance(config[\"crop_w\"], str):\n            self.crop_w = int(config[\"crop_w\"])\n        else:\n            self.crop_w = 2000\n\n        if \"crop_x\" in config and isinstance(config[\"crop_x\"], str):\n            self.crop_x = int(config[\"crop_x\"])\n        else:\n            self.crop_x = 0\n\n        if \"crop_y\" in config and isinstance(config[\"crop_y\"], str):\n            self.crop_y = int(config[\"crop_y\"])\n        else:\n            self.crop_y = 0\n\n        self.rotation = 0\n        if \"rotation\" in config:\n            self.rotation = int(config[\"rotation\"])\n            if self.rotation not in [0, 90, 180, 270]:\n                raise Exception(\"Rotation must be either 0, 90, 180 or 270\")\n\n        # give an OK message\n        logger.debug(f'Inkycal webshot loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Create tmp path\n        tmpFolder = settings.TEMPORARY_FOLDER\n\n        if not os.path.exists(tmpFolder):\n            print(f\"Creating tmp directory {tmpFolder}\")\n            os.mkdir(tmpFolder)\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        if self.rotation in (90, 270):\n            im_width, im_height = im_height, im_width\n        im_size = im_width, im_height\n        logger.debug('image size: {} x {} px'.format(im_width, im_height))\n\n        # Create an image for black pixels and one for coloured pixels (required)\n        im_black = Image.new('RGB', size=im_size, color='white')\n        im_colour = Image.new('RGB', size=im_size, color='white')\n\n        # Check if internet is available\n        if internet_available():\n            logger.info('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise Exception('Network could not be reached :/')\n\n        logger.info(\n            f'preparing webshot from {self.url}... cropH{self.crop_h} cropW{self.crop_w} cropX{self.crop_x} cropY{self.crop_y}')\n\n        shot = WebShot(size=(im_height, im_width))\n\n        shot.params = {\n            \"--crop-x\": self.crop_x,\n            \"--crop-y\": self.crop_y,\n            \"--crop-w\": self.crop_w,\n            \"--crop-h\": self.crop_h,\n        }\n\n        logger.info(f'getting webshot from {self.url}...')\n\n        try:\n            shot.create_pic(url=self.url, output=f\"{tmpFolder}/webshot.png\")\n        except:\n            print(traceback.format_exc())\n            print(\"If you have not already installed wkhtmltopdf, please use: sudo apt-get install wkhtmltopdf. See here for more details: https://github.com/1Danish-00/htmlwebshot/\")\n            raise Exception('Could not get webshot :/')\n\n\n        logger.info(f'got webshot...')\n\n        webshotSpaceBlack = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n        webshotSpaceColour = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n\n        im = Images()\n        im.load(f'{tmpFolder}/webshot.png')\n        im.remove_alpha()\n\n        imageAspectRatio = im_width / im_height\n        webshotAspectRatio = im.image.width / im.image.height\n\n        if webshotAspectRatio &gt; imageAspectRatio:\n            imageScale = im_width / im.image.width\n        else:\n            imageScale = im_height / im.image.height\n\n        webshotHeight = int(im.image.height * imageScale)\n\n        im.resize(width=int(im.image.width * imageScale), height=webshotHeight)\n\n        im_webshot_black, im_webshot_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n        webshotCenterPosY = int((im_height / 2) - (im.image.height / 2))\n\n        centerPosX = int((im_width / 2) - (im.image.width / 2))\n\n\n        if self.rotation != 0:\n            webshotSpaceBlack.paste(im_webshot_black, (centerPosX, webshotCenterPosY))\n            im_black.paste(webshotSpaceBlack)\n            im_black = im_black.rotate(self.rotation, expand=True)\n\n            webshotSpaceColour.paste(im_webshot_colour, (centerPosX, webshotCenterPosY))\n            im_colour.paste(webshotSpaceColour)\n            im_colour = im_colour.rotate(self.rotation, expand=True)\n        else:\n            webshotSpaceBlack.paste(im_webshot_black, (centerPosX, webshotCenterPosY))\n            im_black.paste(webshotSpaceBlack)\n\n            webshotSpaceColour.paste(im_webshot_colour, (centerPosX, webshotCenterPosY))\n            im_colour.paste(webshotSpaceColour)\n\n        im.clear()\n        logger.info(f'added webshot image')\n\n        # Save image of black and colour channel in image-folder\n        return im_black, im_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_webshot.Webshot.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_webshot.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Create tmp path\n    tmpFolder = settings.TEMPORARY_FOLDER\n\n    if not os.path.exists(tmpFolder):\n        print(f\"Creating tmp directory {tmpFolder}\")\n        os.mkdir(tmpFolder)\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    if self.rotation in (90, 270):\n        im_width, im_height = im_height, im_width\n    im_size = im_width, im_height\n    logger.debug('image size: {} x {} px'.format(im_width, im_height))\n\n    # Create an image for black pixels and one for coloured pixels (required)\n    im_black = Image.new('RGB', size=im_size, color='white')\n    im_colour = Image.new('RGB', size=im_size, color='white')\n\n    # Check if internet is available\n    if internet_available():\n        logger.info('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise Exception('Network could not be reached :/')\n\n    logger.info(\n        f'preparing webshot from {self.url}... cropH{self.crop_h} cropW{self.crop_w} cropX{self.crop_x} cropY{self.crop_y}')\n\n    shot = WebShot(size=(im_height, im_width))\n\n    shot.params = {\n        \"--crop-x\": self.crop_x,\n        \"--crop-y\": self.crop_y,\n        \"--crop-w\": self.crop_w,\n        \"--crop-h\": self.crop_h,\n    }\n\n    logger.info(f'getting webshot from {self.url}...')\n\n    try:\n        shot.create_pic(url=self.url, output=f\"{tmpFolder}/webshot.png\")\n    except:\n        print(traceback.format_exc())\n        print(\"If you have not already installed wkhtmltopdf, please use: sudo apt-get install wkhtmltopdf. See here for more details: https://github.com/1Danish-00/htmlwebshot/\")\n        raise Exception('Could not get webshot :/')\n\n\n    logger.info(f'got webshot...')\n\n    webshotSpaceBlack = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n    webshotSpaceColour = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n\n    im = Images()\n    im.load(f'{tmpFolder}/webshot.png')\n    im.remove_alpha()\n\n    imageAspectRatio = im_width / im_height\n    webshotAspectRatio = im.image.width / im.image.height\n\n    if webshotAspectRatio &gt; imageAspectRatio:\n        imageScale = im_width / im.image.width\n    else:\n        imageScale = im_height / im.image.height\n\n    webshotHeight = int(im.image.height * imageScale)\n\n    im.resize(width=int(im.image.width * imageScale), height=webshotHeight)\n\n    im_webshot_black, im_webshot_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n    webshotCenterPosY = int((im_height / 2) - (im.image.height / 2))\n\n    centerPosX = int((im_width / 2) - (im.image.width / 2))\n\n\n    if self.rotation != 0:\n        webshotSpaceBlack.paste(im_webshot_black, (centerPosX, webshotCenterPosY))\n        im_black.paste(webshotSpaceBlack)\n        im_black = im_black.rotate(self.rotation, expand=True)\n\n        webshotSpaceColour.paste(im_webshot_colour, (centerPosX, webshotCenterPosY))\n        im_colour.paste(webshotSpaceColour)\n        im_colour = im_colour.rotate(self.rotation, expand=True)\n    else:\n        webshotSpaceBlack.paste(im_webshot_black, (centerPosX, webshotCenterPosY))\n        im_black.paste(webshotSpaceBlack)\n\n        webshotSpaceColour.paste(im_webshot_colour, (centerPosX, webshotCenterPosY))\n        im_colour.paste(webshotSpaceColour)\n\n    im.clear()\n    logger.info(f'added webshot image')\n\n    # Save image of black and colour channel in image-folder\n    return im_black, im_colour\n</code></pre>"},{"location":"reference/#slideshow","title":"Slideshow","text":"<p>Inkycal Slideshow Module Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_slideshow.Slideshow","title":"<code>Slideshow</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Cycles through images in a local image folder</p> Source code in <code>inkycal/modules/inkycal_slideshow.py</code> <pre><code>class Slideshow(InkycalModule):\n    \"\"\"Cycles through images in a local image folder\"\"\"\n    name = \"Slideshow - cycle through images from a local folder\"\n\n    requires = {\n\n        \"path\": {\n            \"label\": \"Path to a local folder, e.g. /home/pi/Desktop/images. \"\n                     \"Only PNG and JPG/JPEG images are used for the slideshow.\"\n        },\n\n        \"palette\": {\n            \"label\": \"Which palette should be used for converting images?\",\n            \"options\": [\"bw\", \"bwr\", \"bwy\"]\n        }\n\n    }\n\n    optional = {\n\n        \"autoflip\": {\n            \"label\": \"Should the image be flipped automatically? Default is False\",\n            \"options\": [False, True]\n        },\n\n        \"orientation\": {\n            \"label\": \"Please select the desired orientation\",\n            \"options\": [\"vertical\", \"horizontal\"]\n        }\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # required parameters\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # optional parameters\n        self.path = config['path']\n        self.palette = config['palette']\n        self.autoflip = config['autoflip']\n        self.orientation = config['orientation']\n\n        # Get the full path of all png/jpg/jpeg images in the given folder\n        all_files = glob.glob(f'{self.path}/*')\n        self.images = [i for i in all_files if i.split('.')[-1].lower() in ('jpg', 'jpeg', 'png')]\n\n        if not self.images:\n            logger.error('No images found in the given folder, please double check your path!')\n            raise Exception('No images found in the given folder path :/')\n\n        self.cache = JSONCache('inkycal_slideshow')\n        self.cache_data = self.cache.read()\n\n        # set a 'first run' signal\n        self._first_run = True\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n\n        logger.debug(f'Image size: {im_size}')\n\n        # rotates list items by 1 index\n        def rotate(list: list):\n            return list[1:] + list[:1]\n\n        # Switch to the next image if this is not the first run\n        if self._first_run:\n            self._first_run = False\n            self.cache_data[\"current_index\"] = 0\n        else:\n            self.images = rotate(self.images)\n            self.cache_data[\"current_index\"] = (self.cache_data[\"current_index\"] + 1) % len(self.images)\n\n        # initialize custom image class\n        im = Images()\n\n        # temporary print method, prints current filename\n        print(f'slideshow - current image name: {self.images[0].split(\"/\")[-1]}')\n\n        # use the image at the first index\n        im.load(self.images[0])\n\n        # Remove background if present\n        im.remove_alpha()\n\n        # if auto-flip was enabled, flip the image\n        if self.autoflip:\n            im.autoflip(self.orientation)\n\n        # resize the image so it can fit on the epaper\n        im.resize(width=im_width, height=im_height)\n\n        # convert images according to specified palette\n        im_black, im_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n        # with the images now send, clear the current image\n        im.clear()\n\n        self.cache.write(self.cache_data)\n\n        # return images\n        return im_black, im_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_slideshow.Slideshow.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize module</p> Source code in <code>inkycal/modules/inkycal_slideshow.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # required parameters\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # optional parameters\n    self.path = config['path']\n    self.palette = config['palette']\n    self.autoflip = config['autoflip']\n    self.orientation = config['orientation']\n\n    # Get the full path of all png/jpg/jpeg images in the given folder\n    all_files = glob.glob(f'{self.path}/*')\n    self.images = [i for i in all_files if i.split('.')[-1].lower() in ('jpg', 'jpeg', 'png')]\n\n    if not self.images:\n        logger.error('No images found in the given folder, please double check your path!')\n        raise Exception('No images found in the given folder path :/')\n\n    self.cache = JSONCache('inkycal_slideshow')\n    self.cache_data = self.cache.read()\n\n    # set a 'first run' signal\n    self._first_run = True\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_slideshow.Slideshow.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_slideshow.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n\n    logger.debug(f'Image size: {im_size}')\n\n    # rotates list items by 1 index\n    def rotate(list: list):\n        return list[1:] + list[:1]\n\n    # Switch to the next image if this is not the first run\n    if self._first_run:\n        self._first_run = False\n        self.cache_data[\"current_index\"] = 0\n    else:\n        self.images = rotate(self.images)\n        self.cache_data[\"current_index\"] = (self.cache_data[\"current_index\"] + 1) % len(self.images)\n\n    # initialize custom image class\n    im = Images()\n\n    # temporary print method, prints current filename\n    print(f'slideshow - current image name: {self.images[0].split(\"/\")[-1]}')\n\n    # use the image at the first index\n    im.load(self.images[0])\n\n    # Remove background if present\n    im.remove_alpha()\n\n    # if auto-flip was enabled, flip the image\n    if self.autoflip:\n        im.autoflip(self.orientation)\n\n    # resize the image so it can fit on the epaper\n    im.resize(width=im_width, height=im_height)\n\n    # convert images according to specified palette\n    im_black, im_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n    # with the images now send, clear the current image\n    im.clear()\n\n    self.cache.write(self.cache_data)\n\n    # return images\n    return im_black, im_colour\n</code></pre>"},{"location":"reference/#server-module","title":"Server Module","text":"<p>Inkycal-server module for Inkycal Project by Aterju (https://inkycal.robertsirre.nl/) Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_server.Inkyserver","title":"<code>Inkyserver</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Displays an image from URL or local path</p> Source code in <code>inkycal/modules/inkycal_server.py</code> <pre><code>class Inkyserver(InkycalModule):\n    \"\"\"Displays an image from URL or local path\n    \"\"\"\n\n    name = \"Inykcal Server - fetches an image from Inkycal-server - (https://inkycal.robertsirre.nl/)\"\n\n    requires = {\n\n        \"path\": {\n            \"label\": \"Which URL should be used to get the image?\"\n        },\n\n        \"palette\": {\n            \"label\": \"Which palette should be used to convert the images?\",\n            \"options\": ['bw', 'bwr', 'bwy']\n        }\n\n    }\n\n    optional = {\n\n        \"path_body\": {\n            \"label\": \"Send this data to the server via POST. Use a comma to \"\n                     \"separate multiple items\",\n        },\n        \"dither\": {\n            \"label\": \"Dither images before sending to E-Paper? Default is False.\",\n            \"options\": [False, True],\n        }\n\n    }\n\n    def __init__(self, config):\n        \"\"\"Initialize module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # required parameters\n        for param in self.requires:\n            if param not in config:\n                raise Exception(f'config is missing {param}')\n\n        # optional parameters\n        self.path = config['path']\n        self.palette = config['palette']\n        self.dither = config['dither']\n\n        # convert path_body to list, if not already\n        if config['path_body'] and isinstance(config['path_body'], str):\n            self.path_body = config['path_body'].split(',')\n        else:\n            self.path_body = config['path_body']\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n\n        logger.info(f'Image size: {im_size}')\n\n        # replace width and height of url\n        print(self.path)\n        self.path = self.path.format(width=im_width, height=im_height)\n        print(f\"modified path: {self.path}\")\n\n        # initialize custom image class\n        im = Images()\n\n        # when no path_body is provided, use plain GET\n        if not self.path_body:\n\n            # use the image at the first index\n            im.load(self.path)\n\n        # else use POST request\n        else:\n            # Get the response image\n            response = Image.open(requests.post(\n                self.path, json=self.path_body, stream=True).raw)\n\n            # initialize custom image class with response\n            im = Images(response)\n\n        # resize the image to respect padding\n        im.resize(width=im_width, height=im_height)\n\n        # convert image to given palette\n        im_black, im_colour = im.to_palette(self.palette, dither=self.dither)\n\n        # with the images now send, clear the current image\n        im.clear()\n\n        # return images\n        return im_black, im_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_server.Inkyserver.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize module</p> Source code in <code>inkycal/modules/inkycal_server.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # required parameters\n    for param in self.requires:\n        if param not in config:\n            raise Exception(f'config is missing {param}')\n\n    # optional parameters\n    self.path = config['path']\n    self.palette = config['palette']\n    self.dither = config['dither']\n\n    # convert path_body to list, if not already\n    if config['path_body'] and isinstance(config['path_body'], str):\n        self.path_body = config['path_body'].split(',')\n    else:\n        self.path_body = config['path_body']\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_server.Inkyserver.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_server.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n\n    logger.info(f'Image size: {im_size}')\n\n    # replace width and height of url\n    print(self.path)\n    self.path = self.path.format(width=im_width, height=im_height)\n    print(f\"modified path: {self.path}\")\n\n    # initialize custom image class\n    im = Images()\n\n    # when no path_body is provided, use plain GET\n    if not self.path_body:\n\n        # use the image at the first index\n        im.load(self.path)\n\n    # else use POST request\n    else:\n        # Get the response image\n        response = Image.open(requests.post(\n            self.path, json=self.path_body, stream=True).raw)\n\n        # initialize custom image class with response\n        im = Images(response)\n\n    # resize the image to respect padding\n    im.resize(width=im_width, height=im_height)\n\n    # convert image to given palette\n    im_black, im_colour = im.to_palette(self.palette, dither=self.dither)\n\n    # with the images now send, clear the current image\n    im.clear()\n\n    # return images\n    return im_black, im_colour\n</code></pre>"},{"location":"reference/#xkcd","title":"XKCD","text":"<p>Inkycal XKCD module by https://github.com/worstface</p>"},{"location":"reference/#inkycal.modules.inkycal_xkcd.Xkcd","title":"<code>Xkcd</code>","text":"<p>               Bases: <code>InkycalModule</code></p> Source code in <code>inkycal/modules/inkycal_xkcd.py</code> <pre><code>class Xkcd(InkycalModule):\n    name = \"xkcd - Displays comics from xkcd.com by Randall Munroe\"\n\n    # required parameters\n    requires = {\n\n        \"mode\": {\n            \"label\": \"Please select the mode\",\n            \"options\": [\"latest\", \"random\"],\n            \"default\": \"latest\"\n        },\n        \"palette\": {\n            \"label\": \"Which color palette should be used for the comic Image2?\",\n            \"options\": [\"bw\", \"bwr\", \"bwy\"]\n        },\n        \"alt\": {\n            \"label\": \"Would you like to add the alt text below the comic? If XKCD is not the only module you are showing, I recommend setting this to 'no'\",\n            \"options\": [\"yes\", \"no\"],\n            \"default\": \"no\"\n        },\n        \"filter\": {\n            \"label\": \"Would you like to add a scaling filter? If the is far too big to be shown in the space you've allotted for it, the module will try to find another image for you. This only applies in random mode. If XKCD is not the only module you are showing, I recommend setting this to 'no'.\",\n            \"options\": [\"yes\", \"no\"],\n            \"default\": \"no\"\n        }\n    }\n\n    def __init__(self, config):\n\n        super().__init__(config)\n\n        config = config['config']\n\n        self.mode = config['mode']\n        self.palette = config['palette']\n        self.alt = config['alt']\n        self.scale_filter = config['filter']\n\n        # give an OK message\n        logger.debug(f'Inkycal XKCD loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Create tmp path\n        tmpPath = settings.TEMPORARY_FOLDER\n\n        if not os.path.exists(tmpPath):\n            os.mkdir(tmpPath)\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'image size: {im_width} x {im_height} px')\n\n        canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n        # Check if internet is available\n        if internet_available():\n            logger.info('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise Exception('Network could not be reached :/')\n\n        # Set some parameters for formatting feeds\n        line_spacing = 1\n        line_height = canvas.get_line_height() + line_spacing\n        line_width = im_width\n        max_lines = im_height // (line_height + line_spacing)\n\n        logger.debug(f\"max_lines: {max_lines}\")\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [(0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        logger.debug(f'line positions: {line_positions}')\n\n        logger.info(f'getting xkcd comic...')\n\n        if self.mode == 'random':\n            if self.scale_filter == 'no':\n                xkcdComic = xkcd.getRandomComic()\n                xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n            else:\n                perc = (2.1, 0.4)\n                url = \"test variable, not a real comic\"\n                while max(perc) &gt; 1.75:\n                    print(\"looking for another comic, old comic was: \", perc, url)\n                    xkcdComic = xkcd.getRandomComic()\n                    xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n                    actual_size = Image.open(tmpPath + '/xkcdComic.png').size\n                    perc = (actual_size[0] / im_width, actual_size[1] / im_height)\n                    url = xkcdComic.getImageLink()\n                print(\"found one! perc: \", perc, url)\n        else:\n            xkcdComic = xkcd.getLatestComic()\n            xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n\n        logger.info(f'got xkcd comic...')\n        title_lines = []\n        title_lines.append(xkcdComic.getTitle())\n\n        altOffset = int(line_height * 1)\n\n        if self.alt == \"yes\":\n            alt_text = xkcdComic.getAltText()  # get the alt text, too (I break it up into multiple lines later on)\n\n            # break up the alt text into lines\n            alt_lines = []\n            current_line = \"\"\n            for _ in alt_text.split(\" \"):\n                # this breaks up the alt_text into words and creates each line by adding\n                # one word at a time until the line is longer than the width of the module\n                # then it appends the line to the alt_lines array and starts testing a new line\n                # with the next word\n                if canvas.get_text_width(current_line + _ + \" \") &lt; im_width:\n                    current_line = current_line + _ + \" \"\n                else:\n                    alt_lines.append(current_line)\n                    current_line = _ + \" \"\n            alt_lines.append(\n                current_line)  # this adds the last line to the array (or the only line, if the alt text is really short)\n            altHeight = int(line_height * len(alt_lines)) + altOffset\n        else:\n            altHeight = 0  # this is added so that I don't need to add more \"if alt is yes\" conditionals when centering below. Now the centering code will work regardless of whether they want alttext or not\n\n        comicSpaceBlack = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n        comicSpaceColour = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n\n        im = Image2()\n        im.load(f\"{tmpPath}/xkcdComic.png\")\n        im.remove_alpha()\n\n        imageAspectRatio = im_width / im_height\n        comicAspectRatio = im.image.width / im.image.height\n\n        if comicAspectRatio &gt; imageAspectRatio:\n            imageScale = im_width / im.image.width\n        else:\n            imageScale = im_height / im.image.height\n\n        comicHeight = int(im.image.height * imageScale)\n\n        headerHeight = int(line_height * 3 / 2)\n\n        if comicHeight + (headerHeight + altHeight) &gt; im_height:\n            comicHeight -= (headerHeight + altHeight)\n\n        im.resize(width=int(im.image.width * imageScale), height=comicHeight)\n\n        im_comic_black, im_comic_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n        headerCenterPosY = int((im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2))\n        comicCenterPosY = int((im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2) + headerHeight)\n        altCenterPosY = int(\n            (im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2) + headerHeight + im.image.height)\n\n        centerPosX = int((im_width / 2) - (im.image.width / 2))\n\n        comicSpaceBlack.paste(im_comic_black, (centerPosX, comicCenterPosY))\n        canvas.image_black.paste(comicSpaceBlack)\n\n        comicSpaceColour.paste(im_comic_colour, (centerPosX, comicCenterPosY))\n        canvas.image_colour.paste(comicSpaceColour)\n\n        im.clear()\n        logger.info(f'added comic image')\n\n        # Write the title on the black image\n        canvas.write(\n            xy=(0, headerCenterPosY),\n            box_size=(line_width, line_height),\n            text=title_lines[0]\n        )\n\n        if self.alt == \"yes\":\n            # write alt_text\n            for _ in range(len(alt_lines)):\n                canvas.write(\n                    xy=(0, altCenterPosY + _ * line_height + altOffset),\n                    box_size=(line_width, line_height),\n                    text=alt_lines[_],\n                    alignment='left'\n                )\n        # Save image of black and colour channel in image-folder\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_xkcd.Xkcd.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_xkcd.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Create tmp path\n    tmpPath = settings.TEMPORARY_FOLDER\n\n    if not os.path.exists(tmpPath):\n        os.mkdir(tmpPath)\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'image size: {im_width} x {im_height} px')\n\n    canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n    # Check if internet is available\n    if internet_available():\n        logger.info('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise Exception('Network could not be reached :/')\n\n    # Set some parameters for formatting feeds\n    line_spacing = 1\n    line_height = canvas.get_line_height() + line_spacing\n    line_width = im_width\n    max_lines = im_height // (line_height + line_spacing)\n\n    logger.debug(f\"max_lines: {max_lines}\")\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [(0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    logger.debug(f'line positions: {line_positions}')\n\n    logger.info(f'getting xkcd comic...')\n\n    if self.mode == 'random':\n        if self.scale_filter == 'no':\n            xkcdComic = xkcd.getRandomComic()\n            xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n        else:\n            perc = (2.1, 0.4)\n            url = \"test variable, not a real comic\"\n            while max(perc) &gt; 1.75:\n                print(\"looking for another comic, old comic was: \", perc, url)\n                xkcdComic = xkcd.getRandomComic()\n                xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n                actual_size = Image.open(tmpPath + '/xkcdComic.png').size\n                perc = (actual_size[0] / im_width, actual_size[1] / im_height)\n                url = xkcdComic.getImageLink()\n            print(\"found one! perc: \", perc, url)\n    else:\n        xkcdComic = xkcd.getLatestComic()\n        xkcdComic.download(output=tmpPath, outputFile='xkcdComic.png')\n\n    logger.info(f'got xkcd comic...')\n    title_lines = []\n    title_lines.append(xkcdComic.getTitle())\n\n    altOffset = int(line_height * 1)\n\n    if self.alt == \"yes\":\n        alt_text = xkcdComic.getAltText()  # get the alt text, too (I break it up into multiple lines later on)\n\n        # break up the alt text into lines\n        alt_lines = []\n        current_line = \"\"\n        for _ in alt_text.split(\" \"):\n            # this breaks up the alt_text into words and creates each line by adding\n            # one word at a time until the line is longer than the width of the module\n            # then it appends the line to the alt_lines array and starts testing a new line\n            # with the next word\n            if canvas.get_text_width(current_line + _ + \" \") &lt; im_width:\n                current_line = current_line + _ + \" \"\n            else:\n                alt_lines.append(current_line)\n                current_line = _ + \" \"\n        alt_lines.append(\n            current_line)  # this adds the last line to the array (or the only line, if the alt text is really short)\n        altHeight = int(line_height * len(alt_lines)) + altOffset\n    else:\n        altHeight = 0  # this is added so that I don't need to add more \"if alt is yes\" conditionals when centering below. Now the centering code will work regardless of whether they want alttext or not\n\n    comicSpaceBlack = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n    comicSpaceColour = Image.new('RGBA', (im_width, im_height), (255, 255, 255, 255))\n\n    im = Image2()\n    im.load(f\"{tmpPath}/xkcdComic.png\")\n    im.remove_alpha()\n\n    imageAspectRatio = im_width / im_height\n    comicAspectRatio = im.image.width / im.image.height\n\n    if comicAspectRatio &gt; imageAspectRatio:\n        imageScale = im_width / im.image.width\n    else:\n        imageScale = im_height / im.image.height\n\n    comicHeight = int(im.image.height * imageScale)\n\n    headerHeight = int(line_height * 3 / 2)\n\n    if comicHeight + (headerHeight + altHeight) &gt; im_height:\n        comicHeight -= (headerHeight + altHeight)\n\n    im.resize(width=int(im.image.width * imageScale), height=comicHeight)\n\n    im_comic_black, im_comic_colour = image_to_palette(im.image.convert(\"RGB\"), self.palette)\n\n    headerCenterPosY = int((im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2))\n    comicCenterPosY = int((im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2) + headerHeight)\n    altCenterPosY = int(\n        (im_height / 2) - ((im.image.height + headerHeight + altHeight) / 2) + headerHeight + im.image.height)\n\n    centerPosX = int((im_width / 2) - (im.image.width / 2))\n\n    comicSpaceBlack.paste(im_comic_black, (centerPosX, comicCenterPosY))\n    canvas.image_black.paste(comicSpaceBlack)\n\n    comicSpaceColour.paste(im_comic_colour, (centerPosX, comicCenterPosY))\n    canvas.image_colour.paste(comicSpaceColour)\n\n    im.clear()\n    logger.info(f'added comic image')\n\n    # Write the title on the black image\n    canvas.write(\n        xy=(0, headerCenterPosY),\n        box_size=(line_width, line_height),\n        text=title_lines[0]\n    )\n\n    if self.alt == \"yes\":\n        # write alt_text\n        for _ in range(len(alt_lines)):\n            canvas.write(\n                xy=(0, altCenterPosY + _ * line_height + altOffset),\n                box_size=(line_width, line_height),\n                text=alt_lines[_],\n                alignment='left'\n            )\n    # Save image of black and colour channel in image-folder\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#jokes","title":"Jokes","text":"<p>iCanHazDadJoke module for InkyCal Project Special thanks to Erik Fredericks (@efredericks) for the template!</p> <p>Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_jokes.Jokes","title":"<code>Jokes</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Icanhazdad-api class parses rss/atom feeds from given urls</p> Source code in <code>inkycal/modules/inkycal_jokes.py</code> <pre><code>class Jokes(InkycalModule):\n    \"\"\"Icanhazdad-api class\n    parses rss/atom feeds from given urls\n    \"\"\"\n\n    name = \"iCanHazDad API - grab a random joke from icanhazdad api\"\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_feeds module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'image size: {im_width} x {im_height} px')\n\n        canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n        # Check if internet is available\n        if internet_available():\n            logger.debug('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise NetworkNotReachableError\n\n        # Set some parameters for formatting feeds\n        line_spacing = 5\n        line_height = canvas.get_line_height()\n        line_width = im_width\n        max_lines = (im_height // (line_height + line_spacing))\n\n        logger.debug(f\"max_lines: {max_lines}\")\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        logger.debug(f'line positions: {line_positions}')\n\n        # Get the actual joke\n        url = \"https://icanhazdadjoke.com\"\n        header = {\"accept\": \"text/plain\"}\n        response = requests.get(url, headers=header)\n        response.encoding = 'utf-8'  # Change encoding to UTF-8\n        joke = response.text.rstrip()  # use to remove newlines\n        logger.debug(f\"joke: {joke}\")\n\n        # wrap text in case joke is too large\n        wrapped = canvas.text_wrap(joke, max_width=line_width)\n        logger.debug(f\"wrapped: {wrapped}\")\n\n        # Check if joke can actually fit on the provided space\n        if len(wrapped) &gt; max_lines:\n            logger.error(\"Ohoh, Joke is too large for given space, please consider \"\n                         \"increasing the size for this module\")\n\n        # Write the joke on the image\n        for _ in range(len(wrapped)):\n            if _ + 1 &gt; max_lines:\n                logger.error('Ran out of lines for this joke :/')\n                break\n            canvas.write(\n                xy=line_positions[_],\n                box_size=(line_width, line_height),\n                text=wrapped[_],\n                alignment='left'\n            )\n\n        # Return images for black and colour channels\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_jokes.Jokes.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_feeds module</p> Source code in <code>inkycal/modules/inkycal_jokes.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_feeds module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_jokes.Jokes.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_jokes.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'image size: {im_width} x {im_height} px')\n\n    canvas = Canvas(im_size, font=self.font, font_size=self.fontsize)\n\n    # Check if internet is available\n    if internet_available():\n        logger.debug('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise NetworkNotReachableError\n\n    # Set some parameters for formatting feeds\n    line_spacing = 5\n    line_height = canvas.get_line_height()\n    line_width = im_width\n    max_lines = (im_height // (line_height + line_spacing))\n\n    logger.debug(f\"max_lines: {max_lines}\")\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    logger.debug(f'line positions: {line_positions}')\n\n    # Get the actual joke\n    url = \"https://icanhazdadjoke.com\"\n    header = {\"accept\": \"text/plain\"}\n    response = requests.get(url, headers=header)\n    response.encoding = 'utf-8'  # Change encoding to UTF-8\n    joke = response.text.rstrip()  # use to remove newlines\n    logger.debug(f\"joke: {joke}\")\n\n    # wrap text in case joke is too large\n    wrapped = canvas.text_wrap(joke, max_width=line_width)\n    logger.debug(f\"wrapped: {wrapped}\")\n\n    # Check if joke can actually fit on the provided space\n    if len(wrapped) &gt; max_lines:\n        logger.error(\"Ohoh, Joke is too large for given space, please consider \"\n                     \"increasing the size for this module\")\n\n    # Write the joke on the image\n    for _ in range(len(wrapped)):\n        if _ + 1 &gt; max_lines:\n            logger.error('Ran out of lines for this joke :/')\n            break\n        canvas.write(\n            xy=line_positions[_],\n            box_size=(line_width, line_height),\n            text=wrapped[_],\n            alignment='left'\n        )\n\n    # Return images for black and colour channels\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#tindie","title":"Tindie","text":"<p>Tindie module for Inkycal Project Shows unshipped orders from your Tindie store</p> <p>Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_tindie.Tindie","title":"<code>Tindie</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>Tindie - show latest orders from your store</p> Source code in <code>inkycal/modules/inkycal_tindie.py</code> <pre><code>class Tindie(InkycalModule):\n    \"\"\"Tindie - show latest orders from your store\"\"\"\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_feeds module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n        self.api_key = config['api_key']\n        self.username = config['username']\n        # todo implement mode\n        # self.mode = config['mode']  # unshipped_orders, shipped_orders, all_orders\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n        # Define new image size with respect to padding\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'image size: {im_width} x {im_height} px')\n\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Check if internet is available\n        if internet_available():\n            logger.info('Connection test passed')\n        else:\n            logger.error(\"Network not reachable. Please check your connection.\")\n            raise NetworkNotReachableError\n\n        # Set some parameters for formatting feeds\n        line_spacing = 5\n        line_height = canvas.get_line_height() + line_spacing\n        line_width = im_width\n        max_lines = (im_height // (line_height + line_spacing))\n\n        logger.debug(f\"max_lines: {max_lines}\")\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        logger.debug(f'line positions: {line_positions}')\n\n        # Make the API call\n        url = f\"https://www.tindie.com/api/v1/order/?format=json&amp;username={self.username}&amp;api_key={self.api_key}\"\n        header = {\"accept\": \"text/json\"}\n        response = requests.get(url, headers=header, params={\"shipped\": \"false\", \"limit\": \"50\"})\n        if response.status_code != 200:\n            logger.error(f\"Failed to get orders, status code: {response.status_code}, reason: {response.reason}.\")\n            logger.error(f\"response: {response.text}\")\n            raise AssertionError(\"Failed to get orders\")\n        else:\n            logger.info(\"Orders received\")\n\n        text = []\n\n        orders = json.loads(response.text)[\"orders\"]\n        text.append(f\"You have {len(orders)} unshipped orders\")\n        previous_date = None\n        for index, order in enumerate(orders, start=1):\n            items = order[\"items\"]\n            date = arrow.get(order[\"date\"]).to(\"local\").format(\"YY/MM/DD\")\n            if not previous_date or previous_date != date:\n                text.append(date)\n                previous_date = date\n            user_name = order[\"shipping_name\"]\n            text.append(f\"{index}) {user_name} from {order['shipping_country_code']} ordered {len(items)} items!\")\n\n        for pos, line in enumerate(text):\n            if pos &gt; max_lines - 1:\n                logger.error(f'Ran out of lines! Required {len(text)} lines but only {max_lines} available')\n                break\n            if pos == 0:\n                canvas.write(\n                    xy=line_positions[pos],\n                    box_size=(line_width, line_height),\n                    text=line,\n                    alignment='left',\n                    colour=\"colour\"\n                )\n            else:\n                canvas.write(\n                    xy=line_positions[pos],\n                    box_size=(line_width, line_height),\n                    text=line,\n                    alignment='left',\n                )\n\n\n        # Return images for black and colour channels\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_tindie.Tindie.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_feeds module</p> Source code in <code>inkycal/modules/inkycal_tindie.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_feeds module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n    self.api_key = config['api_key']\n    self.username = config['username']\n    # todo implement mode\n    # self.mode = config['mode']  # unshipped_orders, shipped_orders, all_orders\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_tindie.Tindie.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_tindie.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n    # Define new image size with respect to padding\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'image size: {im_width} x {im_height} px')\n\n    canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n    # Check if internet is available\n    if internet_available():\n        logger.info('Connection test passed')\n    else:\n        logger.error(\"Network not reachable. Please check your connection.\")\n        raise NetworkNotReachableError\n\n    # Set some parameters for formatting feeds\n    line_spacing = 5\n    line_height = canvas.get_line_height() + line_spacing\n    line_width = im_width\n    max_lines = (im_height // (line_height + line_spacing))\n\n    logger.debug(f\"max_lines: {max_lines}\")\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    logger.debug(f'line positions: {line_positions}')\n\n    # Make the API call\n    url = f\"https://www.tindie.com/api/v1/order/?format=json&amp;username={self.username}&amp;api_key={self.api_key}\"\n    header = {\"accept\": \"text/json\"}\n    response = requests.get(url, headers=header, params={\"shipped\": \"false\", \"limit\": \"50\"})\n    if response.status_code != 200:\n        logger.error(f\"Failed to get orders, status code: {response.status_code}, reason: {response.reason}.\")\n        logger.error(f\"response: {response.text}\")\n        raise AssertionError(\"Failed to get orders\")\n    else:\n        logger.info(\"Orders received\")\n\n    text = []\n\n    orders = json.loads(response.text)[\"orders\"]\n    text.append(f\"You have {len(orders)} unshipped orders\")\n    previous_date = None\n    for index, order in enumerate(orders, start=1):\n        items = order[\"items\"]\n        date = arrow.get(order[\"date\"]).to(\"local\").format(\"YY/MM/DD\")\n        if not previous_date or previous_date != date:\n            text.append(date)\n            previous_date = date\n        user_name = order[\"shipping_name\"]\n        text.append(f\"{index}) {user_name} from {order['shipping_country_code']} ordered {len(items)} items!\")\n\n    for pos, line in enumerate(text):\n        if pos &gt; max_lines - 1:\n            logger.error(f'Ran out of lines! Required {len(text)} lines but only {max_lines} available')\n            break\n        if pos == 0:\n            canvas.write(\n                xy=line_positions[pos],\n                box_size=(line_width, line_height),\n                text=line,\n                alignment='left',\n                colour=\"colour\"\n            )\n        else:\n            canvas.write(\n                xy=line_positions[pos],\n                box_size=(line_width, line_height),\n                text=line,\n                alignment='left',\n            )\n\n\n    # Return images for black and colour channels\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#text-file-renderer","title":"Text File Renderer","text":"<p>Textfile module for InkyCal Project</p> <p>Reads data from a plain .txt file and renders it on the display. If the content is too long, it will be truncated from the back until it fits</p> <p>Copyright by aceinnolab</p>"},{"location":"reference/#inkycal.modules.inkycal_textfile_to_display.TextToDisplay","title":"<code>TextToDisplay</code>","text":"<p>               Bases: <code>InkycalModule</code></p> <p>TextToDisplay module - Display text from a local file on the display</p> Source code in <code>inkycal/modules/inkycal_textfile_to_display.py</code> <pre><code>class TextToDisplay(InkycalModule):\n    \"\"\"TextToDisplay module - Display text from a local file on the display\n    \"\"\"\n    name = \"TextToDisplay - Display text from a local file on the display\"\n\n    def __init__(self, config):\n        \"\"\"Initialize inkycal_textfile_to_display module\"\"\"\n\n        super().__init__(config)\n\n        config = config['config']\n        # required parameters\n        self.filepath = config[\"filepath\"]\n\n        self.make_request = True if self.filepath.startswith(\"https://\") else False\n\n        # give an OK message\n        logger.debug(f'{__name__} loaded')\n\n    def _validate(self):\n        \"\"\"Validate module-specific parameters\"\"\"\n        # ensure we only use a single file\n        assert (self.filepath and len(self.filepath) == 1)\n\n    def generate_image(self):\n        \"\"\"Generate image for this module\"\"\"\n\n        # Define new image size with respect to padding\n        file_content = None\n        im_width = int(self.width - (2 * self.padding_left))\n        im_height = int(self.height - (2 * self.padding_top))\n        im_size = im_width, im_height\n        logger.debug(f'Image size: {im_size}')\n\n        canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n        # Set some parameters for formatting feeds\n        line_spacing = 4\n        line_height = canvas.get_line_height() + line_spacing\n        line_width = im_width\n        max_lines = im_height // line_height\n\n        # Calculate padding from top so the lines look centralised\n        spacing_top = int(im_height % line_height / 2)\n\n        # Calculate line_positions\n        line_positions = [\n            (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n        if self.make_request:\n            logger.info(\"Detected http path, making request\")\n            # Check if internet is available\n            if internet_available():\n                logger.info('Connection test passed')\n            else:\n                raise NetworkNotReachableError\n            file_content = urlopen(self.filepath).read().decode('utf-8')\n        else:\n            # Create list containing all lines\n            with open(self.filepath, 'r') as file:\n                file_content = file.read()\n\n        # Split content by lines if not making a request\n        if not self.make_request:\n            lines = file_content.split('\\n')\n        else:\n            lines = canvas.text_wrap(file_content, max_width=im_width)\n\n        # Trim down the list to the max number of lines\n        del lines[max_lines:]\n\n        # Write feeds on image\n        for index, line in enumerate(lines):\n            canvas.write(\n                xy=line_positions[index],\n                box_size=(line_width, line_height),\n                text=line,\n                alignment='left'\n            )\n\n        # return images\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_textfile_to_display.TextToDisplay.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize inkycal_textfile_to_display module</p> Source code in <code>inkycal/modules/inkycal_textfile_to_display.py</code> <pre><code>def __init__(self, config):\n    \"\"\"Initialize inkycal_textfile_to_display module\"\"\"\n\n    super().__init__(config)\n\n    config = config['config']\n    # required parameters\n    self.filepath = config[\"filepath\"]\n\n    self.make_request = True if self.filepath.startswith(\"https://\") else False\n\n    # give an OK message\n    logger.debug(f'{__name__} loaded')\n</code></pre>"},{"location":"reference/#inkycal.modules.inkycal_textfile_to_display.TextToDisplay.generate_image","title":"<code>generate_image()</code>","text":"<p>Generate image for this module</p> Source code in <code>inkycal/modules/inkycal_textfile_to_display.py</code> <pre><code>def generate_image(self):\n    \"\"\"Generate image for this module\"\"\"\n\n    # Define new image size with respect to padding\n    file_content = None\n    im_width = int(self.width - (2 * self.padding_left))\n    im_height = int(self.height - (2 * self.padding_top))\n    im_size = im_width, im_height\n    logger.debug(f'Image size: {im_size}')\n\n    canvas = Canvas(im_size=im_size, font=self.font, font_size=self.fontsize)\n\n    # Set some parameters for formatting feeds\n    line_spacing = 4\n    line_height = canvas.get_line_height() + line_spacing\n    line_width = im_width\n    max_lines = im_height // line_height\n\n    # Calculate padding from top so the lines look centralised\n    spacing_top = int(im_height % line_height / 2)\n\n    # Calculate line_positions\n    line_positions = [\n        (0, spacing_top + _ * line_height) for _ in range(max_lines)]\n\n    if self.make_request:\n        logger.info(\"Detected http path, making request\")\n        # Check if internet is available\n        if internet_available():\n            logger.info('Connection test passed')\n        else:\n            raise NetworkNotReachableError\n        file_content = urlopen(self.filepath).read().decode('utf-8')\n    else:\n        # Create list containing all lines\n        with open(self.filepath, 'r') as file:\n            file_content = file.read()\n\n    # Split content by lines if not making a request\n    if not self.make_request:\n        lines = file_content.split('\\n')\n    else:\n        lines = canvas.text_wrap(file_content, max_width=im_width)\n\n    # Trim down the list to the max number of lines\n    del lines[max_lines:]\n\n    # Write feeds on image\n    for index, line in enumerate(lines):\n        canvas.write(\n            xy=line_positions[index],\n            box_size=(line_width, line_height),\n            text=line,\n            alignment='left'\n        )\n\n    # return images\n    return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"reference/#display-api","title":"\ud83d\udda5 Display API","text":"<p>Inkycal ePaper Display Driver Abstraction</p> <p>This module provides the high-level Display class used by Inkycal for rendering images on supported E-Paper displays. It dynamically loads the appropriate hardware driver based on the selected model and provides:</p> <ul> <li>Rendering black/white or black/white/colour images</li> <li>Automatic fallback checks</li> <li>Display calibration</li> <li>Utility helpers for accessing supported display models</li> </ul> <p>All hardware driver implementations are expected to provide a <code>EPD</code> class with methods:</p> <ul> <li><code>init()</code></li> <li><code>display(buffer_black, buffer_colour=None)</code></li> <li><code>getbuffer(image)</code></li> <li><code>sleep()</code></li> </ul>"},{"location":"reference/#inkycal.display.display.Display","title":"<code>Display</code>","text":"<p>High-level interface for rendering images on an ePaper display.</p> <p>The Display class wraps the low-level hardware driver for the selected E-Paper model and offers simplified rendering and calibration routines.</p> <p>Parameters:</p> Name Type Description Default <code>epaper_model</code> <code>str</code> <p>Name of the display model, e.g. <code>\"waveshare_7in5_colour\"</code>.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the driver module cannot be imported or if SPI appears</p> Source code in <code>inkycal/display/display.py</code> <pre><code>class Display:\n    \"\"\"High-level interface for rendering images on an ePaper display.\n\n    The Display class wraps the low-level hardware driver for the selected\n    E-Paper model and offers simplified rendering and calibration routines.\n\n    Args:\n        epaper_model (str):\n            Name of the display model, e.g. ``\"waveshare_7in5_colour\"``.\n\n    Raises:\n        Exception: If the driver module cannot be imported or if SPI appears\n        unavailable.\n    \"\"\"\n\n    # ----------------------------------------------------------------------\n    # Initialization\n    # ----------------------------------------------------------------------\n    def __init__(self, epaper_model: str) -&gt; None:\n        \"\"\"Load and initialize the driver for the given E-Paper model.\"\"\"\n\n        self.supports_colour = \"colour\" in epaper_model\n\n        try:\n            driver = import_driver(epaper_model)\n            self._epaper = driver.EPD()\n            self.model_name = epaper_model\n\n        except ImportError:\n            raise Exception(\n                f\"Display model '{epaper_model}' is not supported. \"\n                \"Check spelling or supported models list.\"\n            )\n\n        except FileNotFoundError:\n            raise Exception(\n                \"SPI interface could not be initialized. \"\n                \"Ensure SPI is enabled on your system.\"\n            )\n\n    # ----------------------------------------------------------------------\n    # Rendering\n    # ----------------------------------------------------------------------\n    def render(self, im_black: Image.Image, im_colour: Optional[Image.Image] = None) -&gt; None:\n        \"\"\"Render one or two images on the selected E-Paper display.\n\n        Args:\n            im_black (PIL.Image):\n                The image representing black pixels. Required for **all**\n                supported E-Paper types. Anything non-white becomes black.\n\n            im_colour (PIL.Image, optional):\n                The image representing colour pixels (red/yellow). Required only\n                when the selected display supports colour. Anything non-white\n                becomes coloured.\n\n        Raises:\n            Exception: If a colour display is used without ``im_colour``.\n\n        Examples:\n            Rendering a black-white image:\n\n            &gt;&gt;&gt; img = Image.open(\"image.png\")\n            &gt;&gt;&gt; disp = Display(\"waveshare_7in5\")\n            &gt;&gt;&gt; disp.render(img)\n\n            Rendering black-white on a colour display:\n\n            &gt;&gt;&gt; img = Image.open(\"image.png\")\n            &gt;&gt;&gt; disp = Display(\"waveshare_7in5_colour\")\n            &gt;&gt;&gt; disp.render(img, img)\n\n            Rendering fully separated black + colour channels:\n\n            &gt;&gt;&gt; bw = Image.open(\"bw.png\")\n            &gt;&gt;&gt; col = Image.open(\"col.png\")\n            &gt;&gt;&gt; disp.render(bw, col)\n        \"\"\"\n        epaper = self._epaper\n\n        # Initialize and update\n        print(\"Initialising..\", end=\"\")\n        epaper.init()\n\n        print(\"Updating display......\", end=\"\")\n        if self.supports_colour:\n            if im_colour is None:\n                raise Exception(\n                    \"im_colour is required for colour E-Paper displays.\"\n                )\n            epaper.display(\n                epaper.getbuffer(im_black),\n                epaper.getbuffer(im_colour),\n            )\n        else:\n            epaper.display(epaper.getbuffer(im_black))\n\n        print(\"Done\")\n\n        # Put display into deep sleep to reduce ghosting and power usage\n        print(\"Sending E-Paper to deep sleep...\", end=\"\")\n        epaper.sleep()\n        print(\"Done\")\n\n    # ----------------------------------------------------------------------\n    # Calibration\n    # ----------------------------------------------------------------------\n    def calibrate(self, cycles: int = 3) -&gt; None:\n        \"\"\"Calibrate the display to reduce ghosting and restore contrast.\n\n        Performs repeated full-screen refresh cycles using black/white or\n        black/white/colour depending on the display type.\n\n        Args:\n            cycles (int):\n                Number of calibration cycles. More cycles produce cleaner\n                results but take longer.\n\n        Notes:\n            - Black/white displays: ~10 minutes for 3 cycles.\n            - Colour displays: ~20 minutes for 3 cycles.\n            - Recommended: run calibration every **~6 updates**.\n\n        Raises:\n            RuntimeError: If display initialization fails.\n        \"\"\"\n        epaper = self._epaper\n        epaper.init()\n\n        display_size = self.get_display_size(self.model_name)\n\n        white = Image.new(\"1\", display_size, \"white\")\n        black = Image.new(\"1\", display_size, \"black\")\n\n        print(\"---------- Starting calibration ----------\")\n\n        if self.supports_colour:\n            # black \u2192 colour \u2192 white\n            for i in range(cycles):\n                print(f\"Cycle {i+1}/{cycles}: black...\", end=\" \")\n                epaper.display(epaper.getbuffer(black), epaper.getbuffer(white))\n\n                print(\"colour...\", end=\" \")\n                epaper.display(epaper.getbuffer(white), epaper.getbuffer(black))\n\n                print(\"white...\")\n                epaper.display(epaper.getbuffer(white), epaper.getbuffer(white))\n\n        else:\n            # black \u2192 white\n            for i in range(cycles):\n                print(f\"Cycle {i+1}/{cycles}: black...\", end=\" \")\n                epaper.display(epaper.getbuffer(black))\n\n                print(\"white...\")\n                epaper.display(epaper.getbuffer(white))\n\n            epaper.sleep()\n\n        print(\"---------- Calibration complete ----------\")\n\n    # ----------------------------------------------------------------------\n    # Display information helpers\n    # ----------------------------------------------------------------------\n    @classmethod\n    def get_display_size(cls, model_name: str) -&gt; Tuple[int, int]:\n        \"\"\"Return the pixel size of a supported display.\n\n        Args:\n            model_name (str):\n                Display model identifier (key in ``supported_models``).\n\n        Returns:\n            Tuple[int, int]: The display resolution as ``(width, height)``.\n\n        Raises:\n            AssertionError: If the model is not found.\n\n        Example:\n            &gt;&gt;&gt; Display.get_display_size(\"waveshare_7in5\")\n            (800, 480)\n        \"\"\"\n        if model_name in supported_models:\n            return supported_models[model_name]\n\n        raise AssertionError(f\"'{model_name}' not found in supported models\")\n\n    @classmethod\n    def get_display_names(cls) -&gt; List[str]:\n        \"\"\"Return a list of all supported E-Paper model names.\n\n        Returns:\n            List[str]: All supported display identifiers.\n\n        Example:\n            &gt;&gt;&gt; Display.get_display_names()\n            ['waveshare_7in5', 'waveshare_7in5_colour', ...]\n        \"\"\"\n        return list(supported_models.keys())\n\n    # ----------------------------------------------------------------------\n    # Utility: simple text rendering\n    # ----------------------------------------------------------------------\n    def render_text(self, text: str, font_size: int = 24, max_width_ratio: float = 0.95) -&gt; None:\n        \"\"\"Render a centered, auto-wrapped text message on the display.\n\n        This is primarily used for setup messages, error reporting,\n        or simple system notifications.\n\n        Args:\n            text (str):\n                Text to display. Auto-wrapped to fit screen width.\n\n            font_size (int):\n                Base font size used to render text.\n\n            max_width_ratio (float):\n                Maximum fraction of screen width allowed for text lines.\n\n        Raises:\n            Exception: If the display cannot be initialized or rendered.\n\n        Example:\n            &gt;&gt;&gt; disp = Display(\"waveshare_7in5\")\n            &gt;&gt;&gt; disp.render_text(\"Hello world!\")\n        \"\"\"\n        from PIL import ImageDraw, ImageFont\n        from inkycal.utils.enums import FONTS\n\n        # Fetch resolution (Inkycal rotates images internally)\n        height, width = self.get_display_size(self.model_name)\n\n        # Load font\n        font = ImageFont.truetype(FONTS.default.value, font_size)\n\n        # Temporary canvas for measurements\n        temp_img = Image.new(\"1\", (width, height), \"white\")\n        draw = ImageDraw.Draw(temp_img)\n\n        # Helper: measure text line\n        def measure(line: str):\n            bbox = draw.textbbox((0, 0), line, font=font)\n            return bbox[2] - bbox[0], bbox[3] - bbox[1]\n\n        max_width_px = int(width * max_width_ratio)\n\n        # Auto-wrap\n        words = text.split()\n        lines = []\n        current = []\n\n        for word in words:\n            test = \" \".join(current + [word])\n            w, _ = measure(test)\n            if w &lt;= max_width_px:\n                current.append(word)\n            else:\n                lines.append(\" \".join(current))\n                current = [word]\n\n        if current:\n            lines.append(\" \".join(current))\n\n        # Measure block height\n        line_sizes = [measure(line) for line in lines]\n        total_height = sum(h for _, h in line_sizes)\n        y = (height - total_height) // 2\n\n        # Final BW image\n        img_bw = Image.new(\"1\", (width, height), \"white\")\n        draw_final = ImageDraw.Draw(img_bw)\n\n        for line, (w, h) in zip(lines, line_sizes):\n            x = (width - w) // 2\n            draw_final.text((x, y), line, fill=\"black\", font=font)\n            y += h\n\n        # Dummy colour channel\n        img_colour = Image.new(\"1\", (width, height), \"white\")\n\n        self.render(img_bw, img_colour)\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.__init__","title":"<code>__init__(epaper_model)</code>","text":"<p>Load and initialize the driver for the given E-Paper model.</p> Source code in <code>inkycal/display/display.py</code> <pre><code>def __init__(self, epaper_model: str) -&gt; None:\n    \"\"\"Load and initialize the driver for the given E-Paper model.\"\"\"\n\n    self.supports_colour = \"colour\" in epaper_model\n\n    try:\n        driver = import_driver(epaper_model)\n        self._epaper = driver.EPD()\n        self.model_name = epaper_model\n\n    except ImportError:\n        raise Exception(\n            f\"Display model '{epaper_model}' is not supported. \"\n            \"Check spelling or supported models list.\"\n        )\n\n    except FileNotFoundError:\n        raise Exception(\n            \"SPI interface could not be initialized. \"\n            \"Ensure SPI is enabled on your system.\"\n        )\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.calibrate","title":"<code>calibrate(cycles=3)</code>","text":"<p>Calibrate the display to reduce ghosting and restore contrast.</p> <p>Performs repeated full-screen refresh cycles using black/white or black/white/colour depending on the display type.</p> <p>Parameters:</p> Name Type Description Default <code>cycles</code> <code>int</code> <p>Number of calibration cycles. More cycles produce cleaner results but take longer.</p> <code>3</code> Notes <ul> <li>Black/white displays: ~10 minutes for 3 cycles.</li> <li>Colour displays: ~20 minutes for 3 cycles.</li> <li>Recommended: run calibration every ~6 updates.</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If display initialization fails.</p> Source code in <code>inkycal/display/display.py</code> <pre><code>def calibrate(self, cycles: int = 3) -&gt; None:\n    \"\"\"Calibrate the display to reduce ghosting and restore contrast.\n\n    Performs repeated full-screen refresh cycles using black/white or\n    black/white/colour depending on the display type.\n\n    Args:\n        cycles (int):\n            Number of calibration cycles. More cycles produce cleaner\n            results but take longer.\n\n    Notes:\n        - Black/white displays: ~10 minutes for 3 cycles.\n        - Colour displays: ~20 minutes for 3 cycles.\n        - Recommended: run calibration every **~6 updates**.\n\n    Raises:\n        RuntimeError: If display initialization fails.\n    \"\"\"\n    epaper = self._epaper\n    epaper.init()\n\n    display_size = self.get_display_size(self.model_name)\n\n    white = Image.new(\"1\", display_size, \"white\")\n    black = Image.new(\"1\", display_size, \"black\")\n\n    print(\"---------- Starting calibration ----------\")\n\n    if self.supports_colour:\n        # black \u2192 colour \u2192 white\n        for i in range(cycles):\n            print(f\"Cycle {i+1}/{cycles}: black...\", end=\" \")\n            epaper.display(epaper.getbuffer(black), epaper.getbuffer(white))\n\n            print(\"colour...\", end=\" \")\n            epaper.display(epaper.getbuffer(white), epaper.getbuffer(black))\n\n            print(\"white...\")\n            epaper.display(epaper.getbuffer(white), epaper.getbuffer(white))\n\n    else:\n        # black \u2192 white\n        for i in range(cycles):\n            print(f\"Cycle {i+1}/{cycles}: black...\", end=\" \")\n            epaper.display(epaper.getbuffer(black))\n\n            print(\"white...\")\n            epaper.display(epaper.getbuffer(white))\n\n        epaper.sleep()\n\n    print(\"---------- Calibration complete ----------\")\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.get_display_names","title":"<code>get_display_names()</code>  <code>classmethod</code>","text":"<p>Return a list of all supported E-Paper model names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: All supported display identifiers.</p> Example <p>Display.get_display_names() ['waveshare_7in5', 'waveshare_7in5_colour', ...]</p> Source code in <code>inkycal/display/display.py</code> <pre><code>@classmethod\ndef get_display_names(cls) -&gt; List[str]:\n    \"\"\"Return a list of all supported E-Paper model names.\n\n    Returns:\n        List[str]: All supported display identifiers.\n\n    Example:\n        &gt;&gt;&gt; Display.get_display_names()\n        ['waveshare_7in5', 'waveshare_7in5_colour', ...]\n    \"\"\"\n    return list(supported_models.keys())\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.get_display_size","title":"<code>get_display_size(model_name)</code>  <code>classmethod</code>","text":"<p>Return the pixel size of a supported display.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Display model identifier (key in <code>supported_models</code>).</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: The display resolution as <code>(width, height)</code>.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model is not found.</p> Example <p>Display.get_display_size(\"waveshare_7in5\") (800, 480)</p> Source code in <code>inkycal/display/display.py</code> <pre><code>@classmethod\ndef get_display_size(cls, model_name: str) -&gt; Tuple[int, int]:\n    \"\"\"Return the pixel size of a supported display.\n\n    Args:\n        model_name (str):\n            Display model identifier (key in ``supported_models``).\n\n    Returns:\n        Tuple[int, int]: The display resolution as ``(width, height)``.\n\n    Raises:\n        AssertionError: If the model is not found.\n\n    Example:\n        &gt;&gt;&gt; Display.get_display_size(\"waveshare_7in5\")\n        (800, 480)\n    \"\"\"\n    if model_name in supported_models:\n        return supported_models[model_name]\n\n    raise AssertionError(f\"'{model_name}' not found in supported models\")\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.render","title":"<code>render(im_black, im_colour=None)</code>","text":"<p>Render one or two images on the selected E-Paper display.</p> <p>Parameters:</p> Name Type Description Default <code>im_black</code> <code>Image</code> <p>The image representing black pixels. Required for all supported E-Paper types. Anything non-white becomes black.</p> required <code>im_colour</code> <code>Image</code> <p>The image representing colour pixels (red/yellow). Required only when the selected display supports colour. Anything non-white becomes coloured.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If a colour display is used without <code>im_colour</code>.</p> <p>Examples:</p> <p>Rendering a black-white image:</p> <pre><code>&gt;&gt;&gt; img = Image.open(\"image.png\")\n&gt;&gt;&gt; disp = Display(\"waveshare_7in5\")\n&gt;&gt;&gt; disp.render(img)\n</code></pre> <p>Rendering black-white on a colour display:</p> <pre><code>&gt;&gt;&gt; img = Image.open(\"image.png\")\n&gt;&gt;&gt; disp = Display(\"waveshare_7in5_colour\")\n&gt;&gt;&gt; disp.render(img, img)\n</code></pre> <p>Rendering fully separated black + colour channels:</p> <pre><code>&gt;&gt;&gt; bw = Image.open(\"bw.png\")\n&gt;&gt;&gt; col = Image.open(\"col.png\")\n&gt;&gt;&gt; disp.render(bw, col)\n</code></pre> Source code in <code>inkycal/display/display.py</code> <pre><code>def render(self, im_black: Image.Image, im_colour: Optional[Image.Image] = None) -&gt; None:\n    \"\"\"Render one or two images on the selected E-Paper display.\n\n    Args:\n        im_black (PIL.Image):\n            The image representing black pixels. Required for **all**\n            supported E-Paper types. Anything non-white becomes black.\n\n        im_colour (PIL.Image, optional):\n            The image representing colour pixels (red/yellow). Required only\n            when the selected display supports colour. Anything non-white\n            becomes coloured.\n\n    Raises:\n        Exception: If a colour display is used without ``im_colour``.\n\n    Examples:\n        Rendering a black-white image:\n\n        &gt;&gt;&gt; img = Image.open(\"image.png\")\n        &gt;&gt;&gt; disp = Display(\"waveshare_7in5\")\n        &gt;&gt;&gt; disp.render(img)\n\n        Rendering black-white on a colour display:\n\n        &gt;&gt;&gt; img = Image.open(\"image.png\")\n        &gt;&gt;&gt; disp = Display(\"waveshare_7in5_colour\")\n        &gt;&gt;&gt; disp.render(img, img)\n\n        Rendering fully separated black + colour channels:\n\n        &gt;&gt;&gt; bw = Image.open(\"bw.png\")\n        &gt;&gt;&gt; col = Image.open(\"col.png\")\n        &gt;&gt;&gt; disp.render(bw, col)\n    \"\"\"\n    epaper = self._epaper\n\n    # Initialize and update\n    print(\"Initialising..\", end=\"\")\n    epaper.init()\n\n    print(\"Updating display......\", end=\"\")\n    if self.supports_colour:\n        if im_colour is None:\n            raise Exception(\n                \"im_colour is required for colour E-Paper displays.\"\n            )\n        epaper.display(\n            epaper.getbuffer(im_black),\n            epaper.getbuffer(im_colour),\n        )\n    else:\n        epaper.display(epaper.getbuffer(im_black))\n\n    print(\"Done\")\n\n    # Put display into deep sleep to reduce ghosting and power usage\n    print(\"Sending E-Paper to deep sleep...\", end=\"\")\n    epaper.sleep()\n    print(\"Done\")\n</code></pre>"},{"location":"reference/#inkycal.display.display.Display.render_text","title":"<code>render_text(text, font_size=24, max_width_ratio=0.95)</code>","text":"<p>Render a centered, auto-wrapped text message on the display.</p> <p>This is primarily used for setup messages, error reporting, or simple system notifications.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to display. Auto-wrapped to fit screen width.</p> required <code>font_size</code> <code>int</code> <p>Base font size used to render text.</p> <code>24</code> <code>max_width_ratio</code> <code>float</code> <p>Maximum fraction of screen width allowed for text lines.</p> <code>0.95</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the display cannot be initialized or rendered.</p> Example <p>disp = Display(\"waveshare_7in5\") disp.render_text(\"Hello world!\")</p> Source code in <code>inkycal/display/display.py</code> <pre><code>def render_text(self, text: str, font_size: int = 24, max_width_ratio: float = 0.95) -&gt; None:\n    \"\"\"Render a centered, auto-wrapped text message on the display.\n\n    This is primarily used for setup messages, error reporting,\n    or simple system notifications.\n\n    Args:\n        text (str):\n            Text to display. Auto-wrapped to fit screen width.\n\n        font_size (int):\n            Base font size used to render text.\n\n        max_width_ratio (float):\n            Maximum fraction of screen width allowed for text lines.\n\n    Raises:\n        Exception: If the display cannot be initialized or rendered.\n\n    Example:\n        &gt;&gt;&gt; disp = Display(\"waveshare_7in5\")\n        &gt;&gt;&gt; disp.render_text(\"Hello world!\")\n    \"\"\"\n    from PIL import ImageDraw, ImageFont\n    from inkycal.utils.enums import FONTS\n\n    # Fetch resolution (Inkycal rotates images internally)\n    height, width = self.get_display_size(self.model_name)\n\n    # Load font\n    font = ImageFont.truetype(FONTS.default.value, font_size)\n\n    # Temporary canvas for measurements\n    temp_img = Image.new(\"1\", (width, height), \"white\")\n    draw = ImageDraw.Draw(temp_img)\n\n    # Helper: measure text line\n    def measure(line: str):\n        bbox = draw.textbbox((0, 0), line, font=font)\n        return bbox[2] - bbox[0], bbox[3] - bbox[1]\n\n    max_width_px = int(width * max_width_ratio)\n\n    # Auto-wrap\n    words = text.split()\n    lines = []\n    current = []\n\n    for word in words:\n        test = \" \".join(current + [word])\n        w, _ = measure(test)\n        if w &lt;= max_width_px:\n            current.append(word)\n        else:\n            lines.append(\" \".join(current))\n            current = [word]\n\n    if current:\n        lines.append(\" \".join(current))\n\n    # Measure block height\n    line_sizes = [measure(line) for line in lines]\n    total_height = sum(h for _, h in line_sizes)\n    y = (height - total_height) // 2\n\n    # Final BW image\n    img_bw = Image.new(\"1\", (width, height), \"white\")\n    draw_final = ImageDraw.Draw(img_bw)\n\n    for line, (w, h) in zip(lines, line_sizes):\n        x = (width - w) // 2\n        draw_final.text((x, y), line, fill=\"black\", font=font)\n        y += h\n\n    # Dummy colour channel\n    img_colour = Image.new(\"1\", (width, height), \"white\")\n\n    self.render(img_bw, img_colour)\n</code></pre>"},{"location":"reference/#inkycal.display.display.import_driver","title":"<code>import_driver(model)</code>","text":"<p>Dynamically import a driver module for the given display model.</p> Source code in <code>inkycal/display/display.py</code> <pre><code>def import_driver(model: str):\n    \"\"\"Dynamically import a driver module for the given display model.\"\"\"\n    return import_module(f\"inkycal.display.drivers.{model}\")\n</code></pre>"},{"location":"reference/#canvas-api","title":"\ud83c\udfa8 Canvas API","text":"<p>This is one of the most important components of Inkycal. It is used to render text, icons, shapes, and previews.</p> <p>Auto-generate docs:</p> <p>canvas.py</p>"},{"location":"reference/#inkycal.utils.canvas.Canvas","title":"<code>Canvas</code>","text":"<p>Canvas class of Inkycal. Set this up once and use to draw text on a PIL Image.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>class Canvas:\n    \"\"\"Canvas class of Inkycal. Set this up once and use to draw text on a PIL Image.\"\"\"\n    def __init__(self, im_size:Tuple[int, int], font: FONTS, font_size: int):\n        self._font = ImageFont.truetype(font.value, font_size)\n        self.font_enum = font\n        self._font_size = font_size\n        self.image_black = Image.new('RGB', size=im_size, color='white')\n        self.image_colour = Image.new('RGB', size=im_size, color='white')\n\n\n    def set_font_size(self, font_size: int):\n        \"\"\"Set the font size to use\"\"\"\n        self._font_size = font_size\n\n    @property\n    def font_size(self):\n        return self._font_size\n\n    @property\n    def size(self):\n        return self.image_black.size\n\n    def set_font(self, font:FONTS, font_size: Optional[int]):\n        self.font_enum = font\n        self._font = ImageFont.truetype(font, font_size if font_size else self._font_size)\n\n    @property\n    def font(self) -&gt; FONTS:\n        return self.font_enum\n\n    def write(\n            self,\n            xy: Tuple[int, int],\n            box_size: Tuple[int, int],\n            text: str,\n            *,\n            alignment: Literal[\"center\", \"left\", \"right\"] = \"center\",\n            autofit: bool = False,\n            colour: Literal[\"black\", \"colour\"] = \"black\",\n            rotation: Optional[float] = None,\n            fill_width: float = 1.0,\n            fill_height: float = 0.8,\n    ) -&gt; None:\n        \"\"\"\n        Write (possibly multi-line) text inside a rectangle.\n        Supports '\\n' and auto-wrapping inside each line.\n        \"\"\"\n\n        box_x, box_y = xy\n        box_w, box_h = box_size\n\n        font_path = self.font_enum.value\n        font = self._font\n        size = self._font_size\n\n        # ----------------------------\n        # 1) Auto-fit the font size\n        # ----------------------------\n        if autofit or (fill_width != 1.0) or (fill_height != 0.8):\n            size = max(8, size)\n            while True:\n                font = _load_font(font_path, size)\n\n                # measure test height with 1-line sample\n                sample_h = font.getbbox(\"Ag\")[3] - font.getbbox(\"Ag\")[1]\n\n                if sample_h &gt;= int(box_h * fill_height):\n                    if size &gt; 8:\n                        size -= 1\n                    font = _load_font(font_path, size)\n                    break\n\n                size += 1\n\n            self._font_size = size\n            self._font = font\n\n        # ----------------------------\n        # 2) Split text into logical lines\n        # ----------------------------\n        logical_lines = text.split(\"\\n\")\n\n        # ----------------------------\n        # 3) Wrap each line to the box width\n        # ----------------------------\n        wrapped_lines: list[str] = []\n        for line in logical_lines:\n            wrapped_lines.extend(self.text_wrap(line, max_width=int(box_w * fill_width)))\n\n        if not wrapped_lines:\n            return\n\n        # ----------------------------\n        # 4) Measure combined height\n        # ----------------------------\n        line_heights = []\n        total_h = 0\n\n        for line in wrapped_lines:\n            bbox = font.getbbox(line)\n            h = bbox[3] - bbox[1]\n            line_heights.append(h)\n            total_h += h\n\n        # add minimal line spacing (you can tune this)\n        line_spacing = int(font.size * 0.2)\n        total_h += line_spacing * (len(wrapped_lines) - 1)\n\n        # If text block too tall \u2192 truncate bottom lines\n        while total_h &gt; box_h and wrapped_lines:\n            removed = wrapped_lines.pop()\n            removed_h = line_heights.pop()\n            total_h -= (removed_h + line_spacing)\n\n        if not wrapped_lines:\n            return\n\n        # ----------------------------\n        # 5) Vertical centering\n        # ----------------------------\n        cy = box_y + (box_h - total_h) // 2\n\n        # ----------------------------\n        # 6) Create transparent layer and draw lines\n        # ----------------------------\n        space = Image.new(\"RGBA\", (box_w, box_h), (0, 0, 0, 0))\n        draw = ImageDraw.Draw(space)\n\n        py = 0\n        for line, lh in zip(wrapped_lines, line_heights):\n\n            # horizontal alignment\n            line_w = font.getbbox(line)[2] - font.getbbox(line)[0]\n\n            if alignment == \"center\":\n                px = (box_w - line_w) // 2\n            elif alignment == \"left\":\n                px = 0\n            elif alignment == \"right\":\n                px = box_w - line_w\n            else:\n                px = (box_w - line_w) // 2\n\n            draw.text((px, py), line, fill=\"black\", font=font)\n            py += lh + line_spacing\n\n        # ----------------------------\n        # 7) Rotation + paste\n        # ----------------------------\n        if rotation:\n            space = space.rotate(rotation, expand=True)\n\n        # Always draw on black first\n        self.image_black.paste(space, xy, space)\n\n        # Colour overlay if needed\n        if colour == \"colour\":\n            self.image_colour.paste(space, xy, space)\n\n    def text_wrap(self, text: str, max_width: int) -&gt; list[str]:\n        \"\"\"\n        Split long text into wrapped lines using the Canvas' current font.\n\n        Args:\n            text: The full text to wrap.\n            max_width: Maximum pixel width allowed per line.\n\n        Returns:\n            A list of strings, each representing one wrapped line.\n        \"\"\"\n\n        font = self._font\n        words = text.split(\" \")\n        lines = []\n        current_line = \"\"\n\n        for word in words:\n            # Test candidate line\n            proposed = (current_line + \" \" + word).strip()\n\n            if font.getlength(proposed) &lt;= max_width:\n                # Word fits \u2014 extend current line\n                current_line = proposed\n            else:\n                # Word does not fit\n                if not current_line:\n                    # Word itself too long: force-break\n                    lines.append(word)\n                else:\n                    # Push current line and start a new one\n                    lines.append(current_line)\n                    current_line = word\n\n        # Add final line\n        if current_line:\n            lines.append(current_line)\n\n        return lines\n\n    def auto_fontsize(self, max_height: int, sample_text: str = \"Ag\", target_ratio: float = 0.80):\n        \"\"\"\n        Automatically scale the canvas' font so its height reaches ~target_ratio\n        of the given max_height.\n\n        Args:\n            max_height (int): Maximum allowed pixel height.\n            sample_text (str): Text used to measure font height. Default \"Ag\".\n            target_ratio (float): The portion of max_height the font should fill.\n\n        Returns:\n            None \u2014 self.font and self._font_size are updated.\n        \"\"\"\n\n        best_size = 1\n        target_height = max_height * target_ratio\n\n        # Start from the current size\n        size = self._font_size\n\n        # Increment font size until height overshoots target\n        while True:\n            font = _load_font(self.font_enum.value, size)\n            bbox = font.getbbox(sample_text)\n            height = bbox[3] - bbox[1]\n\n            if height &gt; target_height:\n                break\n\n            best_size = size\n            size += 1\n\n        # Load the chosen font size\n        self._font_size = best_size\n        font_path = self.font_enum.value\n        self._font = _load_font(font_path, best_size)\n\n    def get_line_height(self, sample_text: str = \"Ag\") -&gt; int:\n        \"\"\"\n        Return the pixel line height of the currently active font.\n        Based on ascent + descent, with a reliable fallback if unsupported.\n\n        Args:\n            sample_text (str): A sample string used to measure font height.\n\n        Returns:\n            int \u2014 Line height in pixels.\n        \"\"\"\n        try:\n            ascent, descent = self._font.getmetrics()\n            return ascent + descent\n        except Exception:\n            # Fallback using bounding box\n            bbox = self._font.getbbox(sample_text)\n            return int(bbox[3] - bbox[1])\n\n    def get_text_width(self, text: str) -&gt; int:\n        \"\"\"\n        Return the rendered width of a string using the current font.\n\n        Args:\n            text (str): The text to measure.\n\n        Returns:\n            int \u2014 Width in pixels.\n        \"\"\"\n        bbox = self._font.getbbox(text)\n        return int(bbox[2] - bbox[0])\n\n    def draw_icon(\n            self,\n            xy: Tuple[int, int],\n            box_size: Tuple[int, int],\n            icon: str,\n            colour: Literal[\"black\", \"colour\"] = \"black\",\n            rotation: Optional[float] = None,\n            fill_ratio: float = 0.90,\n            font: Optional[FONTS] = None,\n    ) -&gt; None:\n\n        box_x, box_y = xy\n        box_w, box_h = box_size\n\n        # Select icon font\n        font_enum = font or FONTS.weather_icons\n        font_path = font_enum.value\n\n        # --- Determine max usable size ---\n        size = 8\n        while True:\n            test_font = _load_font(font_path, size)\n            bbox = test_font.getbbox(icon)\n            w = bbox[2] - bbox[0]\n            h = bbox[3] - bbox[1]\n            if w &gt;= box_w * fill_ratio or h &gt;= box_h * fill_ratio:\n                size = max(8, size - 1)\n                break\n            size += 1\n\n        font_final = _load_font(font_path, size)\n\n        # --- TEMP CANVAS FOR PIXEL ANALYSIS ---\n        temp_w = box_w * 2\n        temp_h = box_h * 2\n\n        # 1) Render icon for ALPHA extraction\n        temp_alpha = Image.new(\"L\", (temp_w, temp_h), 0)\n        dA = ImageDraw.Draw(temp_alpha)\n        dA.text((temp_w // 2, temp_h // 2), icon, fill=255, font=font_final, anchor=\"mm\")\n\n        # Convert to numpy\n        import numpy as np\n        arr = np.asarray(temp_alpha)\n\n        # Detect ink pixels\n        mask = arr &gt; 10  # threshold to keep fill\n\n        if not mask.any():\n            return\n\n        ys, xs = np.where(mask)\n        min_x, max_x = xs.min(), xs.max()\n        min_y, max_y = ys.min(), ys.max()\n\n        ink_w = max_x - min_x + 1\n        ink_h = max_y - min_y + 1\n\n        # Extract the alpha mask for that region\n        mask_region = temp_alpha.crop((min_x, min_y, max_x + 1, max_y + 1))\n\n        # --- 2) Render icon again as RGB fill (full-strength black) ---\n        temp_rgb = Image.new(\"RGB\", (temp_w, temp_h), \"white\")\n        dR = ImageDraw.Draw(temp_rgb)\n        dR.text((temp_w // 2, temp_h // 2), icon, fill=\"black\", font=font_final, anchor=\"mm\")\n\n        rgb_region = temp_rgb.crop((min_x, min_y, max_x + 1, max_y + 1))\n\n        # --- 3) Combine into RGBA for final paste ---\n        layer = Image.new(\"RGBA\", (box_w, box_h), (0, 0, 0, 0))\n\n        paste_x = (box_w - ink_w) // 2\n        paste_y = (box_h - ink_h) // 2\n\n        layer.paste(rgb_region, (paste_x, paste_y), mask_region)\n\n        if rotation:\n            layer = layer.rotate(rotation, expand=True)\n\n        # Paste to black layer\n        self.image_black.paste(layer, xy, layer)\n\n        # Paste to colour layer if needed\n        if colour == \"colour\":\n            self.image_colour.paste(layer, xy, layer)\n\n    @staticmethod\n    def _optimize_for_red_preview(img: Image.Image, threshold: int = 200) -&gt; Image.Image:\n        \"\"\"\n        Normalize coloured-image contrast before converting to red.\n        Dark pixels \u2192 black\n        Light pixels \u2192 white\n        Threshold-based cleanup prevents blurry thick red shapes.\n        \"\"\"\n        arr = numpy.asarray(img.convert(\"RGB\")).copy()\n\n        red = arr[:, :, 0]\n        green = arr[:, :, 1]\n        blue = arr[:, :, 2]\n\n        # Identify dark-ish pixels \u2192 treat as black\n        dark_mask = (red &lt;= threshold) &amp; (green &lt;= threshold) &amp; (blue &lt;= threshold)\n\n        # Everything else becomes pure white\n        arr[~dark_mask] = [255, 255, 255]\n        arr[dark_mask] = [0, 0, 0]\n\n        return Image.fromarray(arr)\n\n    @staticmethod\n    def color_to_red(img: Image.Image) -&gt; Image.Image:\n        \"\"\"\n        Convert dark pixels to red with alpha transparency.\n        Uses optimized thresholding for more accurate previews.\n        \"\"\"\n        arr = numpy.asarray(img.convert(\"RGBA\")).copy()\n\n        # dark = colored pixel (0,0,0) after optimization\n        dark_mask = (arr[:, :, 0] == 0) &amp; (arr[:, :, 1] == 0) &amp; (arr[:, :, 2] == 0)\n\n        # Red output pixels\n        arr[dark_mask, 0] = 255  # R\n        arr[dark_mask, 1] = 0  # G\n        arr[dark_mask, 2] = 0  # B\n\n        # Alpha channel\n        arr[:, :, 3] = (dark_mask * 255).astype(numpy.uint8)\n\n        return Image.fromarray(arr)\n\n    def get_preview_image(self) -&gt; Image.Image:\n        \"\"\"Returns a black+red preview image, optimized for readability.\"\"\"\n\n        # 1. Copy black image\n        image_black = self.image_black.copy()\n\n        # 2. Optimize the colour layer first (cleans up anti-aliasing)\n        optimized_colour = self._optimize_for_red_preview(self.image_colour)\n\n        # 3. Convert darkened layer to red overlay\n        image_colour_red = self.color_to_red(optimized_colour)\n\n        # 4. Composite\n        image_black.paste(image_colour_red, (0, 0), image_colour_red)\n\n        logger.info(\"Preview image created (optimized black + red composite)\")\n        return image_black\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.auto_fontsize","title":"<code>auto_fontsize(max_height, sample_text='Ag', target_ratio=0.8)</code>","text":"<p>Automatically scale the canvas' font so its height reaches ~target_ratio of the given max_height.</p> <p>Parameters:</p> Name Type Description Default <code>max_height</code> <code>int</code> <p>Maximum allowed pixel height.</p> required <code>sample_text</code> <code>str</code> <p>Text used to measure font height. Default \"Ag\".</p> <code>'Ag'</code> <code>target_ratio</code> <code>float</code> <p>The portion of max_height the font should fill.</p> <code>0.8</code> <p>Returns:</p> Type Description <p>None \u2014 self.font and self._font_size are updated.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def auto_fontsize(self, max_height: int, sample_text: str = \"Ag\", target_ratio: float = 0.80):\n    \"\"\"\n    Automatically scale the canvas' font so its height reaches ~target_ratio\n    of the given max_height.\n\n    Args:\n        max_height (int): Maximum allowed pixel height.\n        sample_text (str): Text used to measure font height. Default \"Ag\".\n        target_ratio (float): The portion of max_height the font should fill.\n\n    Returns:\n        None \u2014 self.font and self._font_size are updated.\n    \"\"\"\n\n    best_size = 1\n    target_height = max_height * target_ratio\n\n    # Start from the current size\n    size = self._font_size\n\n    # Increment font size until height overshoots target\n    while True:\n        font = _load_font(self.font_enum.value, size)\n        bbox = font.getbbox(sample_text)\n        height = bbox[3] - bbox[1]\n\n        if height &gt; target_height:\n            break\n\n        best_size = size\n        size += 1\n\n    # Load the chosen font size\n    self._font_size = best_size\n    font_path = self.font_enum.value\n    self._font = _load_font(font_path, best_size)\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.color_to_red","title":"<code>color_to_red(img)</code>  <code>staticmethod</code>","text":"<p>Convert dark pixels to red with alpha transparency. Uses optimized thresholding for more accurate previews.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>@staticmethod\ndef color_to_red(img: Image.Image) -&gt; Image.Image:\n    \"\"\"\n    Convert dark pixels to red with alpha transparency.\n    Uses optimized thresholding for more accurate previews.\n    \"\"\"\n    arr = numpy.asarray(img.convert(\"RGBA\")).copy()\n\n    # dark = colored pixel (0,0,0) after optimization\n    dark_mask = (arr[:, :, 0] == 0) &amp; (arr[:, :, 1] == 0) &amp; (arr[:, :, 2] == 0)\n\n    # Red output pixels\n    arr[dark_mask, 0] = 255  # R\n    arr[dark_mask, 1] = 0  # G\n    arr[dark_mask, 2] = 0  # B\n\n    # Alpha channel\n    arr[:, :, 3] = (dark_mask * 255).astype(numpy.uint8)\n\n    return Image.fromarray(arr)\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.get_line_height","title":"<code>get_line_height(sample_text='Ag')</code>","text":"<p>Return the pixel line height of the currently active font. Based on ascent + descent, with a reliable fallback if unsupported.</p> <p>Parameters:</p> Name Type Description Default <code>sample_text</code> <code>str</code> <p>A sample string used to measure font height.</p> <code>'Ag'</code> <p>Returns:</p> Type Description <code>int</code> <p>int \u2014 Line height in pixels.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def get_line_height(self, sample_text: str = \"Ag\") -&gt; int:\n    \"\"\"\n    Return the pixel line height of the currently active font.\n    Based on ascent + descent, with a reliable fallback if unsupported.\n\n    Args:\n        sample_text (str): A sample string used to measure font height.\n\n    Returns:\n        int \u2014 Line height in pixels.\n    \"\"\"\n    try:\n        ascent, descent = self._font.getmetrics()\n        return ascent + descent\n    except Exception:\n        # Fallback using bounding box\n        bbox = self._font.getbbox(sample_text)\n        return int(bbox[3] - bbox[1])\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.get_preview_image","title":"<code>get_preview_image()</code>","text":"<p>Returns a black+red preview image, optimized for readability.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def get_preview_image(self) -&gt; Image.Image:\n    \"\"\"Returns a black+red preview image, optimized for readability.\"\"\"\n\n    # 1. Copy black image\n    image_black = self.image_black.copy()\n\n    # 2. Optimize the colour layer first (cleans up anti-aliasing)\n    optimized_colour = self._optimize_for_red_preview(self.image_colour)\n\n    # 3. Convert darkened layer to red overlay\n    image_colour_red = self.color_to_red(optimized_colour)\n\n    # 4. Composite\n    image_black.paste(image_colour_red, (0, 0), image_colour_red)\n\n    logger.info(\"Preview image created (optimized black + red composite)\")\n    return image_black\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.get_text_width","title":"<code>get_text_width(text)</code>","text":"<p>Return the rendered width of a string using the current font.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to measure.</p> required <p>Returns:</p> Type Description <code>int</code> <p>int \u2014 Width in pixels.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def get_text_width(self, text: str) -&gt; int:\n    \"\"\"\n    Return the rendered width of a string using the current font.\n\n    Args:\n        text (str): The text to measure.\n\n    Returns:\n        int \u2014 Width in pixels.\n    \"\"\"\n    bbox = self._font.getbbox(text)\n    return int(bbox[2] - bbox[0])\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.set_font_size","title":"<code>set_font_size(font_size)</code>","text":"<p>Set the font size to use</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def set_font_size(self, font_size: int):\n    \"\"\"Set the font size to use\"\"\"\n    self._font_size = font_size\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.text_wrap","title":"<code>text_wrap(text, max_width)</code>","text":"<p>Split long text into wrapped lines using the Canvas' current font.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The full text to wrap.</p> required <code>max_width</code> <code>int</code> <p>Maximum pixel width allowed per line.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of strings, each representing one wrapped line.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def text_wrap(self, text: str, max_width: int) -&gt; list[str]:\n    \"\"\"\n    Split long text into wrapped lines using the Canvas' current font.\n\n    Args:\n        text: The full text to wrap.\n        max_width: Maximum pixel width allowed per line.\n\n    Returns:\n        A list of strings, each representing one wrapped line.\n    \"\"\"\n\n    font = self._font\n    words = text.split(\" \")\n    lines = []\n    current_line = \"\"\n\n    for word in words:\n        # Test candidate line\n        proposed = (current_line + \" \" + word).strip()\n\n        if font.getlength(proposed) &lt;= max_width:\n            # Word fits \u2014 extend current line\n            current_line = proposed\n        else:\n            # Word does not fit\n            if not current_line:\n                # Word itself too long: force-break\n                lines.append(word)\n            else:\n                # Push current line and start a new one\n                lines.append(current_line)\n                current_line = word\n\n    # Add final line\n    if current_line:\n        lines.append(current_line)\n\n    return lines\n</code></pre>"},{"location":"reference/#inkycal.utils.canvas.Canvas.write","title":"<code>write(xy, box_size, text, *, alignment='center', autofit=False, colour='black', rotation=None, fill_width=1.0, fill_height=0.8)</code>","text":"<pre><code>    Write (possibly multi-line) text inside a rectangle.\n    Supports '\n</code></pre> <p>' and auto-wrapping inside each line.</p> Source code in <code>inkycal/utils/canvas.py</code> <pre><code>def write(\n        self,\n        xy: Tuple[int, int],\n        box_size: Tuple[int, int],\n        text: str,\n        *,\n        alignment: Literal[\"center\", \"left\", \"right\"] = \"center\",\n        autofit: bool = False,\n        colour: Literal[\"black\", \"colour\"] = \"black\",\n        rotation: Optional[float] = None,\n        fill_width: float = 1.0,\n        fill_height: float = 0.8,\n) -&gt; None:\n    \"\"\"\n    Write (possibly multi-line) text inside a rectangle.\n    Supports '\\n' and auto-wrapping inside each line.\n    \"\"\"\n\n    box_x, box_y = xy\n    box_w, box_h = box_size\n\n    font_path = self.font_enum.value\n    font = self._font\n    size = self._font_size\n\n    # ----------------------------\n    # 1) Auto-fit the font size\n    # ----------------------------\n    if autofit or (fill_width != 1.0) or (fill_height != 0.8):\n        size = max(8, size)\n        while True:\n            font = _load_font(font_path, size)\n\n            # measure test height with 1-line sample\n            sample_h = font.getbbox(\"Ag\")[3] - font.getbbox(\"Ag\")[1]\n\n            if sample_h &gt;= int(box_h * fill_height):\n                if size &gt; 8:\n                    size -= 1\n                font = _load_font(font_path, size)\n                break\n\n            size += 1\n\n        self._font_size = size\n        self._font = font\n\n    # ----------------------------\n    # 2) Split text into logical lines\n    # ----------------------------\n    logical_lines = text.split(\"\\n\")\n\n    # ----------------------------\n    # 3) Wrap each line to the box width\n    # ----------------------------\n    wrapped_lines: list[str] = []\n    for line in logical_lines:\n        wrapped_lines.extend(self.text_wrap(line, max_width=int(box_w * fill_width)))\n\n    if not wrapped_lines:\n        return\n\n    # ----------------------------\n    # 4) Measure combined height\n    # ----------------------------\n    line_heights = []\n    total_h = 0\n\n    for line in wrapped_lines:\n        bbox = font.getbbox(line)\n        h = bbox[3] - bbox[1]\n        line_heights.append(h)\n        total_h += h\n\n    # add minimal line spacing (you can tune this)\n    line_spacing = int(font.size * 0.2)\n    total_h += line_spacing * (len(wrapped_lines) - 1)\n\n    # If text block too tall \u2192 truncate bottom lines\n    while total_h &gt; box_h and wrapped_lines:\n        removed = wrapped_lines.pop()\n        removed_h = line_heights.pop()\n        total_h -= (removed_h + line_spacing)\n\n    if not wrapped_lines:\n        return\n\n    # ----------------------------\n    # 5) Vertical centering\n    # ----------------------------\n    cy = box_y + (box_h - total_h) // 2\n\n    # ----------------------------\n    # 6) Create transparent layer and draw lines\n    # ----------------------------\n    space = Image.new(\"RGBA\", (box_w, box_h), (0, 0, 0, 0))\n    draw = ImageDraw.Draw(space)\n\n    py = 0\n    for line, lh in zip(wrapped_lines, line_heights):\n\n        # horizontal alignment\n        line_w = font.getbbox(line)[2] - font.getbbox(line)[0]\n\n        if alignment == \"center\":\n            px = (box_w - line_w) // 2\n        elif alignment == \"left\":\n            px = 0\n        elif alignment == \"right\":\n            px = box_w - line_w\n        else:\n            px = (box_w - line_w) // 2\n\n        draw.text((px, py), line, fill=\"black\", font=font)\n        py += lh + line_spacing\n\n    # ----------------------------\n    # 7) Rotation + paste\n    # ----------------------------\n    if rotation:\n        space = space.rotate(rotation, expand=True)\n\n    # Always draw on black first\n    self.image_black.paste(space, xy, space)\n\n    # Colour overlay if needed\n    if colour == \"colour\":\n        self.image_colour.paste(space, xy, space)\n</code></pre>"},{"location":"reference/#utility-functions","title":"\ud83d\udd27 Utility Functions","text":""},{"location":"reference/#general-utils","title":"General Utils","text":"<p>Utility Functions for Inkycal</p> <p>This module contains small standalone helpers used throughout the Inkycal framework. These functions handle tasks such as timezone detection, network availability checks, simple drawing helpers, and generating lightweight charts.</p> <p>These utilities are intentionally framework-agnostic and can be used inside modules, during setup, or anywhere Inkycal requires common functionality.</p>"},{"location":"reference/#inkycal.utils.functions.draw_border","title":"<code>draw_border(image, xy, size, radius=5, thickness=1, shrinkage=(0.1, 0.1))</code>","text":"<p>Draw a stylized border around a rectangular region.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The PIL image into which the border is drawn.</p> required <code>xy</code> <code>Tuple[int, int]</code> <p>Top-left corner of the border (x, y).</p> required <code>size</code> <code>Tuple[int, int]</code> <p>Width and height of the border before shrinkage is applied.</p> required <code>radius</code> <code>int</code> <p>Corner roundness. <code>0</code> creates a rectangle with sharp corners.</p> <code>5</code> <code>thickness</code> <code>int</code> <p>Stroke width in pixels.</p> <code>1</code> <code>shrinkage</code> <code>Tuple[float, float]</code> <p>Proportional shrinkage of width and height. For example: <code>(0.1, 0.2)</code> \u2192 shrink width by 10% and height by 20%.</p> <code>(0.1, 0.1)</code> Notes <p>This function is used by various modules (Calendar, Agenda, Feeds) to visually highlight areas such as days with events.</p> Source code in <code>inkycal/utils/functions.py</code> <pre><code>def draw_border(\n    image: Image.Image,\n    xy: Tuple[int, int],\n    size: Tuple[int, int],\n    radius: int = 5,\n    thickness: int = 1,\n    shrinkage: Tuple[float, float] = (0.1, 0.1),\n) -&gt; None:\n    \"\"\"Draw a stylized border around a rectangular region.\n\n    Args:\n        image (PIL.Image.Image):\n            The PIL image into which the border is drawn.\n\n        xy (Tuple[int, int]):\n            Top-left corner of the border (x, y).\n\n        size (Tuple[int, int]):\n            Width and height of the border before shrinkage is applied.\n\n        radius (int, optional):\n            Corner roundness. ``0`` creates a rectangle with sharp corners.\n\n        thickness (int, optional):\n            Stroke width in pixels.\n\n        shrinkage (Tuple[float, float], optional):\n            Proportional shrinkage of width and height. For example:\n            ``(0.1, 0.2)`` \u2192 shrink width by 10% and height by 20%.\n\n    Notes:\n        This function is used by various modules (Calendar, Agenda, Feeds)\n        to visually highlight areas such as days with events.\n    \"\"\"\n\n    colour = \"black\"\n\n    # Apply shrinkage to box size\n    width = int(size[0] * (1 - shrinkage[0]))\n    height = int(size[1] * (1 - shrinkage[1]))\n\n    # Center correction\n    offset_x = int((size[0] - width) / 2)\n    offset_y = int((size[1] - height) / 2)\n\n    x = xy[0] + offset_x\n    y = xy[1] + offset_y\n    diameter = radius * 2\n\n    # Core rectangle parameters\n    a = width - diameter\n    b = height - diameter\n\n    # Straight line segments\n    p1, p2 = (x + radius, y), (x + radius + a, y)\n    p3, p4 = (x + width, y + radius), (x + width, y + radius + b)\n    p5, p6 = (p2[0], y + height), (p1[0], y + height)\n    p7, p8 = (x, p4[1]), (x, p3[1])\n\n    draw = ImageDraw.Draw(image)\n    draw.line((p1, p2), fill=colour, width=thickness)\n    draw.line((p3, p4), fill=colour, width=thickness)\n    draw.line((p5, p6), fill=colour, width=thickness)\n    draw.line((p7, p8), fill=colour, width=thickness)\n\n    # Rounded corners\n    if radius &gt; 0:\n        c1, c2 = (x, y), (x + diameter, y + diameter)\n        c3, c4 = (x + width - diameter, y), (x + width, y + diameter)\n        c5, c6 = (x + width - diameter, y + height - diameter), (x + width, y + height)\n        c7, c8 = (x, y + height - diameter), (x + diameter, y + height)\n\n        draw.arc((c1, c2), 180, 270, fill=colour, width=thickness)\n        draw.arc((c3, c4), 270, 360, fill=colour, width=thickness)\n        draw.arc((c5, c6), 0, 90, fill=colour, width=thickness)\n        draw.arc((c7, c8), 90, 180, fill=colour, width=thickness)\n</code></pre>"},{"location":"reference/#inkycal.utils.functions.draw_border_2","title":"<code>draw_border_2(im, xy, size, radius)</code>","text":"<p>Draw a simple rounded rectangle border using Pillow's high-level API.</p> Source code in <code>inkycal/utils/functions.py</code> <pre><code>def draw_border_2(im: Image.Image, xy: Tuple[int, int], size: Tuple[int, int], radius: int):\n    \"\"\"Draw a simple rounded rectangle border using Pillow's high-level API.\"\"\"\n    draw = ImageDraw.Draw(im)\n    x, y = xy\n    w, h = size\n    draw.rounded_rectangle((x, y, x + w, y + h), outline=\"black\", radius=radius)\n</code></pre>"},{"location":"reference/#inkycal.utils.functions.get_system_tz","title":"<code>get_system_tz()</code>","text":"<p>Return the system's timezone as a string.</p> <p>Attempts to detect the local timezone using <code>tzlocal</code>. If detection fails, the function falls back to <code>\"UTC\"</code> and logs a warning.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The detected timezone name. Examples include: - <code>\"Europe/Berlin\"</code> - <code>\"America/New_York\"</code> - <code>\"UTC\"</code> (fallback)</p> Example <p>arrow.now(tz=get_system_tz())  Source code in <code>inkycal/utils/functions.py</code> <pre><code>def get_system_tz() -&gt; str:\n    \"\"\"Return the system's timezone as a string.\n\n    Attempts to detect the local timezone using ``tzlocal``. If detection fails,\n    the function falls back to ``\"UTC\"`` and logs a warning.\n\n    Returns:\n        str: The detected timezone name. Examples include:\n            - ``\"Europe/Berlin\"``\n            - ``\"America/New_York\"``\n            - ``\"UTC\"`` (fallback)\n\n    Example:\n        &gt;&gt;&gt; arrow.now(tz=get_system_tz())\n        &lt;Arrow [2025-02-18T12:34:56+01:00]&gt;\n    \"\"\"\n    try:\n        local_tz = tzlocal.get_localzone().key\n        logger.debug(f\"Local system timezone is {local_tz}.\")\n    except Exception:\n        logger.error(\"System timezone could not be parsed! Falling back to UTC.\")\n        local_tz = \"UTC\"\n\n    # Log formatted current time in detected TZ\n    logger.debug(\n        f\"Current time: {arrow.now(tz=local_tz).format('YYYY-MM-DD HH:mm:ss ZZ')}\"\n    )\n    return local_tz\n</code></pre>"},{"location":"reference/#inkycal.utils.functions.internet_available","title":"<code>internet_available()</code>","text":"<p>Check whether the internet connection is reachable.</p> <p>The function attempts 3 connections to <code>https://google.com</code> with a short timeout. If any request succeeds, the network is considered available.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if at least one connection attempt succeeds, otherwise</p> <code>bool</code> <p><code>False</code>.</p> Example <p>if internet_available(): ...     print(\"Online!\") ... else: ...     print(\"Offline!\")</p> Source code in <code>inkycal/utils/functions.py</code> <pre><code>def internet_available() -&gt; bool:\n    \"\"\"Check whether the internet connection is reachable.\n\n    The function attempts 3 connections to ``https://google.com`` with a short\n    timeout. If any request succeeds, the network is considered available.\n\n    Returns:\n        bool: ``True`` if at least one connection attempt succeeds, otherwise\n        ``False``.\n\n    Example:\n        &gt;&gt;&gt; if internet_available():\n        ...     print(\"Online!\")\n        ... else:\n        ...     print(\"Offline!\")\n    \"\"\"\n    for attempt in range(3):\n        try:\n            requests.get(\"https://google.com\", timeout=5)\n            return True\n        except Exception:\n            print(f\"Network could not be reached: {traceback.print_exc()}\")\n            time.sleep(5)\n\n    return False\n</code></pre>"},{"location":"reference/#inkycal.utils.functions.render_line_chart","title":"<code>render_line_chart(values, size, line_width=2, line_color='black', bg_color='white', padding=4)</code>","text":"<p>Render a lightweight line chart using Pillow.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[float]</code> <p>A list/tuple of numeric values to plot. Must contain at least 2 points to draw a line.</p> required <code>size</code> <code>Tuple[int, int]</code> <p>Output image size <code>(width, height)</code>.</p> required <code>line_width</code> <code>int</code> <p>Thickness of the plotted line.</p> <code>2</code> <code>line_color</code> <code>str or tuple</code> <p>Colour of the line. Accepts any Pillow colour value.</p> <code>'black'</code> <code>bg_color</code> <code>str or tuple</code> <p>Background colour.</p> <code>'white'</code> <code>padding</code> <code>int</code> <p>Inner padding in pixels (space to chart edges).</p> <code>4</code> <p>Returns:</p> Type Description <code>Image</code> <p>PIL.Image.Image: A new image containing the rendered chart.</p> Notes <ul> <li>Scaling is automatically normalized between min(values) and   max(values).</li> <li>Used primarily by the Stocks module.</li> </ul> Example <p>img = render_line_chart([1, 3, 2, 5], (200, 80)) img.show()</p> Source code in <code>inkycal/utils/functions.py</code> <pre><code>def render_line_chart(\n    values: Sequence[float],\n    size: Tuple[int, int],\n    line_width: int = 2,\n    line_color=\"black\",\n    bg_color=\"white\",\n    padding: int = 4\n) -&gt; Image.Image:\n    \"\"\"Render a lightweight line chart using Pillow.\n\n    Args:\n        values (Sequence[float]):\n            A list/tuple of numeric values to plot. Must contain at least 2\n            points to draw a line.\n\n        size (Tuple[int, int]):\n            Output image size ``(width, height)``.\n\n        line_width (int, optional):\n            Thickness of the plotted line.\n\n        line_color (str or tuple, optional):\n            Colour of the line. Accepts any Pillow colour value.\n\n        bg_color (str or tuple, optional):\n            Background colour.\n\n        padding (int, optional):\n            Inner padding in pixels (space to chart edges).\n\n    Returns:\n        PIL.Image.Image:\n            A new image containing the rendered chart.\n\n    Notes:\n        - Scaling is automatically normalized between min(values) and\n          max(values).\n        - Used primarily by the Stocks module.\n\n    Example:\n        &gt;&gt;&gt; img = render_line_chart([1, 3, 2, 5], (200, 80))\n        &gt;&gt;&gt; img.show()\n    \"\"\"\n\n    width, height = size\n    img = Image.new(\"RGBA\", (width, height), bg_color)\n    draw = ImageDraw.Draw(img)\n\n    if not values or len(values) &lt; 2:\n        return img  # nothing to draw\n\n    v_min = min(values)\n    v_max = max(values)\n\n    # Avoid division by zero for flat datasets\n    if math.isclose(v_min, v_max):\n        v_min -= 1.0\n        v_max += 1.0\n\n    inner_w = max(1, width - 2 * padding)\n    inner_h = max(1, height - 2 * padding)\n\n    def to_xy(idx: int, val: float, n: int):\n        \"\"\"Transform a value into canvas coordinates.\"\"\"\n        # X: evenly spaced\n        x = padding + (inner_w * idx) / (n - 1) if n &gt; 1 else padding + inner_w / 2\n\n        # Y: inverted because (0,0) is top-left\n        norm = (val - v_min) / (v_max - v_min)\n        y = padding + inner_h * (1.0 - norm)\n\n        return x, y\n\n    n = len(values)\n    pts = [to_xy(i, float(v), n) for i, v in enumerate(values)]\n\n    draw.line(pts, fill=line_color, width=line_width)\n\n    return img\n</code></pre>"},{"location":"reference/#enumerations-fonts-settings","title":"Enumerations (fonts, settings)","text":"<p>enums.py</p>"},{"location":"reference/#supported-display-models","title":"Supported Display Models","text":""},{"location":"reference/#summary","title":"\ud83c\udfc1 Summary","text":"<p>This API reference is meant as a central index for:</p> <ul> <li>All modules  </li> <li>Rendering engine (Canvas)  </li> <li>ePaper Display driver  </li> <li>Utilities  </li> </ul> <p>If you are developing your own module, be sure to check:</p> <ul> <li><code>template.py</code> </li> <li>Developer Guide (<code>dev_doc.md</code>)  </li> <li>Canvas documentation (<code>canvas.md</code>)  </li> </ul>"},{"location":"api/canvas/","title":"Canvas API","text":"<p>The <code>Canvas</code> class is the core drawing utility in Inkycal. Every module generates its visual output using a <code>Canvas</code> instance, which provides:</p> <ul> <li>High-level text rendering (<code>write()</code>)</li> <li>Automatic text wrapping</li> <li>Automatic font scaling</li> <li>Icon rendering with pixel-accurate centering</li> <li>Preview rendering (black + red composite)</li> <li>Helper utilities for borders, sizing, and layout</li> </ul> <p>This document describes the full public API of the <code>Canvas</code> class.</p>"},{"location":"api/canvas/#overview","title":"Overview","text":"<p>A <code>Canvas</code> maintains two separate Pillow images:</p> <ul> <li><code>image_black</code> \u2192 The black layer  </li> <li><code>image_colour</code> \u2192 The colour layer (used for red pixels on supported displays)</li> </ul> <p>Each <code>write()</code> or <code>draw_icon()</code> operation may write to one or both layers, depending on the <code>colour</code> parameter.</p>"},{"location":"api/canvas/#creating-a-canvas","title":"Creating a Canvas","text":"<pre><code>from inkycal.utils.canvas import Canvas\nfrom inkycal.utils.enums import FONTS\n\ncanvas = Canvas(\n    im_size=(800, 480),\n    font=FONTS.default,\n    font_size=24\n)\n</code></pre>"},{"location":"api/canvas/#class-reference","title":"Class Reference","text":""},{"location":"api/canvas/#canvas__init__im_size-font-font_size","title":"<code>Canvas.__init__(im_size, font, font_size)</code>","text":"<p>Initializes a drawing context.</p> Parameter Type Description <code>im_size</code> tuple(int, int) (width, height) of the canvas <code>font</code> <code>FONTS</code> enum Default font to use <code>font_size</code> int Initial font size <p>Creates two internal images:</p> <ul> <li><code>image_black</code></li> <li><code>image_colour</code></li> </ul> <p>Both begin as white RGB canvases.</p>"},{"location":"api/canvas/#writexy-box_size-text","title":"<code>write(xy, box_size, text, ...)</code>","text":"<p>High-level function to draw single-line or multi-line text inside a bounding box.</p>"},{"location":"api/canvas/#supports","title":"Supports:","text":"<ul> <li><code>\\n</code> manual line breaks  </li> <li>Automatic line breaking (<code>text_wrap</code>)  </li> <li>Automatic font scaling (<code>autofit=True</code>)  </li> <li>Vertical + horizontal centering  </li> <li>Rotated text  </li> <li>Colour or black rendering  </li> </ul>"},{"location":"api/canvas/#signature","title":"Signature","text":"<pre><code>write(\n    xy: Tuple[int, int],\n    box_size: Tuple[int, int],\n    text: str,\n    *,\n    alignment: Literal[\"center\", \"left\", \"right\"] = \"center\",\n    autofit: bool = False,\n    colour: Literal[\"black\", \"colour\"] = \"black\",\n    rotation: Optional[float] = None,\n    fill_width: float = 1.0,\n    fill_height: float = 0.8,\n)\n</code></pre>"},{"location":"api/canvas/#example","title":"Example","text":"<pre><code>canvas.write(\n    xy=(20, 20),\n    box_size=(200, 80),\n    text=\"Hello World\",\n    autofit=True,\n    alignment=\"center\",\n)\n</code></pre>"},{"location":"api/canvas/#text_wraptext-max_width","title":"<code>text_wrap(text, max_width)</code>","text":"<p>Splits text into a list of wrapped lines based on rendered pixel width.</p> <pre><code>lines = canvas.text_wrap(\"some long text\", max_width=180)\n</code></pre> <p>This is used internally by <code>write()</code> but may also be useful when building complex layouts.</p>"},{"location":"api/canvas/#auto_fontsizemax_height-sample_textag-target_ratio08","title":"<code>auto_fontsize(max_height, sample_text=\"Ag\", target_ratio=0.8)</code>","text":"<p>Automatically increases font size until the rendered height of a sample string reaches a ratio of the bounding height.</p> <p>Used internally by <code>write(autofit=True)</code>.</p>"},{"location":"api/canvas/#get_line_heightsample_textag","title":"<code>get_line_height(sample_text=\"Ag\")</code>","text":"<p>Returns the true pixel height (ascent + descent) of the active font.</p> <p>This is extremely useful for:</p> <ul> <li>Vertical spacing</li> <li>Multi-line layouts</li> <li>Event list rendering</li> <li>Calendar modules</li> </ul> <p>Example:</p> <pre><code>line_height = canvas.get_line_height()\n</code></pre>"},{"location":"api/canvas/#get_text_widthtext","title":"<code>get_text_width(text)</code>","text":"<p>Returns the width in pixels of the given text using the current font.</p>"},{"location":"api/canvas/#icon-rendering","title":"Icon Rendering","text":""},{"location":"api/canvas/#draw_iconxy-box_size-icon","title":"<code>draw_icon(xy, box_size, icon, ...)</code>","text":"<p>Draws a weather icon or glyph centered inside a bounding box.</p>"},{"location":"api/canvas/#features","title":"Features:","text":"<ul> <li>Pixel-accurate centering via alpha analysis  </li> <li>Automatic icon sizing (<code>fill_ratio</code>)  </li> <li>Optionally writes to colour layer  </li> <li>Supports rotation  </li> </ul>"},{"location":"api/canvas/#signature_1","title":"Signature","text":"<pre><code>draw_icon(\n    xy: Tuple[int, int],\n    box_size: Tuple[int, int],\n    icon: str,\n    colour: Literal[\"black\", \"colour\"] = \"black\",\n    rotation: Optional[float] = None,\n    fill_ratio: float = 0.90,\n    font: Optional[FONTS] = None,\n)\n</code></pre> <p>Example:</p> <pre><code>canvas.draw_icon(\n    xy=(100, 100),\n    box_size=(80, 80),\n    icon=\"\\uf00d\",\n    colour=\"colour\"\n)\n</code></pre> <p>This is used heavily in the Weather module.</p>"},{"location":"api/canvas/#preview-rendering","title":"Preview Rendering","text":"<p>The preview system converts the internal black + colour layers into a pure black + red composite image for display in the WebUI or debugging.</p>"},{"location":"api/canvas/#_optimize_for_red_previewimg","title":"<code>_optimize_for_red_preview(img)</code>","text":"<p>Internal cleanup step that removes grey pixels introduced by anti-aliasing.</p> <p>You should not call this manually.</p>"},{"location":"api/canvas/#color_to_redimg","title":"<code>color_to_red(img)</code>","text":"<p>Converts all dark pixels in the colour layer to pure red with alpha transparency, used by the preview generator.</p>"},{"location":"api/canvas/#get_preview_image","title":"<code>get_preview_image()</code>","text":"<p>Returns a composite image where:</p> <ul> <li><code>image_black</code> = black base</li> <li><code>image_colour</code> = converted to red overlay</li> <li>Both layers are merged</li> </ul> <p>Used by:</p> <ul> <li>The WebUI  </li> <li>Debug output  </li> <li>Local previews  </li> </ul> <pre><code>preview = canvas.get_preview_image()\npreview.show()\n</code></pre>"},{"location":"api/canvas/#properties","title":"Properties","text":""},{"location":"api/canvas/#canvasimage_black","title":"<code>Canvas.image_black</code>","text":"<p>A Pillow <code>RGB</code> image containing all black-layer content.</p>"},{"location":"api/canvas/#canvasimage_colour","title":"<code>Canvas.image_colour</code>","text":"<p>A Pillow <code>RGB</code> image containing all colour-layer content (will appear red on preview or e-paper).</p>"},{"location":"api/canvas/#canvasfont","title":"<code>Canvas.font</code>","text":"<p>Current font enum (type <code>FONTS</code>).</p>"},{"location":"api/canvas/#canvasfont_size","title":"<code>Canvas.font_size</code>","text":"<p>Current font size.</p>"},{"location":"api/canvas/#canvassize","title":"<code>Canvas.size</code>","text":"<p>Returns the full <code>(width, height)</code> of the canvas.</p>"},{"location":"api/canvas/#when-to-use-canvas","title":"When to Use Canvas","text":"<p>Use Canvas whenever your module needs to:</p>"},{"location":"api/canvas/#render-text","title":"\u2714 Render text","text":""},{"location":"api/canvas/#draw-icons","title":"\u2714 Draw icons","text":""},{"location":"api/canvas/#draw-calendar-grids","title":"\u2714 Draw calendar grids","text":""},{"location":"api/canvas/#generate-multi-column-layouts","title":"\u2714 Generate multi-column layouts","text":""},{"location":"api/canvas/#render-a-chart-or-image-annotation","title":"\u2714 Render a chart or image annotation","text":""},{"location":"api/canvas/#produce-a-composite-preview","title":"\u2714 Produce a composite preview","text":""},{"location":"api/canvas/#handle-black-red-layer-separation","title":"\u2714 Handle black + red layer separation","text":"<p>The Canvas class abstracts away:</p> <ul> <li>Pixel-level centering  </li> <li>Font sizing  </li> <li>Text wrapping  </li> <li>Dual-layer rendering  </li> <li>Red preview logic  </li> </ul> <p>So module authors can focus purely on layout and content.</p>"},{"location":"api/canvas/#example-building-a-module-with-canvas","title":"Example: Building a Module with Canvas","text":"<pre><code>class HelloWorld(InkycalModule):\n    def generate_image(self):\n\n        canvas = Canvas(\n            im_size=(self.width, self.height),\n            font=self.font,\n            font_size=self.fontsize\n        )\n\n        canvas.write(\n            xy=(0, 0),\n            box_size=(self.width, 100),\n            text=\"Hello World!\",\n            autofit=True,\n            alignment=\"center\"\n        )\n\n        return canvas.image_black, canvas.image_colour\n</code></pre>"},{"location":"api/canvas/#summary","title":"Summary","text":"<p>The <code>Canvas</code> class is the core drawing abstraction for Inkycal. It provides everything needed for:</p> <ul> <li>Text rendering  </li> <li>Wrapping  </li> <li>Automatic font fitting  </li> <li>Clean black/colour separation  </li> <li>Accurate icon rendering  </li> <li>Red preview generation  </li> </ul> <p>Most modules rely heavily on Canvas \u2014 understanding it unlocks the ability to create rich visual layouts.</p>"},{"location":"api/display/","title":"Display API","text":"<p>The <code>Display</code> class is the low-level interface responsible for communicating with the selected ePaper display driver. Every time Inkycal generates an image, the <code>Display</code> class handles:</p> <ul> <li>Initializing the hardware  </li> <li>Sending the black/colour image buffers  </li> <li>Triggering a display refresh  </li> <li>Putting the display into deep sleep  </li> <li>Running calibration cycles when requested  </li> </ul> <p>This document describes the full API of the <code>Display</code> class and how to use it safely.</p>"},{"location":"api/display/#overview","title":"Overview","text":"<p>A <code>Display</code> instance corresponds to one specific ePaper model, chosen by the user in their <code>settings.json</code>.</p> <p>Internally:</p> <ul> <li>Each model corresponds to a driver in <code>inkycal/display/drivers/&lt;model&gt;.py</code></li> <li>Each driver exposes an <code>EPD()</code> class</li> <li>Inkycal automatically loads the correct driver using <code>import_driver()</code></li> </ul> <p>You never need to import drivers manually \u2014 only the <code>Display</code> class.</p>"},{"location":"api/display/#creating-a-display","title":"Creating a Display","text":"<pre><code>from inkycal.display import Display\n\ndisplay = Display(\"waveshare_7in5_colour\")\n</code></pre> <p>If the model name exists in <code>supported_models</code>, the display initializes successfully.</p> <p>If not, you will see:</p> <pre><code>Exception: This module is not supported. Check your spellings?\n</code></pre> <p>Or if SPI is unavailable:</p> <pre><code>Exception: SPI could not be found. Please check if SPI is enabled\n</code></pre>"},{"location":"api/display/#constructor","title":"Constructor","text":""},{"location":"api/display/#displayepaper_model","title":"<code>Display(epaper_model)</code>","text":"<p>Initializes an ePaper driver for the selected model.</p>"},{"location":"api/display/#parameters","title":"Parameters","text":"Name Type Description <code>epaper_model</code> str A supported model name from <code>supported_models</code>"},{"location":"api/display/#behaviour","title":"Behaviour","text":"<ul> <li>Determines whether the display supports a colour layer   (<code>supports_colour = True/False</code>)</li> <li>Dynamically imports the correct driver module</li> <li>Instantiates its <code>EPD()</code> class</li> </ul>"},{"location":"api/display/#methods","title":"Methods","text":""},{"location":"api/display/#renderim_black-im_colournone","title":"<code>render(im_black, im_colour=None)</code>","text":"<p>Renders an image onto the ePaper display.</p> <p>This is the primary interface used by Inkycal\u2019s runtime, and by you when debugging.</p>"},{"location":"api/display/#parameters_1","title":"Parameters","text":"Name Type Required? Description <code>im_black</code> <code>PIL.Image</code> required Black layer image. Black pixels = black ink. <code>im_colour</code> <code>PIL.Image</code> required on colour displays Colour layer image. Black pixels = red/yellow ink."},{"location":"api/display/#behaviour_1","title":"Behaviour","text":"<ol> <li>Calls <code>epaper.init()</code></li> <li>Converts images to the display\u2019s internal buffer using <code>getbuffer()</code></li> <li>Sends output via <code>epaper.display(...)</code></li> <li>Sends display to deep sleep via <code>epaper.sleep()</code></li> </ol>"},{"location":"api/display/#example-black-white-display","title":"Example \u2014 black &amp; white display","text":"<pre><code>from PIL import Image\nfrom inkycal.display import Display\n\nimg = Image.open(\"hello.png\")\ndisplay = Display(\"waveshare_7in5\")\ndisplay.render(img)\n</code></pre>"},{"location":"api/display/#example-colour-display","title":"Example \u2014 colour display","text":"<pre><code>black = Image.open(\"black.png\")\ncolour = Image.open(\"colour.png\")\n\ndisplay = Display(\"waveshare_7in5_colour\")\ndisplay.render(black, colour)\n</code></pre>"},{"location":"api/display/#calibratecycles3","title":"<code>calibrate(cycles=3)</code>","text":"<p>Flushes the display through several full-colour cycles to remove ghosting artifacts.</p> <p>Strongly recommended on both BW and colour displays.</p>"},{"location":"api/display/#parameters_2","title":"Parameters","text":"Name Type Description <code>cycles</code> int Number of flush cycles (3 default)"},{"location":"api/display/#behaviour_2","title":"Behaviour","text":""},{"location":"api/display/#on-colour-displays","title":"On colour displays:","text":"<pre><code>black \u2192 colour \u2192 white\n(repeat cycles times)\n</code></pre>"},{"location":"api/display/#on-bw-displays","title":"On BW displays:","text":"<pre><code>black \u2192 white\n(repeat cycles times)\n</code></pre> <p>\u26a0\ufe0f Calibration can take 10\u201320 minutes depending on model.</p>"},{"location":"api/display/#example","title":"Example","text":"<pre><code>display = Display(\"waveshare_7in5_colour\")\ndisplay.calibrate(cycles=2)\n</code></pre>"},{"location":"api/display/#get_display_sizemodel_name","title":"<code>get_display_size(model_name)</code>","text":"<p>Returns the model's width and height in pixels.</p>"},{"location":"api/display/#example_1","title":"Example","text":"<pre><code>w, h = Display.get_display_size(\"waveshare_7in5\")\nprint(w, h)  # e.g.: 640 384\n</code></pre> <p>Raises:</p> <pre><code>AssertionError: model_name not found in supported models\n</code></pre>"},{"location":"api/display/#get_display_names","title":"<code>get_display_names()</code>","text":"<p>Returns a list of all officially supported ePaper models.</p> <pre><code>print(Display.get_display_names())\n</code></pre> <p>Useful when building UI components or validating configuration.</p>"},{"location":"api/display/#render_texttext-font_size24-max_width_ratio095","title":"<code>render_text(text, font_size=24, max_width_ratio=0.95)</code>","text":"<p>Utility method for quick debugging: Renders centered text to the display without needing to manually create images.</p> <p>Great for troubleshooting:</p> <pre><code>Display(\"waveshare_7in5\").render_text(\"Hello world!\")\n</code></pre> <p>Features:</p> <ul> <li>Automatic text wrapping</li> <li>Centered alignment</li> <li>Uses Pillow \u2265 10 APIs (<code>textbbox</code>)</li> <li>Works on both BW and colour displays</li> </ul>"},{"location":"api/display/#internal-mechanics","title":"Internal Mechanics","text":""},{"location":"api/display/#driver-system","title":"Driver System","text":"<p>Every display driver resides in:</p> <pre><code>inkycal/display/drivers/&lt;model&gt;.py\n</code></pre> <p>Each driver must implement:</p> <pre><code>class EPD:\n    def init(self): ...\n    def display(self, *buffers): ...\n    def getbuffer(self, image): ...\n    def sleep(self): ...\n</code></pre> <p>The model names exported in:</p> <pre><code>inkycal/display/supported_models.py\n</code></pre> <p>control which models users may select.</p>"},{"location":"api/display/#dual-layer-rendering","title":"Dual-Layer Rendering","text":"<p>Internally, Inkycal modules output:</p> <ul> <li><code>image_black</code> \u2192 black pixels  </li> <li><code>image_colour</code> \u2192 coloured pixels</li> </ul> <p>The display class does not interpret these \u2014 it only passes the bitmaps to the driver.</p>"},{"location":"api/display/#when-to-use-display","title":"When to Use Display","text":"<p>You should use the <code>Display</code> class when:</p>"},{"location":"api/display/#testing-your-screen","title":"\u2714 Testing your screen","text":"<pre><code>display.render_text(\"Testing E-Paper...\")\n</code></pre>"},{"location":"api/display/#sending-final-module-output","title":"\u2714 Sending final module output","text":"<pre><code>black, colour = module.generate_image()\ndisplay.render(black, colour)\n</code></pre>"},{"location":"api/display/#fixing-ghosting","title":"\u2714 Fixing ghosting","text":"<pre><code>display.calibrate(3)\n</code></pre>"},{"location":"api/display/#typical-workflow-in-inkycal","title":"Typical Workflow in Inkycal","text":"<ol> <li>User selects a model in settings.json</li> <li>Inkycal loads <code>Display(model)</code></li> <li>All modules generate images (<code>image_black</code>, <code>image_colour</code>)</li> <li>Inkycal calls <code>display.render()</code></li> <li>Display updates, then sleeps</li> </ol>"},{"location":"api/display/#summary","title":"Summary","text":"<p>The <code>Display</code> class is the hardware abstraction layer for Inkycal.</p> <p>It provides:</p> <ul> <li>Dynamic driver loading  </li> <li>Black &amp; colour image rendering  </li> <li>Calibration routines  </li> <li>Text debugging utilities  </li> <li>Display resolution lookup  </li> </ul> <p>Most module authors never need to touch the display logic directly, but understanding it makes debugging dramatically easier.</p>"},{"location":"api/utils/","title":"\ud83e\uddf0 Inkycal Utility API (<code>inkycal.utils</code>)","text":"<p>This page documents the helper functions and utilities available under:</p> <pre><code>inkycal/utils/\n</code></pre> <p>These tools are used internally by Inkycal\u2019s modules and are also available for third-party module developers.</p>"},{"location":"api/utils/#module-overview","title":"\ud83d\udcda Module Overview","text":"<p>The <code>inkycal.utils</code> package contains:</p> Submodule Purpose <code>functions.py</code> Timezone detection, internet checks, drawing helpers <code>canvas.py</code> High-level text &amp; icon rendering (documented separately in <code>canvas.md</code>) <code>enums.py</code> Font enumeration and font paths <code>ical_parser.py</code> Event parsing from <code>.ics</code> files <code>...</code> Additional helpers depending on version <p>This page focuses on <code>functions.py</code>, the general-purpose utility helpers.</p>"},{"location":"api/utils/#get_system_tz","title":"\u23f1\ufe0f <code>get_system_tz()</code>","text":"<pre><code>from inkycal.utils.functions import get_system_tz\ntz = get_system_tz()\n</code></pre> <p>Returns the system's configured timezone name, using <code>tzlocal</code>.</p>"},{"location":"api/utils/#behaviour","title":"\ud83d\udca1 Behaviour","text":"<ul> <li>If the system timezone can be detected \u2192 returns e.g. <code>\"Europe/Berlin\"</code>.</li> <li>If detection fails \u2192 logs warning and falls back to <code>\"UTC\"</code>.</li> </ul>"},{"location":"api/utils/#example","title":"Example","text":"<pre><code>import arrow\nfrom inkycal.utils.functions import get_system_tz\n\nnow_local = arrow.now(tz=get_system_tz())\n</code></pre>"},{"location":"api/utils/#internet_available","title":"\ud83c\udf10 <code>internet_available()</code>","text":"<pre><code>from inkycal.utils.functions import internet_available\n</code></pre> <p>Checks whether an outbound connection to the internet can be made.</p>"},{"location":"api/utils/#behaviour_1","title":"\ud83d\udd0d Behaviour","text":"<ul> <li>Tries 3 attempts</li> <li>Requests <code>https://google.com</code></li> <li>Each attempt times out after 5 seconds</li> <li>Returns:</li> </ul> Internet status Function returns reachable \u2714 <code>True</code> unreachable \u2718 <code>False</code>"},{"location":"api/utils/#example_1","title":"Example","text":"<pre><code>if internet_available():\n    print(\"We have internet!\")\nelse:\n    print(\"No internet connection.\")\n</code></pre>"},{"location":"api/utils/#drawing-helpers","title":"\ud83d\udce6 Drawing Helpers","text":"<p>These helpers are used when you need custom geometric shapes outside of the <code>Canvas</code> API.</p>"},{"location":"api/utils/#draw_borderimage-xy-size-radius5-thickness1-shrinkage01-01","title":"\ud83d\uddbc\ufe0f <code>draw_border(image, xy, size, radius=5, thickness=1, shrinkage=(0.1, 0.1))</code>","text":"<p>Draws a rounded rectangle border on a Pillow image.</p>"},{"location":"api/utils/#arguments","title":"Arguments","text":"Name Type Meaning <code>image</code> <code>PIL.Image</code> Image on which to draw <code>xy</code> <code>(x, y)</code> Top-left position <code>size</code> <code>(width, height)</code> Border size <code>radius</code> <code>int</code> Corner roundness <code>thickness</code> <code>int</code> Stroke width <code>shrinkage</code> <code>(x%, y%)</code> Amount to shrink border inward"},{"location":"api/utils/#example_2","title":"Example","text":"<pre><code>from inkycal.utils.functions import draw_border\nfrom PIL import Image\n\nimg = Image.new(\"RGB\", (200, 100), \"white\")\n\ndraw_border(\n    image=img,\n    xy=(10, 10),\n    size=(180, 80),\n    radius=8,\n    thickness=2\n)\n</code></pre> <p>This function is used by modules such as the Calendar to highlight special days.</p>"},{"location":"api/utils/#draw_border_2image-xy-size-radius","title":"\ud83d\udfe5 <code>draw_border_2(image, xy, size, radius)</code>","text":"<p>A simpler variant using Pillow\u2019s <code>rounded_rectangle</code>.</p> <p>Example:</p> <pre><code>draw_border_2(image, (10,10), (200,50), radius=6)\n</code></pre>"},{"location":"api/utils/#render_line_chartvalues-size-line_width2-line_colorblack-bg_colorwhite-padding4","title":"\ud83d\udcca <code>render_line_chart(values, size, line_width=2, line_color=\"black\", bg_color=\"white\", padding=4)</code>","text":"<p>Renders a simple polyline chart using Pillow.</p>"},{"location":"api/utils/#arguments_1","title":"Arguments","text":"Name Type Description <code>values</code> list of numbers Data points <code>size</code> <code>(w, h)</code> Output image size <code>line_width</code> integer Stroke thickness <code>line_color</code> string / tuple Line color <code>bg_color</code> string / tuple Background <code>padding</code> integer Space around chart"},{"location":"api/utils/#example_3","title":"Example","text":"<pre><code>from inkycal.utils.functions import render_line_chart\n\nimg = render_line_chart(\n    values=[1, 3, 2, 4, 6, 5],\n    size=(300, 100)\n)\n</code></pre> <p>Chart output is a Pillow RGBA image, ready to paste into a module\u2019s canvas.</p>"},{"location":"api/utils/#deprecations-migration-notes","title":"\ud83d\udcdd Deprecations &amp; Migration Notes","text":"<p>Some older utility functions were removed during the Inkycal 2.0 refactor:</p> Old function Replacement <code>write()</code> <code>Canvas.write()</code> <code>text_wrap()</code> <code>Canvas.text_wrap()</code> <code>auto_fontsize()</code> <code>Canvas.auto_fontsize()</code> <p>This keeps logic centralized and dramatically improves rendering consistency and performance.</p>"},{"location":"api/utils/#testing-utilities","title":"\ud83e\uddea Testing Utilities","text":"<p>If writing a module that depends on utilities:</p> <ul> <li>Mock <code>requests.get</code> when testing <code>internet_available()</code></li> <li>Use Pillow-generated test images for border functions</li> <li>Avoid pixel-exact assertions unless necessary (ePaper rendering varies)</li> </ul> <p>Examples are available in:</p> <pre><code>tests/test_functions.py\ntests/test_canvas.py\n</code></pre>"},{"location":"api/utils/#summary","title":"\ud83c\udfaf Summary","text":"<p><code>inkycal.utils</code> provides:</p> <ul> <li>Timezone detection  </li> <li>Internet reachability checks  </li> <li>Helpful rendering utilities  </li> <li>Chart plotting  </li> <li>Border-drawing helpers  </li> <li>Clean Pillow wrappers  </li> </ul> <p>For rendering text, icons, and layout, use the high-level:</p> <p>\ud83d\udc49 <code>canvas.md</code></p> <p>For real display output:</p> <p>\ud83d\udc49 <code>display.md</code></p>"},{"location":"modules/calendar/","title":"\ud83d\udcc5 Calendar Module","text":"<p>The Calendar module displays a monthly calendar along with optional upcoming events parsed from one or more iCalendar (<code>.ics</code>) feeds. It is one of the most popular Inkycal modules and is fully configurable via the web-UI.</p> <p>This page explains:</p> <ul> <li>What the module does  </li> <li>How configuration works  </li> <li>How calendar rendering is performed  </li> <li>How event parsing works  </li> <li>How to debug issues with calendars  </li> <li>How to write custom ICS preprocessing logic  </li> </ul>"},{"location":"modules/calendar/#overview","title":"\ud83e\udded Overview","text":"<p>The Calendar module:</p> <ul> <li>Renders a 6\u00d77 monthly grid</li> <li>Displays weekday names in your chosen language</li> <li>Highlights today\u2019s date with a colored circle</li> <li>Marks days containing events</li> <li>Displays upcoming events below the calendar</li> <li>Supports multiple <code>.ics</code> URLs or local files</li> <li>Handles all-day events and multi-day events cleanly</li> </ul>"},{"location":"modules/calendar/#example-output","title":"\ud83d\udce6 Example Output","text":"<p>(You can later replace these mock images with actual screenshots)</p> <pre><code>+--------------------------------------------+\n|                 March 2025                 |\n+--------------------------------------------+\n| Mon   Tue   Wed   Thu   Fri   Sat   Sun    |\n|  3     4     5     6     7     8     9     |\n| ...                                        |\n|           [ \u25cf 12 ]                         |\n| ...                                        |\n+--------------------------------------------+\n| Upcoming Events:                           |\n| 12 Mar \u2013 Doctor appointment 10:00          |\n| 14 Mar \u2013 Anna\u2019s Birthday                   |\n| ...                                        |\n+--------------------------------------------+\n</code></pre> <p>Today\u2019s date is drawn with a circle and white number. Days with events receive a border highlight.</p>"},{"location":"modules/calendar/#configuration-options","title":"\u2699\ufe0f Configuration Options","text":"<p>These options appear in the Web-UI under module settings.</p>"},{"location":"modules/calendar/#required-configuration","title":"Required configuration","text":"<p>The Calendar module has no required parameters. It runs out-of-the-box.</p>"},{"location":"modules/calendar/#optional-configuration","title":"Optional configuration","text":"Key Description Type Default <code>week_starts_on</code> Choose whether weeks start on Monday or Sunday <code>\"Monday\"</code>, <code>\"Sunday\"</code> <code>\"Monday\"</code> <code>show_events</code> Whether to show upcoming events <code>bool</code> <code>True</code> <code>ical_urls</code> One or more ICS URLs (comma-separated) <code>str</code> None <code>ical_files</code> One or more local ICS files <code>str</code> None <code>date_format</code> Arrow format string for dates <code>str</code> <code>\"D MMM\"</code> <code>time_format</code> Arrow format string for event times <code>str</code> <code>\"HH:mm\"</code> <code>language</code> Locale used for month and weekday names <code>str</code> <code>\"en\"</code>"},{"location":"modules/calendar/#how-rendering-works","title":"\ud83e\udde0 How Rendering Works","text":""},{"location":"modules/calendar/#1-layout-allocation","title":"1\ufe0f\u20e3 Layout allocation","text":"<p>The module receives a rendering area:</p> <pre><code>(width, height)\n</code></pre> <p>After subtracting padding, the area is split into:</p> <ol> <li>Month title</li> <li>Weekday header row</li> <li>Calendar grid (6 \u00d7 7)</li> <li>Events section (only if <code>show_events = True</code>)</li> </ol>"},{"location":"modules/calendar/#2-drawing-the-calendar-grid","title":"2\ufe0f\u20e3 Drawing the calendar grid","text":"<p>Each day is placed in a cell:</p> <pre><code>row = week index\ncol = day index\n</code></pre> <p>Bounding boxes for all grid cells are precomputed:</p> <pre><code>grid_coordinates = [\n    (grid_start_x + icon_width * x, grid_start_y + icon_height * y)\n    for y in range(calendar_rows)\n    for x in range(calendar_cols)\n]\n</code></pre>"},{"location":"modules/calendar/#3-highlighting-today","title":"3\ufe0f\u20e3 Highlighting today","text":"<p>A separate temporary <code>Canvas</code> is used to draw:</p> <ul> <li>A circle centered in the day cell</li> <li>The day number in white</li> <li>Properly centered using <code>anchor=\"mm\"</code></li> </ul> <p>This ensures pixel-perfect alignment across displays.</p>"},{"location":"modules/calendar/#4-marking-event-days","title":"4\ufe0f\u20e3 Marking event days","text":"<p>Every event is expanded into all days between start and end:</p> <pre><code>for day in arrow.Arrow.range('day', start, end):\n    days_with_events.append(day.day)\n</code></pre> <p>All unique days then receive a rounded border.</p>"},{"location":"modules/calendar/#5-event-rendering","title":"5\ufe0f\u20e3 Event rendering","text":"<p>Upcoming events (up to 4 weeks in advance) are shown below the calendar:</p> <ul> <li>Date is drawn left-aligned</li> <li>Time (if not all-day) is drawn next to date</li> <li>Title fills the remaining space</li> <li>Multi-day events display a human-readable duration:</li> </ul> <p>Example:</p> <pre><code>2 days \u2192 \"(in 2 days)\"\n</code></pre> <p>Line wrapping is handled by the Canvas engine.</p>"},{"location":"modules/calendar/#parsing-icalendar-files","title":"\ud83d\udd17 Parsing iCalendar Files","text":"<p>The module uses:</p> <pre><code>inkycal.utils.ical_parser.iCalendar\n</code></pre> <p>This parser:</p> <ul> <li>Loads <code>.ics</code> URLs</li> <li>Loads local <code>.ics</code> files</li> <li>Sorts events by start date</li> <li>Normalizes timezone-aware values</li> <li>Detects all-day events via:</li> </ul> <pre><code>parser.all_day(event)\n</code></pre> <p>You can pass multiple calendar URLs or files.</p>"},{"location":"modules/calendar/#full-rendering-flow","title":"\ud83d\udcd8 Full Rendering Flow","text":"<pre><code>Calendar.generate_image()\n    |\n    +--&gt; Compute layout regions\n    +--&gt; Create Canvas\n    +--&gt; Draw month &amp; weekdays\n    +--&gt; Build month grid\n    +--&gt; Highlight today\n    +--&gt; Retrieve + parse ICS events\n    +--&gt; Draw event-day borders\n    +--&gt; Draw upcoming events list\n    +--&gt; Return (black_img, colour_img)\n</code></pre>"},{"location":"modules/calendar/#tips-for-better-calendar-results","title":"\ud83d\udd27 Tips for Better Calendar Results","text":""},{"location":"modules/calendar/#choose-readable-fonts","title":"\u2714 Choose readable fonts","text":"<p>If using languages like Chinese, Japanese, Korean\u2014ensure CJK fonts are installed.</p>"},{"location":"modules/calendar/#ensure-ics-urls-support-https","title":"\u2714 Ensure ICS URLs support HTTPS","text":"<p>Many servers block plain HTTP.</p>"},{"location":"modules/calendar/#verify-timezones","title":"\u2714 Verify timezones","text":"<p>If events show at wrong times: - Confirm Raspberry Pi timezone via <code>sudo dpkg-reconfigure tzdata</code> - Check ICS feed timezone fields</p>"},{"location":"modules/calendar/#reduce-event-clutter","title":"\u2714 Reduce event clutter","text":"<p>Use filters in your calendar service if available.</p>"},{"location":"modules/calendar/#troubleshooting","title":"\ud83e\uddea Troubleshooting","text":""},{"location":"modules/calendar/#events-are-missing","title":"\u274c Events are missing","text":"<p>Checklist:</p> <ul> <li>Does ICS feed load in the browser?</li> <li>Are there events in the next 4 weeks? (default range)</li> <li>Is <code>show_events</code> enabled?</li> </ul>"},{"location":"modules/calendar/#wrong-date-formatting","title":"\u274c Wrong date formatting","text":"<p>Your locale may not support certain month abbreviations. Try a standard format:</p> <pre><code>D MMMM\nMMM DD\n</code></pre>"},{"location":"modules/calendar/#today-circle-misaligned","title":"\u274c Today circle misaligned","text":"<p>This usually means:</p> <ul> <li>Canvas font height was oversized  </li> <li>Day cell height too small  </li> <li>Incorrect DPI scaling on custom displays  </li> </ul> <p>Try lowering font size by 10\u201320%.</p>"},{"location":"modules/calendar/#extending-the-calendar-module","title":"\ud83e\udde9 Extending the Calendar Module","text":"<p>You may want to:</p> <ul> <li>Add holiday highlights</li> <li>Add weather integration into each day cell</li> <li>Display week numbers</li> <li>Replace circle highlight with a rectangle or icon</li> </ul> <p>All changes should be made in:</p> <pre><code>inkycal/modules/calendar.py\n</code></pre> <p>And rendered using:</p> <pre><code>Canvas.write(...)\nCanvas.draw_icon(...)\nCanvas utilities\n</code></pre>"},{"location":"modules/calendar/#summary","title":"\ud83d\udcc4 Summary","text":"<p>The Calendar module is a powerful, flexible, and highly customizable component. It makes heavy use of the Canvas abstraction to guarantee:</p> <ul> <li>Consistent rendering  </li> <li>Alignment across displays  </li> <li>Efficient pixel usage  </li> <li>Multi-language support  </li> </ul> <p>It remains one of the most mature and well-tested parts of Inkycal.</p> <p>If you are creating your own module, studying this one is an excellent place to start.</p>"}]}